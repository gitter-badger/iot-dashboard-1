webpackJsonp([1],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(304);


/***/ },

/***/ 304:
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(305);\nmocha.setup(\"bdd\");\n__webpack_require__(313)\n__webpack_require__(318);\nif(true) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(function() {\n\t\tmocha.suite.suites.length = 0;\n\t\tvar stats = document.getElementById('mocha-stats');\n\t\tvar report = document.getElementById('mocha-report');\n\t\tstats.parentNode.removeChild(stats);\n\t\treport.parentNode.removeChild(report);\n\t});\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3Rlc3RzLmpzP2Q5MjAiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3dlYi5qc1wiKTtcbm1vY2hhLnNldHVwKFwiYmRkXCIpO1xucmVxdWlyZShcIiEhL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2luZGV4LmpzP2NhY2hlRGlyZWN0b3J5IS9ob21lL3RyYXZpcy9idWlsZC9OaW9uZGlyL2lvdC1kYXNoYm9hcmQvc3JjL3Rlc3RzLmpzXCIpXG5yZXF1aXJlKFwiISEvaG9tZS90cmF2aXMvYnVpbGQvTmlvbmRpci9pb3QtZGFzaGJvYXJkL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvc3RhcnQuanNcIik7XG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KCk7XG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcblx0XHRtb2NoYS5zdWl0ZS5zdWl0ZXMubGVuZ3RoID0gMDtcblx0XHR2YXIgc3RhdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEtc3RhdHMnKTtcblx0XHR2YXIgcmVwb3J0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXJlcG9ydCcpO1xuXHRcdHN0YXRzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHMpO1xuXHRcdHJlcG9ydC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlcG9ydCk7XG5cdH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vY2hhLWxvYWRlciEuL3NyYy90ZXN0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDMwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 305:
/***/ function(module, exports, __webpack_require__) {

	eval("if (! document.getElementById(\"mocha\")) { document.write(\"<div id=\\\"mocha\\\"></div>\"); }\r\n\r\n__webpack_require__(306);\r\n__webpack_require__(310);\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS1sb2FkZXIvd2ViLmpzPzI5MzEiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKCEgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2NoYVwiKSkgeyBkb2N1bWVudC53cml0ZShcIjxkaXYgaWQ9XFxcIm1vY2hhXFxcIj48L2Rpdj5cIik7IH1cclxuXHJcbnJlcXVpcmUoXCIhc3R5bGUhY3NzIW1vY2hhL21vY2hhLmNzc1wiKTtcclxucmVxdWlyZShcIiFzY3JpcHQhbW9jaGEvbW9jaGEuanNcIik7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vY2hhLWxvYWRlci93ZWIuanNcbiAqKiBtb2R1bGUgaWQgPSAzMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 306:
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(307);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(309)(content, {});\n// Hot Module Replacement\nif(true) {\n\t// When the styles change, update the <style> tags\n\tmodule.hot.accept(307, function() {\n\t\tvar newContent = __webpack_require__(307);\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\tupdate(newContent);\n\t});\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS9tb2NoYS5jc3M/NzVkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS9ob21lL3RyYXZpcy9idWlsZC9OaW9uZGlyL2lvdC1kYXNoYm9hcmQvbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS9ob21lL3RyYXZpcy9idWlsZC9OaW9uZGlyL2lvdC1kYXNoYm9hcmQvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEvaG9tZS90cmF2aXMvYnVpbGQvTmlvbmRpci9pb3QtZGFzaGJvYXJkL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEvaG9tZS90cmF2aXMvYnVpbGQvTmlvbmRpci9pb3QtZGFzaGJvYXJkL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuY3NzXCIpO1xuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9jaGEtbG9hZGVyL34vc3R5bGUtbG9hZGVyIS4vfi9tb2NoYS1sb2FkZXIvfi9jc3MtbG9hZGVyIS4vfi9tb2NoYS9tb2NoYS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAzMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 307:
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(308)();\nexports.push([module.id, \"@charset \\\"utf-8\\\";\\n\\nbody {\\n  margin:0;\\n}\\n\\n#mocha {\\n  font: 20px/1.5 \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n  margin: 60px 50px;\\n}\\n\\n#mocha ul,\\n#mocha li {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n#mocha ul {\\n  list-style: none;\\n}\\n\\n#mocha h1,\\n#mocha h2 {\\n  margin: 0;\\n}\\n\\n#mocha h1 {\\n  margin-top: 15px;\\n  font-size: 1em;\\n  font-weight: 200;\\n}\\n\\n#mocha h1 a {\\n  text-decoration: none;\\n  color: inherit;\\n}\\n\\n#mocha h1 a:hover {\\n  text-decoration: underline;\\n}\\n\\n#mocha .suite .suite h1 {\\n  margin-top: 0;\\n  font-size: .8em;\\n}\\n\\n#mocha .hidden {\\n  display: none;\\n}\\n\\n#mocha h2 {\\n  font-size: 12px;\\n  font-weight: normal;\\n  cursor: pointer;\\n}\\n\\n#mocha .suite {\\n  margin-left: 15px;\\n}\\n\\n#mocha .test {\\n  margin-left: 15px;\\n  overflow: hidden;\\n}\\n\\n#mocha .test.pending:hover h2::after {\\n  content: '(pending)';\\n  font-family: arial, sans-serif;\\n}\\n\\n#mocha .test.pass.medium .duration {\\n  background: #c09853;\\n}\\n\\n#mocha .test.pass.slow .duration {\\n  background: #b94a48;\\n}\\n\\n#mocha .test.pass::before {\\n  content: '✓';\\n  font-size: 12px;\\n  display: block;\\n  float: left;\\n  margin-right: 5px;\\n  color: #00d6b2;\\n}\\n\\n#mocha .test.pass .duration {\\n  font-size: 9px;\\n  margin-left: 5px;\\n  padding: 2px 5px;\\n  color: #fff;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\\n  -webkit-border-radius: 5px;\\n  -moz-border-radius: 5px;\\n  -ms-border-radius: 5px;\\n  -o-border-radius: 5px;\\n  border-radius: 5px;\\n}\\n\\n#mocha .test.pass.fast .duration {\\n  display: none;\\n}\\n\\n#mocha .test.pending {\\n  color: #0b97c4;\\n}\\n\\n#mocha .test.pending::before {\\n  content: '◦';\\n  color: #0b97c4;\\n}\\n\\n#mocha .test.fail {\\n  color: #c00;\\n}\\n\\n#mocha .test.fail pre {\\n  color: black;\\n}\\n\\n#mocha .test.fail::before {\\n  content: '✖';\\n  font-size: 12px;\\n  display: block;\\n  float: left;\\n  margin-right: 5px;\\n  color: #c00;\\n}\\n\\n#mocha .test pre.error {\\n  color: #c00;\\n  max-height: 300px;\\n  overflow: auto;\\n}\\n\\n#mocha .test .html-error {\\n  overflow: auto;\\n  color: black;\\n  line-height: 1.5;\\n  display: block;\\n  float: left;\\n  clear: left;\\n  font: 12px/1.5 monaco, monospace;\\n  margin: 5px;\\n  padding: 15px;\\n  border: 1px solid #eee;\\n  max-width: 85%; /*(1)*/\\n  max-width: calc(100% - 42px); /*(2)*/\\n  max-height: 300px;\\n  word-wrap: break-word;\\n  border-bottom-color: #ddd;\\n  -webkit-border-radius: 3px;\\n  -webkit-box-shadow: 0 1px 3px #eee;\\n  -moz-border-radius: 3px;\\n  -moz-box-shadow: 0 1px 3px #eee;\\n  border-radius: 3px;\\n}\\n\\n#mocha .test .html-error pre.error {\\n  border: none;\\n  -webkit-border-radius: none;\\n  -webkit-box-shadow: none;\\n  -moz-border-radius: none;\\n  -moz-box-shadow: none;\\n  padding: 0;\\n  margin: 0;\\n  margin-top: 18px;\\n  max-height: none;\\n}\\n\\n/**\\n * (1): approximate for browsers not supporting calc\\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\\n *      ^^ seriously\\n */\\n#mocha .test pre {\\n  display: block;\\n  float: left;\\n  clear: left;\\n  font: 12px/1.5 monaco, monospace;\\n  margin: 5px;\\n  padding: 15px;\\n  border: 1px solid #eee;\\n  max-width: 85%; /*(1)*/\\n  max-width: calc(100% - 42px); /*(2)*/\\n  word-wrap: break-word;\\n  border-bottom-color: #ddd;\\n  -webkit-border-radius: 3px;\\n  -webkit-box-shadow: 0 1px 3px #eee;\\n  -moz-border-radius: 3px;\\n  -moz-box-shadow: 0 1px 3px #eee;\\n  border-radius: 3px;\\n}\\n\\n#mocha .test h2 {\\n  position: relative;\\n}\\n\\n#mocha .test a.replay {\\n  position: absolute;\\n  top: 3px;\\n  right: 0;\\n  text-decoration: none;\\n  vertical-align: middle;\\n  display: block;\\n  width: 15px;\\n  height: 15px;\\n  line-height: 15px;\\n  text-align: center;\\n  background: #eee;\\n  font-size: 15px;\\n  -moz-border-radius: 15px;\\n  border-radius: 15px;\\n  -webkit-transition: opacity 200ms;\\n  -moz-transition: opacity 200ms;\\n  transition: opacity 200ms;\\n  opacity: 0.3;\\n  color: #888;\\n}\\n\\n#mocha .test:hover a.replay {\\n  opacity: 1;\\n}\\n\\n#mocha-report.pass .test.fail {\\n  display: none;\\n}\\n\\n#mocha-report.fail .test.pass {\\n  display: none;\\n}\\n\\n#mocha-report.pending .test.pass,\\n#mocha-report.pending .test.fail {\\n  display: none;\\n}\\n#mocha-report.pending .test.pass.pending {\\n  display: block;\\n}\\n\\n#mocha-error {\\n  color: #c00;\\n  font-size: 1.5em;\\n  font-weight: 100;\\n  letter-spacing: 1px;\\n}\\n\\n#mocha-stats {\\n  position: fixed;\\n  top: 15px;\\n  right: 10px;\\n  font-size: 12px;\\n  margin: 0;\\n  color: #888;\\n  z-index: 1;\\n}\\n\\n#mocha-stats .progress {\\n  float: right;\\n  padding-top: 0;\\n  \\n  /**\\n   * Set safe initial values, so mochas .progress does not inherit these\\n   * properties from Bootstrap .progress (which causes .progress height to\\n   * equal line height set in Bootstrap).\\n   */\\n  height: auto;\\n  box-shadow: none;\\n  background-color: initial;\\n}\\n\\n#mocha-stats em {\\n  color: black;\\n}\\n\\n#mocha-stats a {\\n  text-decoration: none;\\n  color: inherit;\\n}\\n\\n#mocha-stats a:hover {\\n  border-bottom: 1px solid #eee;\\n}\\n\\n#mocha-stats li {\\n  display: inline-block;\\n  margin: 0 5px;\\n  list-style: none;\\n  padding-top: 11px;\\n}\\n\\n#mocha-stats canvas {\\n  width: 40px;\\n  height: 40px;\\n}\\n\\n#mocha code .comment { color: #ddd; }\\n#mocha code .init { color: #2f6fad; }\\n#mocha code .string { color: #5890ad; }\\n#mocha code .keyword { color: #8a6343; }\\n#mocha code .number { color: #2f6fad; }\\n\\n@media screen and (max-device-width: 480px) {\\n  #mocha {\\n    margin: 60px 0px;\\n  }\\n\\n  #mocha #stats {\\n    position: absolute;\\n  }\\n}\\n\", \"\"]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS9tb2NoYS5jc3M/YTM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Nzc1RvU3RyaW5nLmpzXCIpKCk7XG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwidXRmLThcXFwiO1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOjA7XFxufVxcblxcbiNtb2NoYSB7XFxuICBmb250OiAyMHB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgbWFyZ2luOiA2MHB4IDUwcHg7XFxufVxcblxcbiNtb2NoYSB1bCxcXG4jbW9jaGEgbGkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuI21vY2hhIHVsIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbiNtb2NoYSBoMSxcXG4jbW9jaGEgaDIge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jbW9jaGEgaDEge1xcbiAgbWFyZ2luLXRvcDogMTVweDtcXG4gIGZvbnQtc2l6ZTogMWVtO1xcbiAgZm9udC13ZWlnaHQ6IDIwMDtcXG59XFxuXFxuI21vY2hhIGgxIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYSBoMSBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4jbW9jaGEgLnN1aXRlIC5zdWl0ZSBoMSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgZm9udC1zaXplOiAuOGVtO1xcbn1cXG5cXG4jbW9jaGEgLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgaDIge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI21vY2hhIC5zdWl0ZSB7XFxuICBtYXJnaW4tbGVmdDogMTVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6aG92ZXIgaDI6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcocGVuZGluZyknO1xcbiAgZm9udC1mYW1pbHk6IGFyaWFsLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5tZWRpdW0gLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNjMDk4NTM7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLnNsb3cgLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNiOTRhNDg7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzOjpiZWZvcmUge1xcbiAgY29udGVudDogJ+Kckyc7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogIzAwZDZiMjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MgLmR1cmF0aW9uIHtcXG4gIGZvbnQtc2l6ZTogOXB4O1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIHBhZGRpbmc6IDJweCA1cHg7XFxuICBjb2xvcjogI2ZmZjtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpO1xcbiAgLW1vei1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1zLWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1vLWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MuZmFzdCAuZHVyYXRpb24ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmcge1xcbiAgY29sb3I6ICMwYjk3YzQ7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wZW5kaW5nOjpiZWZvcmUge1xcbiAgY29udGVudDogJ+KXpic7XFxuICBjb2xvcjogIzBiOTdjNDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWwge1xcbiAgY29sb3I6ICNjMDA7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsIHByZSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsOjpiZWZvcmUge1xcbiAgY29udGVudDogJ+Kclic7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHByZS5lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciB7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGNvbG9yOiBibGFjaztcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgbWF4LWhlaWdodDogMzAwcHg7XFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICAtbW96LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgLmh0bWwtZXJyb3IgcHJlLmVycm9yIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogbm9uZTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogbm9uZTtcXG4gIC1tb3otYm94LXNoYWRvdzogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICBtYXJnaW4tdG9wOiAxOHB4O1xcbiAgbWF4LWhlaWdodDogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogKDEpOiBhcHByb3hpbWF0ZSBmb3IgYnJvd3NlcnMgbm90IHN1cHBvcnRpbmcgY2FsY1xcbiAqICgyKTogNDIgPSAyKjE1ICsgMioxMCArIDIqMSAocGFkZGluZyArIG1hcmdpbiArIGJvcmRlcilcXG4gKiAgICAgIF5eIHNlcmlvdXNseVxcbiAqL1xcbiNtb2NoYSAudGVzdCBwcmUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udDogMTJweC8xLjUgbW9uYWNvLCBtb25vc3BhY2U7XFxuICBtYXJnaW46IDVweDtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbWF4LXdpZHRoOiA4NSU7IC8qKDEpKi9cXG4gIG1heC13aWR0aDogY2FsYygxMDAlIC0gNDJweCk7IC8qKDIpKi9cXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNkZGQ7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCBoMiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbiNtb2NoYSAudGVzdCBhLnJlcGxheSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDNweDtcXG4gIHJpZ2h0OiAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDE1cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxuICBsaW5lLWhlaWdodDogMTVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xcbiAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcXG4gIG9wYWNpdHk6IDAuMztcXG4gIGNvbG9yOiAjODg4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3Q6aG92ZXIgYS5yZXBsYXkge1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuI21vY2hhLXJlcG9ydC5wYXNzIC50ZXN0LmZhaWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhLXJlcG9ydC5mYWlsIC50ZXN0LnBhc3Mge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhLXJlcG9ydC5wZW5kaW5nIC50ZXN0LnBhc3MsXFxuI21vY2hhLXJlcG9ydC5wZW5kaW5nIC50ZXN0LmZhaWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuI21vY2hhLXJlcG9ydC5wZW5kaW5nIC50ZXN0LnBhc3MucGVuZGluZyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuI21vY2hhLWVycm9yIHtcXG4gIGNvbG9yOiAjYzAwO1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG4gIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICBsZXR0ZXItc3BhY2luZzogMXB4O1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAxNXB4O1xcbiAgcmlnaHQ6IDEwcHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuICBjb2xvcjogIzg4ODtcXG4gIHotaW5kZXg6IDE7XFxufVxcblxcbiNtb2NoYS1zdGF0cyAucHJvZ3Jlc3Mge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgcGFkZGluZy10b3A6IDA7XFxuICBcXG4gIC8qKlxcbiAgICogU2V0IHNhZmUgaW5pdGlhbCB2YWx1ZXMsIHNvIG1vY2hhcyAucHJvZ3Jlc3MgZG9lcyBub3QgaW5oZXJpdCB0aGVzZVxcbiAgICogcHJvcGVydGllcyBmcm9tIEJvb3RzdHJhcCAucHJvZ3Jlc3MgKHdoaWNoIGNhdXNlcyAucHJvZ3Jlc3MgaGVpZ2h0IHRvXFxuICAgKiBlcXVhbCBsaW5lIGhlaWdodCBzZXQgaW4gQm9vdHN0cmFwKS5cXG4gICAqL1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBlbSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgYTpob3ZlciB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGxpIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbjogMCA1cHg7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgcGFkZGluZy10b3A6IDExcHg7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBjYW52YXMge1xcbiAgd2lkdGg6IDQwcHg7XFxuICBoZWlnaHQ6IDQwcHg7XFxufVxcblxcbiNtb2NoYSBjb2RlIC5jb21tZW50IHsgY29sb3I6ICNkZGQ7IH1cXG4jbW9jaGEgY29kZSAuaW5pdCB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuI21vY2hhIGNvZGUgLnN0cmluZyB7IGNvbG9yOiAjNTg5MGFkOyB9XFxuI21vY2hhIGNvZGUgLmtleXdvcmQgeyBjb2xvcjogIzhhNjM0MzsgfVxcbiNtb2NoYSBjb2RlIC5udW1iZXIgeyBjb2xvcjogIzJmNmZhZDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtZGV2aWNlLXdpZHRoOiA0ODBweCkge1xcbiAgI21vY2hhIHtcXG4gICAgbWFyZ2luOiA2MHB4IDBweDtcXG4gIH1cXG5cXG4gICNtb2NoYSAjc3RhdHMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB9XFxufVxcblwiLCBcIlwiXSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9jaGEtbG9hZGVyL34vY3NzLWxvYWRlciEuL34vbW9jaGEvbW9jaGEuY3NzXG4gKiogbW9kdWxlIGlkID0gMzA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 308:
/***/ function(module, exports) {

	eval("module.exports = function() {\r\n\tvar list = [];\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\treturn list;\r\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS1sb2FkZXIvfi9jc3MtbG9hZGVyL2Nzc1RvU3RyaW5nLmpzP2MwZjUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2NoYS1sb2FkZXIvfi9jc3MtbG9hZGVyL2Nzc1RvU3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMzA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 309:
/***/ function(module, exports, __webpack_require__) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisIE9 = memoize(function() {\r\n\t\treturn /msie 9\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(false) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isIE9();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function () {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction replaceText(source, id, replacement) {\r\n\tvar boundaries = [\"/** >>\" + id + \" **/\", \"/** \" + id + \"<< **/\"];\r\n\tvar start = source.lastIndexOf(boundaries[0]);\r\n\tvar wrappedReplacement = replacement\r\n\t\t? (boundaries[0] + replacement + boundaries[1])\r\n\t\t: \"\";\r\n\tif (source.lastIndexOf(boundaries[0]) >= 0) {\r\n\t\tvar end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;\r\n\t\treturn source.slice(0, start) + wrappedReplacement + source.slice(end);\r\n\t} else {\r\n\t\treturn source + wrappedReplacement;\r\n\t}\r\n}\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap && typeof btoa === \"function\") {\r\n\t\ttry {\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t\t\tcss = \"@import url(\\\"data:text/css;base64,\" + btoa(css) + \"\\\")\";\r\n\t\t} catch(e) {}\r\n\t}\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS1sb2FkZXIvfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzPzc4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzSUU5ID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSA5XFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDA7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzSUU5KCk7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlVGV4dChzb3VyY2UsIGlkLCByZXBsYWNlbWVudCkge1xyXG5cdHZhciBib3VuZGFyaWVzID0gW1wiLyoqID4+XCIgKyBpZCArIFwiICoqL1wiLCBcIi8qKiBcIiArIGlkICsgXCI8PCAqKi9cIl07XHJcblx0dmFyIHN0YXJ0ID0gc291cmNlLmxhc3RJbmRleE9mKGJvdW5kYXJpZXNbMF0pO1xyXG5cdHZhciB3cmFwcGVkUmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudFxyXG5cdFx0PyAoYm91bmRhcmllc1swXSArIHJlcGxhY2VtZW50ICsgYm91bmRhcmllc1sxXSlcclxuXHRcdDogXCJcIjtcclxuXHRpZiAoc291cmNlLmxhc3RJbmRleE9mKGJvdW5kYXJpZXNbMF0pID49IDApIHtcclxuXHRcdHZhciBlbmQgPSBzb3VyY2UubGFzdEluZGV4T2YoYm91bmRhcmllc1sxXSkgKyBib3VuZGFyaWVzWzFdLmxlbmd0aDtcclxuXHRcdHJldHVybiBzb3VyY2Uuc2xpY2UoMCwgc3RhcnQpICsgd3JhcHBlZFJlcGxhY2VtZW50ICsgc291cmNlLnNsaWNlKGVuZCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBzb3VyY2UgKyB3cmFwcGVkUmVwbGFjZW1lbnQ7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQsIGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpICsgXCIgKi9cIjtcclxuXHRcdFx0Y3NzID0gXCJAaW1wb3J0IHVybChcXFwiZGF0YTp0ZXh0L2NzcztiYXNlNjQsXCIgKyBidG9hKGNzcykgKyBcIlxcXCIpXCI7XHJcblx0XHR9IGNhdGNoKGUpIHt9XHJcblx0fVxyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vY2hhLWxvYWRlci9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 310:
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(311)(__webpack_require__(312))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS9tb2NoYS5qcz9kMThlIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9ob21lL3RyYXZpcy9idWlsZC9OaW9uZGlyL2lvdC1kYXNoYm9hcmQvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL3RyYXZpcy9idWlsZC9OaW9uZGlyL2lvdC1kYXNoYm9hcmQvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvdHJhdmlzL2J1aWxkL05pb25kaXIvaW90LWRhc2hib2FyZC9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL34vbW9jaGEvbW9jaGEuanNcbiAqKiBtb2R1bGUgaWQgPSAzMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 311:
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript === \"function\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcz84MTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XHJcblx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ID09PSBcImZ1bmN0aW9uXCIpXHJcblx0XHRleGVjU2NyaXB0KHNyYyk7XHJcblx0ZWxzZVxyXG5cdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XHJcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 312:
/***/ function(module, exports) {

	eval("module.exports = \"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Shim process.stdout.\\n */\\n\\nprocess.stdout = require('browser-stdout')();\\n\\nvar Mocha = require('./lib/mocha');\\n\\n/**\\n * Create a Mocha instance.\\n *\\n * @return {undefined}\\n */\\n\\nvar mocha = new Mocha({ reporter: 'html' });\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n\\nvar uncaughtExceptionHandlers = [];\\n\\nvar originalOnerrorHandler = global.onerror;\\n\\n/**\\n * Remove uncaughtException listener.\\n * Revert to original onerror handler if previously defined.\\n */\\n\\nprocess.removeListener = function(e, fn){\\n  if ('uncaughtException' == e) {\\n    if (originalOnerrorHandler) {\\n      global.onerror = originalOnerrorHandler;\\n    } else {\\n      global.onerror = function() {};\\n    }\\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\\n    if (i != -1) { uncaughtExceptionHandlers.splice(i, 1); }\\n  }\\n};\\n\\n/**\\n * Implements uncaughtException listener.\\n */\\n\\nprocess.on = function(e, fn){\\n  if ('uncaughtException' == e) {\\n    global.onerror = function(err, url, line){\\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\\n      return !mocha.allowUncaught;\\n    };\\n    uncaughtExceptionHandlers.push(fn);\\n  }\\n};\\n\\n// The BDD UI is registered by default, but no UI will be functional in the\\n// browser without an explicit call to the overridden `mocha.ui` (see below).\\n// Ensure that this default UI does not expose its methods to the global scope.\\nmocha.suite.removeAllListeners('pre-require');\\n\\nvar immediateQueue = []\\n  , immediateTimeout;\\n\\nfunction timeslice() {\\n  var immediateStart = new Date().getTime();\\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\\n    immediateQueue.shift()();\\n  }\\n  if (immediateQueue.length) {\\n    immediateTimeout = setTimeout(timeslice, 0);\\n  } else {\\n    immediateTimeout = null;\\n  }\\n}\\n\\n/**\\n * High-performance override of Runner.immediately.\\n */\\n\\nMocha.Runner.immediately = function(callback) {\\n  immediateQueue.push(callback);\\n  if (!immediateTimeout) {\\n    immediateTimeout = setTimeout(timeslice, 0);\\n  }\\n};\\n\\n/**\\n * Function to allow assertion libraries to throw errors directly into mocha.\\n * This is useful when running tests in a browser because window.onerror will\\n * only receive the 'message' attribute of the Error.\\n */\\nmocha.throwError = function(err) {\\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\\n    fn(err);\\n  });\\n  throw err;\\n};\\n\\n/**\\n * Override ui to ensure that the ui functions are initialized.\\n * Normally this would happen in Mocha.prototype.loadFiles.\\n */\\n\\nmocha.ui = function(ui){\\n  Mocha.prototype.ui.call(this, ui);\\n  this.suite.emit('pre-require', global, null, this);\\n  return this;\\n};\\n\\n/**\\n * Setup mocha with the given setting options.\\n */\\n\\nmocha.setup = function(opts){\\n  if ('string' == typeof opts) opts = { ui: opts };\\n  for (var opt in opts) this[opt](opts[opt]);\\n  return this;\\n};\\n\\n/**\\n * Run mocha, returning the Runner.\\n */\\n\\nmocha.run = function(fn){\\n  var options = mocha.options;\\n  mocha.globals('location');\\n\\n  var query = Mocha.utils.parseQuery(global.location.search || '');\\n  if (query.grep) mocha.grep(new RegExp(query.grep));\\n  if (query.fgrep) mocha.grep(query.fgrep);\\n  if (query.invert) mocha.invert();\\n\\n  return Mocha.prototype.run.call(mocha, function(err){\\n    // The DOM Document is not available in Web Workers.\\n    var document = global.document;\\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\\n      Mocha.utils.highlightTags('code');\\n    }\\n    if (fn) fn(err);\\n  });\\n};\\n\\n/**\\n * Expose the process shim.\\n * https://github.com/mochajs/mocha/pull/916\\n */\\n\\nMocha.process = process;\\n\\n/**\\n * Expose mocha.\\n */\\n\\nglobal.Mocha = Mocha;\\nglobal.mocha = mocha;\\n\\n// this allows test/acceptance/required-tokens.js to pass; thus,\\n// you can now do `const describe = require('mocha').describe` in a\\n// browser context (assuming browserification).  should fix #880\\nmodule.exports = global;\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./lib/mocha\\\":14,\\\"_process\\\":58,\\\"browser-stdout\\\":42}],2:[function(require,module,exports){\\n/* eslint-disable no-unused-vars */\\nmodule.exports = function(type) {\\n  return function() {};\\n};\\n\\n},{}],3:[function(require,module,exports){\\n/**\\n * Module exports.\\n */\\n\\nexports.EventEmitter = EventEmitter;\\n\\n/**\\n * Object#toString reference.\\n */\\nvar objToString = Object.prototype.toString;\\n\\n/**\\n * Check if a value is an array.\\n *\\n * @api private\\n * @param {*} val The value to test.\\n * @return {boolean} true if the value is an array, otherwise false.\\n */\\nfunction isArray(val) {\\n  return objToString.call(val) === '[object Array]';\\n}\\n\\n/**\\n * Event emitter constructor.\\n *\\n * @api public\\n */\\nfunction EventEmitter() {}\\n\\n/**\\n * Add a listener.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @param {Function} fn Event handler.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.on = function(name, fn) {\\n  if (!this.$events) {\\n    this.$events = {};\\n  }\\n\\n  if (!this.$events[name]) {\\n    this.$events[name] = fn;\\n  } else if (isArray(this.$events[name])) {\\n    this.$events[name].push(fn);\\n  } else {\\n    this.$events[name] = [this.$events[name], fn];\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\\n\\n/**\\n * Adds a volatile listener.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @param {Function} fn Event handler.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.once = function(name, fn) {\\n  var self = this;\\n\\n  function on() {\\n    self.removeListener(name, on);\\n    fn.apply(this, arguments);\\n  }\\n\\n  on.listener = fn;\\n  this.on(name, on);\\n\\n  return this;\\n};\\n\\n/**\\n * Remove a listener.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @param {Function} fn Event handler.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.removeListener = function(name, fn) {\\n  if (this.$events && this.$events[name]) {\\n    var list = this.$events[name];\\n\\n    if (isArray(list)) {\\n      var pos = -1;\\n\\n      for (var i = 0, l = list.length; i < l; i++) {\\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\\n          pos = i;\\n          break;\\n        }\\n      }\\n\\n      if (pos < 0) {\\n        return this;\\n      }\\n\\n      list.splice(pos, 1);\\n\\n      if (!list.length) {\\n        delete this.$events[name];\\n      }\\n    } else if (list === fn || (list.listener && list.listener === fn)) {\\n      delete this.$events[name];\\n    }\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Remove all listeners for an event.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.removeAllListeners = function(name) {\\n  if (name === undefined) {\\n    this.$events = {};\\n    return this;\\n  }\\n\\n  if (this.$events && this.$events[name]) {\\n    this.$events[name] = null;\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Get all listeners for a given event.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.listeners = function(name) {\\n  if (!this.$events) {\\n    this.$events = {};\\n  }\\n\\n  if (!this.$events[name]) {\\n    this.$events[name] = [];\\n  }\\n\\n  if (!isArray(this.$events[name])) {\\n    this.$events[name] = [this.$events[name]];\\n  }\\n\\n  return this.$events[name];\\n};\\n\\n/**\\n * Emit an event.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @return {boolean} true if at least one handler was invoked, else false.\\n */\\nEventEmitter.prototype.emit = function(name) {\\n  if (!this.$events) {\\n    return false;\\n  }\\n\\n  var handler = this.$events[name];\\n\\n  if (!handler) {\\n    return false;\\n  }\\n\\n  var args = Array.prototype.slice.call(arguments, 1);\\n\\n  if (typeof handler === 'function') {\\n    handler.apply(this, args);\\n  } else if (isArray(handler)) {\\n    var listeners = handler.slice();\\n\\n    for (var i = 0, l = listeners.length; i < l; i++) {\\n      listeners[i].apply(this, args);\\n    }\\n  } else {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n\\n},{}],4:[function(require,module,exports){\\n/**\\n * Expose `Progress`.\\n */\\n\\nmodule.exports = Progress;\\n\\n/**\\n * Initialize a new `Progress` indicator.\\n */\\nfunction Progress() {\\n  this.percent = 0;\\n  this.size(0);\\n  this.fontSize(11);\\n  this.font('helvetica, arial, sans-serif');\\n}\\n\\n/**\\n * Set progress size to `size`.\\n *\\n * @api public\\n * @param {number} size\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.size = function(size) {\\n  this._size = size;\\n  return this;\\n};\\n\\n/**\\n * Set text to `text`.\\n *\\n * @api public\\n * @param {string} text\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.text = function(text) {\\n  this._text = text;\\n  return this;\\n};\\n\\n/**\\n * Set font size to `size`.\\n *\\n * @api public\\n * @param {number} size\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.fontSize = function(size) {\\n  this._fontSize = size;\\n  return this;\\n};\\n\\n/**\\n * Set font to `family`.\\n *\\n * @param {string} family\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.font = function(family) {\\n  this._font = family;\\n  return this;\\n};\\n\\n/**\\n * Update percentage to `n`.\\n *\\n * @param {number} n\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.update = function(n) {\\n  this.percent = n;\\n  return this;\\n};\\n\\n/**\\n * Draw on `ctx`.\\n *\\n * @param {CanvasRenderingContext2d} ctx\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.draw = function(ctx) {\\n  try {\\n    var percent = Math.min(this.percent, 100);\\n    var size = this._size;\\n    var half = size / 2;\\n    var x = half;\\n    var y = half;\\n    var rad = half - 1;\\n    var fontSize = this._fontSize;\\n\\n    ctx.font = fontSize + 'px ' + this._font;\\n\\n    var angle = Math.PI * 2 * (percent / 100);\\n    ctx.clearRect(0, 0, size, size);\\n\\n    // outer circle\\n    ctx.strokeStyle = '#9f9f9f';\\n    ctx.beginPath();\\n    ctx.arc(x, y, rad, 0, angle, false);\\n    ctx.stroke();\\n\\n    // inner circle\\n    ctx.strokeStyle = '#eee';\\n    ctx.beginPath();\\n    ctx.arc(x, y, rad - 1, 0, angle, true);\\n    ctx.stroke();\\n\\n    // text\\n    var text = this._text || (percent | 0) + '%';\\n    var w = ctx.measureText(text).width;\\n\\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\\n  } catch (err) {\\n    // don't fail if we can't render progress\\n  }\\n  return this;\\n};\\n\\n},{}],5:[function(require,module,exports){\\n(function (global){\\nexports.isatty = function isatty() {\\n  return true;\\n};\\n\\nexports.getWindowSize = function getWindowSize() {\\n  if ('innerHeight' in global) {\\n    return [global.innerHeight, global.innerWidth];\\n  }\\n  // In a Web Worker, the DOM Window is not available.\\n  return [640, 480];\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],6:[function(require,module,exports){\\n/**\\n * Expose `Context`.\\n */\\n\\nmodule.exports = Context;\\n\\n/**\\n * Initialize a new `Context`.\\n *\\n * @api private\\n */\\nfunction Context() {}\\n\\n/**\\n * Set or get the context `Runnable` to `runnable`.\\n *\\n * @api private\\n * @param {Runnable} runnable\\n * @return {Context}\\n */\\nContext.prototype.runnable = function(runnable) {\\n  if (!arguments.length) {\\n    return this._runnable;\\n  }\\n  this.test = this._runnable = runnable;\\n  return this;\\n};\\n\\n/**\\n * Set test timeout `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {Context} self\\n */\\nContext.prototype.timeout = function(ms) {\\n  if (!arguments.length) {\\n    return this.runnable().timeout();\\n  }\\n  this.runnable().timeout(ms);\\n  return this;\\n};\\n\\n/**\\n * Set test timeout `enabled`.\\n *\\n * @api private\\n * @param {boolean} enabled\\n * @return {Context} self\\n */\\nContext.prototype.enableTimeouts = function(enabled) {\\n  this.runnable().enableTimeouts(enabled);\\n  return this;\\n};\\n\\n/**\\n * Set test slowness threshold `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {Context} self\\n */\\nContext.prototype.slow = function(ms) {\\n  this.runnable().slow(ms);\\n  return this;\\n};\\n\\n/**\\n * Mark a test as skipped.\\n *\\n * @api private\\n * @return {Context} self\\n */\\nContext.prototype.skip = function() {\\n  this.runnable().skip();\\n  return this;\\n};\\n\\n/**\\n * Allow a number of retries on failed tests\\n *\\n * @api private\\n * @param {number} n\\n * @return {Context} self\\n */\\nContext.prototype.retries = function(n) {\\n  if (!arguments.length) {\\n    return this.runnable().retries();\\n  }\\n  this.runnable().retries(n);\\n  return this;\\n};\\n\\n/**\\n * Inspect the context void of `._runnable`.\\n *\\n * @api private\\n * @return {string}\\n */\\nContext.prototype.inspect = function() {\\n  return JSON.stringify(this, function(key, val) {\\n    return key === 'runnable' || key === 'test' ? undefined : val;\\n  }, 2);\\n};\\n\\n},{}],7:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Runnable = require('./runnable');\\nvar inherits = require('./utils').inherits;\\n\\n/**\\n * Expose `Hook`.\\n */\\n\\nmodule.exports = Hook;\\n\\n/**\\n * Initialize a new `Hook` with the given `title` and callback `fn`.\\n *\\n * @param {String} title\\n * @param {Function} fn\\n * @api private\\n */\\nfunction Hook(title, fn) {\\n  Runnable.call(this, title, fn);\\n  this.type = 'hook';\\n}\\n\\n/**\\n * Inherit from `Runnable.prototype`.\\n */\\ninherits(Hook, Runnable);\\n\\n/**\\n * Get or set the test `err`.\\n *\\n * @param {Error} err\\n * @return {Error}\\n * @api public\\n */\\nHook.prototype.error = function(err) {\\n  if (!arguments.length) {\\n    err = this._error;\\n    this._error = null;\\n    return err;\\n  }\\n\\n  this._error = err;\\n};\\n\\n},{\\\"./runnable\\\":35,\\\"./utils\\\":39}],8:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\nvar escapeRe = require('escape-string-regexp');\\n\\n/**\\n * BDD-style interface:\\n *\\n *      describe('Array', function() {\\n *        describe('#indexOf()', function() {\\n *          it('should return -1 when not present', function() {\\n *            // ...\\n *          });\\n *\\n *          it('should return the index when present', function() {\\n *            // ...\\n *          });\\n *        });\\n *      });\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('pre-require', function(context, file, mocha) {\\n    var common = require('./common')(suites, context);\\n\\n    context.before = common.before;\\n    context.after = common.after;\\n    context.beforeEach = common.beforeEach;\\n    context.afterEach = common.afterEach;\\n    context.run = mocha.options.delay && common.runWithSuite(suite);\\n    /**\\n     * Describe a \\\"suite\\\" with the given `title`\\n     * and callback `fn` containing nested suites\\n     * and/or tests.\\n     */\\n\\n    context.describe = context.context = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.file = file;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n      return suite;\\n    };\\n\\n    /**\\n     * Pending describe.\\n     */\\n\\n    context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.pending = true;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n    };\\n\\n    /**\\n     * Exclusive suite.\\n     */\\n\\n    context.describe.only = function(title, fn) {\\n      var suite = context.describe(title, fn);\\n      mocha.grep(suite.fullTitle());\\n      return suite;\\n    };\\n\\n    /**\\n     * Describe a specification or test-case\\n     * with the given `title` and callback `fn`\\n     * acting as a thunk.\\n     */\\n\\n    var it = context.it = context.specify = function(title, fn) {\\n      var suite = suites[0];\\n      if (suite.isPending()) {\\n        fn = null;\\n      }\\n      var test = new Test(title, fn);\\n      test.file = file;\\n      suite.addTest(test);\\n      return test;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.it.only = function(title, fn) {\\n      var test = it(title, fn);\\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\\n      mocha.grep(new RegExp(reString));\\n      return test;\\n    };\\n\\n    /**\\n     * Pending test case.\\n     */\\n\\n    context.xit = context.xspecify = context.it.skip = function(title) {\\n      context.it(title);\\n    };\\n\\n    /**\\n     * Number of attempts to retry.\\n     */\\n    context.it.retries = function(n) {\\n      context.retries(n);\\n    };\\n  });\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38,\\\"./common\\\":9,\\\"escape-string-regexp\\\":49}],9:[function(require,module,exports){\\n'use strict';\\n\\n/**\\n * Functions common to more than one interface.\\n *\\n * @param {Suite[]} suites\\n * @param {Context} context\\n * @return {Object} An object containing common functions.\\n */\\nmodule.exports = function(suites, context) {\\n  return {\\n    /**\\n     * This is only present if flag --delay is passed into Mocha. It triggers\\n     * root suite execution.\\n     *\\n     * @param {Suite} suite The root wuite.\\n     * @return {Function} A function which runs the root suite\\n     */\\n    runWithSuite: function runWithSuite(suite) {\\n      return function run() {\\n        suite.run();\\n      };\\n    },\\n\\n    /**\\n     * Execute before running tests.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    before: function(name, fn) {\\n      suites[0].beforeAll(name, fn);\\n    },\\n\\n    /**\\n     * Execute after running tests.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    after: function(name, fn) {\\n      suites[0].afterAll(name, fn);\\n    },\\n\\n    /**\\n     * Execute before each test case.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    beforeEach: function(name, fn) {\\n      suites[0].beforeEach(name, fn);\\n    },\\n\\n    /**\\n     * Execute after each test case.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    afterEach: function(name, fn) {\\n      suites[0].afterEach(name, fn);\\n    },\\n\\n    test: {\\n      /**\\n       * Pending test case.\\n       *\\n       * @param {string} title\\n       */\\n      skip: function(title) {\\n        context.test(title);\\n      },\\n\\n      /**\\n       * Number of retry attempts\\n       *\\n       * @param {number} n\\n       */\\n      retries: function(n) {\\n        context.retries(n);\\n      }\\n    }\\n  };\\n};\\n\\n},{}],10:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\n\\n/**\\n * Exports-style (as Node.js module) interface:\\n *\\n *     exports.Array = {\\n *       '#indexOf()': {\\n *         'should return -1 when the value is not present': function() {\\n *\\n *         },\\n *\\n *         'should return the correct index when the value is present': function() {\\n *\\n *         }\\n *       }\\n *     };\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('require', visit);\\n\\n  function visit(obj, file) {\\n    var suite;\\n    for (var key in obj) {\\n      if (typeof obj[key] === 'function') {\\n        var fn = obj[key];\\n        switch (key) {\\n          case 'before':\\n            suites[0].beforeAll(fn);\\n            break;\\n          case 'after':\\n            suites[0].afterAll(fn);\\n            break;\\n          case 'beforeEach':\\n            suites[0].beforeEach(fn);\\n            break;\\n          case 'afterEach':\\n            suites[0].afterEach(fn);\\n            break;\\n          default:\\n            var test = new Test(key, fn);\\n            test.file = file;\\n            suites[0].addTest(test);\\n        }\\n      } else {\\n        suite = Suite.create(suites[0], key);\\n        suites.unshift(suite);\\n        visit(obj[key], file);\\n        suites.shift();\\n      }\\n    }\\n  }\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38}],11:[function(require,module,exports){\\nexports.bdd = require('./bdd');\\nexports.tdd = require('./tdd');\\nexports.qunit = require('./qunit');\\nexports.exports = require('./exports');\\n\\n},{\\\"./bdd\\\":8,\\\"./exports\\\":10,\\\"./qunit\\\":12,\\\"./tdd\\\":13}],12:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\nvar escapeRe = require('escape-string-regexp');\\n\\n/**\\n * QUnit-style interface:\\n *\\n *     suite('Array');\\n *\\n *     test('#length', function() {\\n *       var arr = [1,2,3];\\n *       ok(arr.length == 3);\\n *     });\\n *\\n *     test('#indexOf()', function() {\\n *       var arr = [1,2,3];\\n *       ok(arr.indexOf(1) == 0);\\n *       ok(arr.indexOf(2) == 1);\\n *       ok(arr.indexOf(3) == 2);\\n *     });\\n *\\n *     suite('String');\\n *\\n *     test('#length', function() {\\n *       ok('foo'.length == 3);\\n *     });\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('pre-require', function(context, file, mocha) {\\n    var common = require('./common')(suites, context);\\n\\n    context.before = common.before;\\n    context.after = common.after;\\n    context.beforeEach = common.beforeEach;\\n    context.afterEach = common.afterEach;\\n    context.run = mocha.options.delay && common.runWithSuite(suite);\\n    /**\\n     * Describe a \\\"suite\\\" with the given `title`.\\n     */\\n\\n    context.suite = function(title) {\\n      if (suites.length > 1) {\\n        suites.shift();\\n      }\\n      var suite = Suite.create(suites[0], title);\\n      suite.file = file;\\n      suites.unshift(suite);\\n      return suite;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.suite.only = function(title, fn) {\\n      var suite = context.suite(title, fn);\\n      mocha.grep(suite.fullTitle());\\n    };\\n\\n    /**\\n     * Describe a specification or test-case\\n     * with the given `title` and callback `fn`\\n     * acting as a thunk.\\n     */\\n\\n    context.test = function(title, fn) {\\n      var test = new Test(title, fn);\\n      test.file = file;\\n      suites[0].addTest(test);\\n      return test;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.test.only = function(title, fn) {\\n      var test = context.test(title, fn);\\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\\n      mocha.grep(new RegExp(reString));\\n    };\\n\\n    context.test.skip = common.test.skip;\\n    context.test.retries = common.test.retries;\\n  });\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38,\\\"./common\\\":9,\\\"escape-string-regexp\\\":49}],13:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\nvar escapeRe = require('escape-string-regexp');\\n\\n/**\\n * TDD-style interface:\\n *\\n *      suite('Array', function() {\\n *        suite('#indexOf()', function() {\\n *          suiteSetup(function() {\\n *\\n *          });\\n *\\n *          test('should return -1 when not present', function() {\\n *\\n *          });\\n *\\n *          test('should return the index when present', function() {\\n *\\n *          });\\n *\\n *          suiteTeardown(function() {\\n *\\n *          });\\n *        });\\n *      });\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('pre-require', function(context, file, mocha) {\\n    var common = require('./common')(suites, context);\\n\\n    context.setup = common.beforeEach;\\n    context.teardown = common.afterEach;\\n    context.suiteSetup = common.before;\\n    context.suiteTeardown = common.after;\\n    context.run = mocha.options.delay && common.runWithSuite(suite);\\n\\n    /**\\n     * Describe a \\\"suite\\\" with the given `title` and callback `fn` containing\\n     * nested suites and/or tests.\\n     */\\n    context.suite = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.file = file;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n      return suite;\\n    };\\n\\n    /**\\n     * Pending suite.\\n     */\\n    context.suite.skip = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.pending = true;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n    context.suite.only = function(title, fn) {\\n      var suite = context.suite(title, fn);\\n      mocha.grep(suite.fullTitle());\\n    };\\n\\n    /**\\n     * Describe a specification or test-case with the given `title` and\\n     * callback `fn` acting as a thunk.\\n     */\\n    context.test = function(title, fn) {\\n      var suite = suites[0];\\n      if (suite.isPending()) {\\n        fn = null;\\n      }\\n      var test = new Test(title, fn);\\n      test.file = file;\\n      suite.addTest(test);\\n      return test;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.test.only = function(title, fn) {\\n      var test = context.test(title, fn);\\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\\n      mocha.grep(new RegExp(reString));\\n    };\\n\\n    context.test.skip = common.test.skip;\\n    context.test.retries = common.test.retries;\\n  });\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38,\\\"./common\\\":9,\\\"escape-string-regexp\\\":49}],14:[function(require,module,exports){\\n(function (process,global,__dirname){\\n/*!\\n * mocha\\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\\n * MIT Licensed\\n */\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar escapeRe = require('escape-string-regexp');\\nvar path = require('path');\\nvar reporters = require('./reporters');\\nvar utils = require('./utils');\\n\\n/**\\n * Expose `Mocha`.\\n */\\n\\nexports = module.exports = Mocha;\\n\\n/**\\n * To require local UIs and reporters when running in node.\\n */\\n\\nif (!process.browser) {\\n  var cwd = process.cwd();\\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\\n}\\n\\n/**\\n * Expose internals.\\n */\\n\\nexports.utils = utils;\\nexports.interfaces = require('./interfaces');\\nexports.reporters = reporters;\\nexports.Runnable = require('./runnable');\\nexports.Context = require('./context');\\nexports.Runner = require('./runner');\\nexports.Suite = require('./suite');\\nexports.Hook = require('./hook');\\nexports.Test = require('./test');\\n\\n/**\\n * Return image `name` path.\\n *\\n * @api private\\n * @param {string} name\\n * @return {string}\\n */\\nfunction image(name) {\\n  return path.join(__dirname, '../images', name + '.png');\\n}\\n\\n/**\\n * Set up mocha with `options`.\\n *\\n * Options:\\n *\\n *   - `ui` name \\\"bdd\\\", \\\"tdd\\\", \\\"exports\\\" etc\\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\\n *   - `globals` array of accepted globals\\n *   - `timeout` timeout in milliseconds\\n *   - `retries` number of times to retry failed tests\\n *   - `bail` bail on the first test failure\\n *   - `slow` milliseconds to wait before considering a test slow\\n *   - `ignoreLeaks` ignore global leaks\\n *   - `fullTrace` display the full stack-trace on failing\\n *   - `grep` string or regexp to filter tests with\\n *\\n * @param {Object} options\\n * @api public\\n */\\nfunction Mocha(options) {\\n  options = options || {};\\n  this.files = [];\\n  this.options = options;\\n  if (options.grep) {\\n    this.grep(new RegExp(options.grep));\\n  }\\n  if (options.fgrep) {\\n    this.grep(options.fgrep);\\n  }\\n  this.suite = new exports.Suite('', new exports.Context());\\n  this.ui(options.ui);\\n  this.bail(options.bail);\\n  this.reporter(options.reporter, options.reporterOptions);\\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\\n    this.timeout(options.timeout);\\n  }\\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\\n    this.retries(options.retries);\\n  }\\n  this.useColors(options.useColors);\\n  if (options.enableTimeouts !== null) {\\n    this.enableTimeouts(options.enableTimeouts);\\n  }\\n  if (options.slow) {\\n    this.slow(options.slow);\\n  }\\n}\\n\\n/**\\n * Enable or disable bailing on the first failure.\\n *\\n * @api public\\n * @param {boolean} [bail]\\n */\\nMocha.prototype.bail = function(bail) {\\n  if (!arguments.length) {\\n    bail = true;\\n  }\\n  this.suite.bail(bail);\\n  return this;\\n};\\n\\n/**\\n * Add test `file`.\\n *\\n * @api public\\n * @param {string} file\\n */\\nMocha.prototype.addFile = function(file) {\\n  this.files.push(file);\\n  return this;\\n};\\n\\n/**\\n * Set reporter to `reporter`, defaults to \\\"spec\\\".\\n *\\n * @param {String|Function} reporter name or constructor\\n * @param {Object} reporterOptions optional options\\n * @api public\\n * @param {string|Function} reporter name or constructor\\n * @param {Object} reporterOptions optional options\\n */\\nMocha.prototype.reporter = function(reporter, reporterOptions) {\\n  if (typeof reporter === 'function') {\\n    this._reporter = reporter;\\n  } else {\\n    reporter = reporter || 'spec';\\n    var _reporter;\\n    // Try to load a built-in reporter.\\n    if (reporters[reporter]) {\\n      _reporter = reporters[reporter];\\n    }\\n    // Try to load reporters from process.cwd() and node_modules\\n    if (!_reporter) {\\n      try {\\n        _reporter = require(reporter);\\n      } catch (err) {\\n        err.message.indexOf('Cannot find module') !== -1\\n          ? console.warn('\\\"' + reporter + '\\\" reporter not found')\\n          : console.warn('\\\"' + reporter + '\\\" reporter blew up with error:\\\\n' + err.stack);\\n      }\\n    }\\n    if (!_reporter && reporter === 'teamcity') {\\n      console.warn('The Teamcity reporter was moved to a package named '\\n        + 'mocha-teamcity-reporter '\\n        + '(https://npmjs.org/package/mocha-teamcity-reporter).');\\n    }\\n    if (!_reporter) {\\n      throw new Error('invalid reporter \\\"' + reporter + '\\\"');\\n    }\\n    this._reporter = _reporter;\\n  }\\n  this.options.reporterOptions = reporterOptions;\\n  return this;\\n};\\n\\n/**\\n * Set test UI `name`, defaults to \\\"bdd\\\".\\n *\\n * @api public\\n * @param {string} bdd\\n */\\nMocha.prototype.ui = function(name) {\\n  name = name || 'bdd';\\n  this._ui = exports.interfaces[name];\\n  if (!this._ui) {\\n    try {\\n      this._ui = require(name);\\n    } catch (err) {\\n      throw new Error('invalid interface \\\"' + name + '\\\"');\\n    }\\n  }\\n  this._ui = this._ui(this.suite);\\n\\n  this.suite.on('pre-require', function(context) {\\n    exports.afterEach = context.afterEach || context.teardown;\\n    exports.after = context.after || context.suiteTeardown;\\n    exports.beforeEach = context.beforeEach || context.setup;\\n    exports.before = context.before || context.suiteSetup;\\n    exports.describe = context.describe || context.suite;\\n    exports.it = context.it || context.test;\\n    exports.setup = context.setup || context.beforeEach;\\n    exports.suiteSetup = context.suiteSetup || context.before;\\n    exports.suiteTeardown = context.suiteTeardown || context.after;\\n    exports.suite = context.suite || context.describe;\\n    exports.teardown = context.teardown || context.afterEach;\\n    exports.test = context.test || context.it;\\n    exports.run = context.run;\\n  });\\n\\n  return this;\\n};\\n\\n/**\\n * Load registered files.\\n *\\n * @api private\\n */\\nMocha.prototype.loadFiles = function(fn) {\\n  var self = this;\\n  var suite = this.suite;\\n  this.files.forEach(function(file) {\\n    file = path.resolve(file);\\n    suite.emit('pre-require', global, file, self);\\n    suite.emit('require', require(file), file, self);\\n    suite.emit('post-require', global, file, self);\\n  });\\n  fn && fn();\\n};\\n\\n/**\\n * Enable growl support.\\n *\\n * @api private\\n */\\nMocha.prototype._growl = function(runner, reporter) {\\n  var notify = require('growl');\\n\\n  runner.on('end', function() {\\n    var stats = reporter.stats;\\n    if (stats.failures) {\\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\\n    } else {\\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\\n        name: 'mocha',\\n        title: 'Passed',\\n        image: image('ok')\\n      });\\n    }\\n  });\\n};\\n\\n/**\\n * Add regexp to grep, if `re` is a string it is escaped.\\n *\\n * @param {RegExp|String} re\\n * @return {Mocha}\\n * @api public\\n * @param {RegExp|string} re\\n * @return {Mocha}\\n */\\nMocha.prototype.grep = function(re) {\\n  this.options.grep = typeof re === 'string' ? new RegExp(escapeRe(re)) : re;\\n  return this;\\n};\\n\\n/**\\n * Invert `.grep()` matches.\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.invert = function() {\\n  this.options.invert = true;\\n  return this;\\n};\\n\\n/**\\n * Ignore global leaks.\\n *\\n * @param {Boolean} ignore\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} ignore\\n * @return {Mocha}\\n */\\nMocha.prototype.ignoreLeaks = function(ignore) {\\n  this.options.ignoreLeaks = Boolean(ignore);\\n  return this;\\n};\\n\\n/**\\n * Enable global leak checking.\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.checkLeaks = function() {\\n  this.options.ignoreLeaks = false;\\n  return this;\\n};\\n\\n/**\\n * Display long stack-trace on failing\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.fullTrace = function() {\\n  this.options.fullStackTrace = true;\\n  return this;\\n};\\n\\n/**\\n * Enable growl support.\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.growl = function() {\\n  this.options.growl = true;\\n  return this;\\n};\\n\\n/**\\n * Ignore `globals` array or string.\\n *\\n * @param {Array|String} globals\\n * @return {Mocha}\\n * @api public\\n * @param {Array|string} globals\\n * @return {Mocha}\\n */\\nMocha.prototype.globals = function(globals) {\\n  this.options.globals = (this.options.globals || []).concat(globals);\\n  return this;\\n};\\n\\n/**\\n * Emit color output.\\n *\\n * @param {Boolean} colors\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} colors\\n * @return {Mocha}\\n */\\nMocha.prototype.useColors = function(colors) {\\n  if (colors !== undefined) {\\n    this.options.useColors = colors;\\n  }\\n  return this;\\n};\\n\\n/**\\n * Use inline diffs rather than +/-.\\n *\\n * @param {Boolean} inlineDiffs\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} inlineDiffs\\n * @return {Mocha}\\n */\\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\\n  return this;\\n};\\n\\n/**\\n * Set the timeout in milliseconds.\\n *\\n * @param {Number} timeout\\n * @return {Mocha}\\n * @api public\\n * @param {number} timeout\\n * @return {Mocha}\\n */\\nMocha.prototype.timeout = function(timeout) {\\n  this.suite.timeout(timeout);\\n  return this;\\n};\\n\\n/**\\n * Set the number of times to retry failed tests.\\n *\\n * @param {Number} retry times\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.retries = function(n) {\\n  this.suite.retries(n);\\n  return this;\\n};\\n\\n/**\\n * Set slowness threshold in milliseconds.\\n *\\n * @param {Number} slow\\n * @return {Mocha}\\n * @api public\\n * @param {number} slow\\n * @return {Mocha}\\n */\\nMocha.prototype.slow = function(slow) {\\n  this.suite.slow(slow);\\n  return this;\\n};\\n\\n/**\\n * Enable timeouts.\\n *\\n * @param {Boolean} enabled\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} enabled\\n * @return {Mocha}\\n */\\nMocha.prototype.enableTimeouts = function(enabled) {\\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\\n  return this;\\n};\\n\\n/**\\n * Makes all tests async (accepting a callback)\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.asyncOnly = function() {\\n  this.options.asyncOnly = true;\\n  return this;\\n};\\n\\n/**\\n * Disable syntax highlighting (in browser).\\n *\\n * @api public\\n */\\nMocha.prototype.noHighlighting = function() {\\n  this.options.noHighlighting = true;\\n  return this;\\n};\\n\\n/**\\n * Enable uncaught errors to propagate (in browser).\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.allowUncaught = function() {\\n  this.options.allowUncaught = true;\\n  return this;\\n};\\n\\n/**\\n * Delay root suite execution.\\n * @returns {Mocha}\\n */\\nMocha.prototype.delay = function delay() {\\n  this.options.delay = true;\\n  return this;\\n};\\n\\n/**\\n * Run tests and invoke `fn()` when complete.\\n *\\n * @api public\\n * @param {Function} fn\\n * @return {Runner}\\n */\\nMocha.prototype.run = function(fn) {\\n  if (this.files.length) {\\n    this.loadFiles();\\n  }\\n  var suite = this.suite;\\n  var options = this.options;\\n  options.files = this.files;\\n  var runner = new exports.Runner(suite, options.delay);\\n  var reporter = new this._reporter(runner, options);\\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\\n  runner.fullStackTrace = options.fullStackTrace;\\n  runner.asyncOnly = options.asyncOnly;\\n  runner.allowUncaught = options.allowUncaught;\\n  if (options.grep) {\\n    runner.grep(options.grep, options.invert);\\n  }\\n  if (options.globals) {\\n    runner.globals(options.globals);\\n  }\\n  if (options.growl) {\\n    this._growl(runner, reporter);\\n  }\\n  if (options.useColors !== undefined) {\\n    exports.reporters.Base.useColors = options.useColors;\\n  }\\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\\n\\n  function done(failures) {\\n    if (reporter.done) {\\n      reporter.done(failures, fn);\\n    } else {\\n      fn && fn(failures);\\n    }\\n  }\\n\\n  return runner.run(done);\\n};\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {},\\\"/lib\\\")\\n},{\\\"./context\\\":6,\\\"./hook\\\":7,\\\"./interfaces\\\":11,\\\"./reporters\\\":22,\\\"./runnable\\\":35,\\\"./runner\\\":36,\\\"./suite\\\":37,\\\"./test\\\":38,\\\"./utils\\\":39,\\\"_process\\\":58,\\\"escape-string-regexp\\\":49,\\\"growl\\\":51,\\\"path\\\":43}],15:[function(require,module,exports){\\n/**\\n * Helpers.\\n */\\n\\nvar s = 1000;\\nvar m = s * 60;\\nvar h = m * 60;\\nvar d = h * 24;\\nvar y = d * 365.25;\\n\\n/**\\n * Parse or format the given `val`.\\n *\\n * Options:\\n *\\n *  - `long` verbose formatting [false]\\n *\\n * @api public\\n * @param {string|number} val\\n * @param {Object} options\\n * @return {string|number}\\n */\\nmodule.exports = function(val, options) {\\n  options = options || {};\\n  if (typeof val === 'string') {\\n    return parse(val);\\n  }\\n  // https://github.com/mochajs/mocha/pull/1035\\n  return options['long'] ? longFormat(val) : shortFormat(val);\\n};\\n\\n/**\\n * Parse the given `str` and return milliseconds.\\n *\\n * @api private\\n * @param {string} str\\n * @return {number}\\n */\\nfunction parse(str) {\\n  var match = (/^((?:\\\\d+)?\\\\.?\\\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\\n  if (!match) {\\n    return;\\n  }\\n  var n = parseFloat(match[1]);\\n  var type = (match[2] || 'ms').toLowerCase();\\n  switch (type) {\\n    case 'years':\\n    case 'year':\\n    case 'y':\\n      return n * y;\\n    case 'days':\\n    case 'day':\\n    case 'd':\\n      return n * d;\\n    case 'hours':\\n    case 'hour':\\n    case 'h':\\n      return n * h;\\n    case 'minutes':\\n    case 'minute':\\n    case 'm':\\n      return n * m;\\n    case 'seconds':\\n    case 'second':\\n    case 's':\\n      return n * s;\\n    case 'ms':\\n      return n;\\n    default:\\n      // No default case\\n  }\\n}\\n\\n/**\\n * Short format for `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {string}\\n */\\nfunction shortFormat(ms) {\\n  if (ms >= d) {\\n    return Math.round(ms / d) + 'd';\\n  }\\n  if (ms >= h) {\\n    return Math.round(ms / h) + 'h';\\n  }\\n  if (ms >= m) {\\n    return Math.round(ms / m) + 'm';\\n  }\\n  if (ms >= s) {\\n    return Math.round(ms / s) + 's';\\n  }\\n  return ms + 'ms';\\n}\\n\\n/**\\n * Long format for `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {string}\\n */\\nfunction longFormat(ms) {\\n  return plural(ms, d, 'day')\\n    || plural(ms, h, 'hour')\\n    || plural(ms, m, 'minute')\\n    || plural(ms, s, 'second')\\n    || ms + ' ms';\\n}\\n\\n/**\\n * Pluralization helper.\\n *\\n * @api private\\n * @param {number} ms\\n * @param {number} n\\n * @param {string} name\\n */\\nfunction plural(ms, n, name) {\\n  if (ms < n) {\\n    return;\\n  }\\n  if (ms < n * 1.5) {\\n    return Math.floor(ms / n) + ' ' + name;\\n  }\\n  return Math.ceil(ms / n) + ' ' + name + 's';\\n}\\n\\n},{}],16:[function(require,module,exports){\\n\\n/**\\n * Expose `Pending`.\\n */\\n\\nmodule.exports = Pending;\\n\\n/**\\n * Initialize a new `Pending` error with the given message.\\n *\\n * @param {string} message\\n */\\nfunction Pending(message) {\\n  this.message = message;\\n}\\n\\n},{}],17:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar tty = require('tty');\\nvar diff = require('diff');\\nvar ms = require('../ms');\\nvar utils = require('../utils');\\nvar supportsColor = process.browser ? null : require('supports-color');\\n\\n/**\\n * Expose `Base`.\\n */\\n\\nexports = module.exports = Base;\\n\\n/**\\n * Save timer references to avoid Sinon interfering.\\n * See: https://github.com/mochajs/mocha/issues/237\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Check if both stdio streams are associated with a tty.\\n */\\n\\nvar isatty = tty.isatty(1) && tty.isatty(2);\\n\\n/**\\n * Enable coloring by default, except in the browser interface.\\n */\\n\\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\\n\\n/**\\n * Inline diffs instead of +/-\\n */\\n\\nexports.inlineDiffs = false;\\n\\n/**\\n * Default color map.\\n */\\n\\nexports.colors = {\\n  pass: 90,\\n  fail: 31,\\n  'bright pass': 92,\\n  'bright fail': 91,\\n  'bright yellow': 93,\\n  pending: 36,\\n  suite: 0,\\n  'error title': 0,\\n  'error message': 31,\\n  'error stack': 90,\\n  checkmark: 32,\\n  fast: 90,\\n  medium: 33,\\n  slow: 31,\\n  green: 32,\\n  light: 90,\\n  'diff gutter': 90,\\n  'diff added': 32,\\n  'diff removed': 31\\n};\\n\\n/**\\n * Default symbol map.\\n */\\n\\nexports.symbols = {\\n  ok: '✓',\\n  err: '✖',\\n  dot: '․'\\n};\\n\\n// With node.js on Windows: use symbols available in terminal default fonts\\nif (process.platform === 'win32') {\\n  exports.symbols.ok = '\\\\u221A';\\n  exports.symbols.err = '\\\\u00D7';\\n  exports.symbols.dot = '.';\\n}\\n\\n/**\\n * Color `str` with the given `type`,\\n * allowing colors to be disabled,\\n * as well as user-defined color\\n * schemes.\\n *\\n * @param {string} type\\n * @param {string} str\\n * @return {string}\\n * @api private\\n */\\nvar color = exports.color = function(type, str) {\\n  if (!exports.useColors) {\\n    return String(str);\\n  }\\n  return '\\\\u001b[' + exports.colors[type] + 'm' + str + '\\\\u001b[0m';\\n};\\n\\n/**\\n * Expose term window size, with some defaults for when stderr is not a tty.\\n */\\n\\nexports.window = {\\n  width: 75\\n};\\n\\nif (isatty) {\\n  exports.window.width = process.stdout.getWindowSize\\n      ? process.stdout.getWindowSize(1)[0]\\n      : tty.getWindowSize()[1];\\n}\\n\\n/**\\n * Expose some basic cursor interactions that are common among reporters.\\n */\\n\\nexports.cursor = {\\n  hide: function() {\\n    isatty && process.stdout.write('\\\\u001b[?25l');\\n  },\\n\\n  show: function() {\\n    isatty && process.stdout.write('\\\\u001b[?25h');\\n  },\\n\\n  deleteLine: function() {\\n    isatty && process.stdout.write('\\\\u001b[2K');\\n  },\\n\\n  beginningOfLine: function() {\\n    isatty && process.stdout.write('\\\\u001b[0G');\\n  },\\n\\n  CR: function() {\\n    if (isatty) {\\n      exports.cursor.deleteLine();\\n      exports.cursor.beginningOfLine();\\n    } else {\\n      process.stdout.write('\\\\r');\\n    }\\n  }\\n};\\n\\n/**\\n * Outut the given `failures` as a list.\\n *\\n * @param {Array} failures\\n * @api public\\n */\\n\\nexports.list = function(failures) {\\n  console.log();\\n  failures.forEach(function(test, i) {\\n    // format\\n    var fmt = color('error title', '  %s) %s:\\\\n')\\n      + color('error message', '     %s')\\n      + color('error stack', '\\\\n%s\\\\n');\\n\\n    // msg\\n    var msg;\\n    var err = test.err;\\n    var message;\\n    if (err.message && typeof err.message.toString === 'function') {\\n      message = err.message + '';\\n    } else if (typeof err.inspect === 'function') {\\n      message = err.inspect() + '';\\n    } else {\\n      message = '';\\n    }\\n    var stack = err.stack || message;\\n    var index = stack.indexOf(message);\\n    var actual = err.actual;\\n    var expected = err.expected;\\n    var escape = true;\\n\\n    if (index === -1) {\\n      msg = message;\\n    } else {\\n      index += message.length;\\n      msg = stack.slice(0, index);\\n      // remove msg from stack\\n      stack = stack.slice(index + 1);\\n    }\\n\\n    // uncaught\\n    if (err.uncaught) {\\n      msg = 'Uncaught ' + msg;\\n    }\\n    // explicitly show diff\\n    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {\\n      escape = false;\\n      if (!(utils.isString(actual) && utils.isString(expected))) {\\n        err.actual = actual = utils.stringify(actual);\\n        err.expected = expected = utils.stringify(expected);\\n      }\\n\\n      fmt = color('error title', '  %s) %s:\\\\n%s') + color('error stack', '\\\\n%s\\\\n');\\n      var match = message.match(/^([^:]+): expected/);\\n      msg = '\\\\n      ' + color('error message', match ? match[1] : msg);\\n\\n      if (exports.inlineDiffs) {\\n        msg += inlineDiff(err, escape);\\n      } else {\\n        msg += unifiedDiff(err, escape);\\n      }\\n    }\\n\\n    // indent stack trace\\n    stack = stack.replace(/^/gm, '  ');\\n\\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\\n  });\\n};\\n\\n/**\\n * Initialize a new `Base` reporter.\\n *\\n * All other reporters generally\\n * inherit from this reporter, providing\\n * stats such as test duration, number\\n * of tests passed / failed etc.\\n *\\n * @param {Runner} runner\\n * @api public\\n */\\n\\nfunction Base(runner) {\\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\\n  var failures = this.failures = [];\\n\\n  if (!runner) {\\n    return;\\n  }\\n  this.runner = runner;\\n\\n  runner.stats = stats;\\n\\n  runner.on('start', function() {\\n    stats.start = new Date();\\n  });\\n\\n  runner.on('suite', function(suite) {\\n    stats.suites = stats.suites || 0;\\n    suite.root || stats.suites++;\\n  });\\n\\n  runner.on('test end', function() {\\n    stats.tests = stats.tests || 0;\\n    stats.tests++;\\n  });\\n\\n  runner.on('pass', function(test) {\\n    stats.passes = stats.passes || 0;\\n\\n    if (test.duration > test.slow()) {\\n      test.speed = 'slow';\\n    } else if (test.duration > test.slow() / 2) {\\n      test.speed = 'medium';\\n    } else {\\n      test.speed = 'fast';\\n    }\\n\\n    stats.passes++;\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    stats.failures = stats.failures || 0;\\n    stats.failures++;\\n    test.err = err;\\n    failures.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    stats.end = new Date();\\n    stats.duration = new Date() - stats.start;\\n  });\\n\\n  runner.on('pending', function() {\\n    stats.pending++;\\n  });\\n}\\n\\n/**\\n * Output common epilogue used by many of\\n * the bundled reporters.\\n *\\n * @api public\\n */\\nBase.prototype.epilogue = function() {\\n  var stats = this.stats;\\n  var fmt;\\n\\n  console.log();\\n\\n  // passes\\n  fmt = color('bright pass', ' ')\\n    + color('green', ' %d passing')\\n    + color('light', ' (%s)');\\n\\n  console.log(fmt,\\n    stats.passes || 0,\\n    ms(stats.duration));\\n\\n  // pending\\n  if (stats.pending) {\\n    fmt = color('pending', ' ')\\n      + color('pending', ' %d pending');\\n\\n    console.log(fmt, stats.pending);\\n  }\\n\\n  // failures\\n  if (stats.failures) {\\n    fmt = color('fail', '  %d failing');\\n\\n    console.log(fmt, stats.failures);\\n\\n    Base.list(this.failures);\\n    console.log();\\n  }\\n\\n  console.log();\\n};\\n\\n/**\\n * Pad the given `str` to `len`.\\n *\\n * @api private\\n * @param {string} str\\n * @param {string} len\\n * @return {string}\\n */\\nfunction pad(str, len) {\\n  str = String(str);\\n  return Array(len - str.length + 1).join(' ') + str;\\n}\\n\\n/**\\n * Returns an inline diff between 2 strings with coloured ANSI output\\n *\\n * @api private\\n * @param {Error} err with actual/expected\\n * @param {boolean} escape\\n * @return {string} Diff\\n */\\nfunction inlineDiff(err, escape) {\\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\\n\\n  // linenos\\n  var lines = msg.split('\\\\n');\\n  if (lines.length > 4) {\\n    var width = String(lines.length).length;\\n    msg = lines.map(function(str, i) {\\n      return pad(++i, width) + ' |' + ' ' + str;\\n    }).join('\\\\n');\\n  }\\n\\n  // legend\\n  msg = '\\\\n'\\n    + color('diff removed', 'actual')\\n    + ' '\\n    + color('diff added', 'expected')\\n    + '\\\\n\\\\n'\\n    + msg\\n    + '\\\\n';\\n\\n  // indent\\n  msg = msg.replace(/^/gm, '      ');\\n  return msg;\\n}\\n\\n/**\\n * Returns a unified diff between two strings.\\n *\\n * @api private\\n * @param {Error} err with actual/expected\\n * @param {boolean} escape\\n * @return {string} The diff.\\n */\\nfunction unifiedDiff(err, escape) {\\n  var indent = '      ';\\n  function cleanUp(line) {\\n    if (escape) {\\n      line = escapeInvisibles(line);\\n    }\\n    if (line[0] === '+') {\\n      return indent + colorLines('diff added', line);\\n    }\\n    if (line[0] === '-') {\\n      return indent + colorLines('diff removed', line);\\n    }\\n    if (line.match(/\\\\@\\\\@/)) {\\n      return null;\\n    }\\n    if (line.match(/\\\\\\\\ No newline/)) {\\n      return null;\\n    }\\n    return indent + line;\\n  }\\n  function notBlank(line) {\\n    return typeof line !== 'undefined' && line !== null;\\n  }\\n  var msg = diff.createPatch('string', err.actual, err.expected);\\n  var lines = msg.split('\\\\n').splice(4);\\n  return '\\\\n      '\\n    + colorLines('diff added', '+ expected') + ' '\\n    + colorLines('diff removed', '- actual')\\n    + '\\\\n\\\\n'\\n    + lines.map(cleanUp).filter(notBlank).join('\\\\n');\\n}\\n\\n/**\\n * Return a character diff for `err`.\\n *\\n * @api private\\n * @param {Error} err\\n * @param {string} type\\n * @param {boolean} escape\\n * @return {string}\\n */\\nfunction errorDiff(err, type, escape) {\\n  var actual = escape ? escapeInvisibles(err.actual) : err.actual;\\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\\n  return diff['diff' + type](actual, expected).map(function(str) {\\n    if (str.added) {\\n      return colorLines('diff added', str.value);\\n    }\\n    if (str.removed) {\\n      return colorLines('diff removed', str.value);\\n    }\\n    return str.value;\\n  }).join('');\\n}\\n\\n/**\\n * Returns a string with all invisible characters in plain text\\n *\\n * @api private\\n * @param {string} line\\n * @return {string}\\n */\\nfunction escapeInvisibles(line) {\\n  return line.replace(/\\\\t/g, '<tab>')\\n    .replace(/\\\\r/g, '<CR>')\\n    .replace(/\\\\n/g, '<LF>\\\\n');\\n}\\n\\n/**\\n * Color lines for `str`, using the color `name`.\\n *\\n * @api private\\n * @param {string} name\\n * @param {string} str\\n * @return {string}\\n */\\nfunction colorLines(name, str) {\\n  return str.split('\\\\n').map(function(str) {\\n    return color(name, str);\\n  }).join('\\\\n');\\n}\\n\\n/**\\n * Object#toString reference.\\n */\\nvar objToString = Object.prototype.toString;\\n\\n/**\\n * Check that a / b have the same type.\\n *\\n * @api private\\n * @param {Object} a\\n * @param {Object} b\\n * @return {boolean}\\n */\\nfunction sameType(a, b) {\\n  return objToString.call(a) === objToString.call(b);\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../ms\\\":15,\\\"../utils\\\":39,\\\"_process\\\":58,\\\"diff\\\":48,\\\"supports-color\\\":43,\\\"tty\\\":5}],18:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\n\\n/**\\n * Expose `Doc`.\\n */\\n\\nexports = module.exports = Doc;\\n\\n/**\\n * Initialize a new `Doc` reporter.\\n *\\n * @param {Runner} runner\\n * @api public\\n */\\nfunction Doc(runner) {\\n  Base.call(this, runner);\\n\\n  var indents = 2;\\n\\n  function indent() {\\n    return Array(indents).join('  ');\\n  }\\n\\n  runner.on('suite', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n    ++indents;\\n    console.log('%s<section class=\\\"suite\\\">', indent());\\n    ++indents;\\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\\n    console.log('%s<dl>', indent());\\n  });\\n\\n  runner.on('suite end', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n    console.log('%s</dl>', indent());\\n    --indents;\\n    console.log('%s</section>', indent());\\n    --indents;\\n  });\\n\\n  runner.on('pass', function(test) {\\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\\n    var code = utils.escape(utils.clean(test.body));\\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    console.log('%s  <dt class=\\\"error\\\">%s</dt>', indent(), utils.escape(test.title));\\n    var code = utils.escape(utils.clean(test.fn.body));\\n    console.log('%s  <dd class=\\\"error\\\"><pre><code>%s</code></pre></dd>', indent(), code);\\n    console.log('%s  <dd class=\\\"error\\\">%s</dd>', indent(), utils.escape(err));\\n  });\\n}\\n\\n},{\\\"../utils\\\":39,\\\"./base\\\":17}],19:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\n\\n/**\\n * Expose `Dot`.\\n */\\n\\nexports = module.exports = Dot;\\n\\n/**\\n * Initialize a new `Dot` matrix test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Dot(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .75 | 0;\\n  var n = -1;\\n\\n  runner.on('start', function() {\\n    process.stdout.write('\\\\n');\\n  });\\n\\n  runner.on('pending', function() {\\n    if (++n % width === 0) {\\n      process.stdout.write('\\\\n  ');\\n    }\\n    process.stdout.write(color('pending', Base.symbols.dot));\\n  });\\n\\n  runner.on('pass', function(test) {\\n    if (++n % width === 0) {\\n      process.stdout.write('\\\\n  ');\\n    }\\n    if (test.speed === 'slow') {\\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\\n    } else {\\n      process.stdout.write(color(test.speed, Base.symbols.dot));\\n    }\\n  });\\n\\n  runner.on('fail', function() {\\n    if (++n % width === 0) {\\n      process.stdout.write('\\\\n  ');\\n    }\\n    process.stdout.write(color('fail', Base.symbols.dot));\\n  });\\n\\n  runner.on('end', function() {\\n    console.log();\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Dot, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],20:[function(require,module,exports){\\n(function (process,__dirname){\\n/**\\n * Module dependencies.\\n */\\n\\nvar JSONCov = require('./json-cov');\\nvar readFileSync = require('fs').readFileSync;\\nvar join = require('path').join;\\n\\n/**\\n * Expose `HTMLCov`.\\n */\\n\\nexports = module.exports = HTMLCov;\\n\\n/**\\n * Initialize a new `JsCoverage` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction HTMLCov(runner) {\\n  var jade = require('jade');\\n  var file = join(__dirname, '/templates/coverage.jade');\\n  var str = readFileSync(file, 'utf8');\\n  var fn = jade.compile(str, { filename: file });\\n  var self = this;\\n\\n  JSONCov.call(this, runner, false);\\n\\n  runner.on('end', function() {\\n    process.stdout.write(fn({\\n      cov: self.cov,\\n      coverageClass: coverageClass\\n    }));\\n  });\\n}\\n\\n/**\\n * Return coverage class for a given coverage percentage.\\n *\\n * @api private\\n * @param {number} coveragePctg\\n * @return {string}\\n */\\nfunction coverageClass(coveragePctg) {\\n  if (coveragePctg >= 75) {\\n    return 'high';\\n  }\\n  if (coveragePctg >= 50) {\\n    return 'medium';\\n  }\\n  if (coveragePctg >= 25) {\\n    return 'low';\\n  }\\n  return 'terrible';\\n}\\n\\n}).call(this,require('_process'),\\\"/lib/reporters\\\")\\n},{\\\"./json-cov\\\":23,\\\"_process\\\":58,\\\"fs\\\":43,\\\"jade\\\":43,\\\"path\\\":43}],21:[function(require,module,exports){\\n(function (global){\\n/* eslint-env browser */\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\nvar Progress = require('../browser/progress');\\nvar escapeRe = require('escape-string-regexp');\\nvar escape = utils.escape;\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Expose `HTML`.\\n */\\n\\nexports = module.exports = HTML;\\n\\n/**\\n * Stats template.\\n */\\n\\nvar statsTemplate = '<ul id=\\\"mocha-stats\\\">'\\n  + '<li class=\\\"progress\\\"><canvas width=\\\"40\\\" height=\\\"40\\\"></canvas></li>'\\n  + '<li class=\\\"passes\\\"><a href=\\\"javascript:void(0);\\\">passes:</a> <em>0</em></li>'\\n  + '<li class=\\\"failures\\\"><a href=\\\"javascript:void(0);\\\">failures:</a> <em>0</em></li>'\\n  + '<li class=\\\"duration\\\">duration: <em>0</em>s</li>'\\n  + '</ul>';\\n\\n/**\\n * Initialize a new `HTML` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction HTML(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var stats = this.stats;\\n  var stat = fragment(statsTemplate);\\n  var items = stat.getElementsByTagName('li');\\n  var passes = items[1].getElementsByTagName('em')[0];\\n  var passesLink = items[1].getElementsByTagName('a')[0];\\n  var failures = items[2].getElementsByTagName('em')[0];\\n  var failuresLink = items[2].getElementsByTagName('a')[0];\\n  var duration = items[3].getElementsByTagName('em')[0];\\n  var canvas = stat.getElementsByTagName('canvas')[0];\\n  var report = fragment('<ul id=\\\"mocha-report\\\"></ul>');\\n  var stack = [report];\\n  var progress;\\n  var ctx;\\n  var root = document.getElementById('mocha');\\n\\n  if (canvas.getContext) {\\n    var ratio = window.devicePixelRatio || 1;\\n    canvas.style.width = canvas.width;\\n    canvas.style.height = canvas.height;\\n    canvas.width *= ratio;\\n    canvas.height *= ratio;\\n    ctx = canvas.getContext('2d');\\n    ctx.scale(ratio, ratio);\\n    progress = new Progress();\\n  }\\n\\n  if (!root) {\\n    return error('#mocha div missing, add it to your document');\\n  }\\n\\n  // pass toggle\\n  on(passesLink, 'click', function(evt) {\\n    evt.preventDefault();\\n    unhide();\\n    var name = (/pass/).test(report.className) ? '' : ' pass';\\n    report.className = report.className.replace(/fail|pass/g, '') + name;\\n    if (report.className.trim()) {\\n      hideSuitesWithout('test pass');\\n    }\\n  });\\n\\n  // failure toggle\\n  on(failuresLink, 'click', function(evt) {\\n    evt.preventDefault();\\n    unhide();\\n    var name = (/fail/).test(report.className) ? '' : ' fail';\\n    report.className = report.className.replace(/fail|pass/g, '') + name;\\n    if (report.className.trim()) {\\n      hideSuitesWithout('test fail');\\n    }\\n  });\\n\\n  root.appendChild(stat);\\n  root.appendChild(report);\\n\\n  if (progress) {\\n    progress.size(40);\\n  }\\n\\n  runner.on('suite', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n\\n    // suite\\n    var url = self.suiteURL(suite);\\n    var el = fragment('<li class=\\\"suite\\\"><h1><a href=\\\"%s\\\">%s</a></h1></li>', url, escape(suite.title));\\n\\n    // container\\n    stack[0].appendChild(el);\\n    stack.unshift(document.createElement('ul'));\\n    el.appendChild(stack[0]);\\n  });\\n\\n  runner.on('suite end', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n    stack.shift();\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var url = self.testURL(test);\\n    var markup = '<li class=\\\"test pass %e\\\"><h2>%e<span class=\\\"duration\\\">%ems</span> '\\n      + '<a href=\\\"%s\\\" class=\\\"replay\\\">‣</a></h2></li>';\\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\\n    self.addCodeToggle(el, test.body);\\n    appendToStack(el);\\n    updateStats();\\n  });\\n\\n  runner.on('fail', function(test) {\\n    var el = fragment('<li class=\\\"test fail\\\"><h2>%e <a href=\\\"%e\\\" class=\\\"replay\\\">‣</a></h2></li>',\\n      test.title, self.testURL(test));\\n    var stackString; // Note: Includes leading newline\\n    var message = test.err.toString();\\n\\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\\n    // check for the result of the stringifying.\\n    if (message === '[object Error]') {\\n      message = test.err.message;\\n    }\\n\\n    if (test.err.stack) {\\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\\n      if (indexOfMessage === -1) {\\n        stackString = test.err.stack;\\n      } else {\\n        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\\n      }\\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\\n      // Safari doesn't give you a stack. Let's at least provide a source line.\\n      stackString = '\\\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\\n    }\\n\\n    stackString = stackString || '';\\n\\n    if (test.err.htmlMessage && stackString) {\\n      el.appendChild(fragment('<div class=\\\"html-error\\\">%s\\\\n<pre class=\\\"error\\\">%e</pre></div>',\\n        test.err.htmlMessage, stackString));\\n    } else if (test.err.htmlMessage) {\\n      el.appendChild(fragment('<div class=\\\"html-error\\\">%s</div>', test.err.htmlMessage));\\n    } else {\\n      el.appendChild(fragment('<pre class=\\\"error\\\">%e%e</pre>', message, stackString));\\n    }\\n\\n    self.addCodeToggle(el, test.body);\\n    appendToStack(el);\\n    updateStats();\\n  });\\n\\n  runner.on('pending', function(test) {\\n    var el = fragment('<li class=\\\"test pass pending\\\"><h2>%e</h2></li>', test.title);\\n    appendToStack(el);\\n    updateStats();\\n  });\\n\\n  function appendToStack(el) {\\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\\n    if (stack[0]) {\\n      stack[0].appendChild(el);\\n    }\\n  }\\n\\n  function updateStats() {\\n    // TODO: add to stats\\n    var percent = stats.tests / this.total * 100 | 0;\\n    if (progress) {\\n      progress.update(percent).draw(ctx);\\n    }\\n\\n    // update stats\\n    var ms = new Date() - stats.start;\\n    text(passes, stats.passes);\\n    text(failures, stats.failures);\\n    text(duration, (ms / 1000).toFixed(2));\\n  }\\n}\\n\\n/**\\n * Makes a URL, preserving querystring (\\\"search\\\") parameters.\\n *\\n * @param {string} s\\n * @return {string} A new URL.\\n */\\nfunction makeUrl(s) {\\n  var search = window.location.search;\\n\\n  // Remove previous grep query parameter if present\\n  if (search) {\\n    search = search.replace(/[?&]grep=[^&\\\\s]*/g, '').replace(/^&/, '?');\\n  }\\n\\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\\n}\\n\\n/**\\n * Provide suite URL.\\n *\\n * @param {Object} [suite]\\n */\\nHTML.prototype.suiteURL = function(suite) {\\n  return makeUrl(suite.fullTitle());\\n};\\n\\n/**\\n * Provide test URL.\\n *\\n * @param {Object} [test]\\n */\\nHTML.prototype.testURL = function(test) {\\n  return makeUrl(test.fullTitle());\\n};\\n\\n/**\\n * Adds code toggle functionality for the provided test's list element.\\n *\\n * @param {HTMLLIElement} el\\n * @param {string} contents\\n */\\nHTML.prototype.addCodeToggle = function(el, contents) {\\n  var h2 = el.getElementsByTagName('h2')[0];\\n\\n  on(h2, 'click', function() {\\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\\n  });\\n\\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\\n  el.appendChild(pre);\\n  pre.style.display = 'none';\\n};\\n\\n/**\\n * Display error `msg`.\\n *\\n * @param {string} msg\\n */\\nfunction error(msg) {\\n  document.body.appendChild(fragment('<div id=\\\"mocha-error\\\">%s</div>', msg));\\n}\\n\\n/**\\n * Return a DOM fragment from `html`.\\n *\\n * @param {string} html\\n */\\nfunction fragment(html) {\\n  var args = arguments;\\n  var div = document.createElement('div');\\n  var i = 1;\\n\\n  div.innerHTML = html.replace(/%([se])/g, function(_, type) {\\n    switch (type) {\\n      case 's': return String(args[i++]);\\n      case 'e': return escape(args[i++]);\\n      // no default\\n    }\\n  });\\n\\n  return div.firstChild;\\n}\\n\\n/**\\n * Check for suites that do not have elements\\n * with `classname`, and hide them.\\n *\\n * @param {text} classname\\n */\\nfunction hideSuitesWithout(classname) {\\n  var suites = document.getElementsByClassName('suite');\\n  for (var i = 0; i < suites.length; i++) {\\n    var els = suites[i].getElementsByClassName(classname);\\n    if (!els.length) {\\n      suites[i].className += ' hidden';\\n    }\\n  }\\n}\\n\\n/**\\n * Unhide .hidden suites.\\n */\\nfunction unhide() {\\n  var els = document.getElementsByClassName('suite hidden');\\n  for (var i = 0; i < els.length; ++i) {\\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\\n  }\\n}\\n\\n/**\\n * Set an element's text contents.\\n *\\n * @param {HTMLElement} el\\n * @param {string} contents\\n */\\nfunction text(el, contents) {\\n  if (el.textContent) {\\n    el.textContent = contents;\\n  } else {\\n    el.innerText = contents;\\n  }\\n}\\n\\n/**\\n * Listen on `event` with callback `fn`.\\n */\\nfunction on(el, event, fn) {\\n  if (el.addEventListener) {\\n    el.addEventListener(event, fn, false);\\n  } else {\\n    el.attachEvent('on' + event, fn);\\n  }\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../browser/progress\\\":4,\\\"../utils\\\":39,\\\"./base\\\":17,\\\"escape-string-regexp\\\":49}],22:[function(require,module,exports){\\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\\nexports.Base = exports.base = require('./base');\\nexports.Dot = exports.dot = require('./dot');\\nexports.Doc = exports.doc = require('./doc');\\nexports.TAP = exports.tap = require('./tap');\\nexports.JSON = exports.json = require('./json');\\nexports.HTML = exports.html = require('./html');\\nexports.List = exports.list = require('./list');\\nexports.Min = exports.min = require('./min');\\nexports.Spec = exports.spec = require('./spec');\\nexports.Nyan = exports.nyan = require('./nyan');\\nexports.XUnit = exports.xunit = require('./xunit');\\nexports.Markdown = exports.markdown = require('./markdown');\\nexports.Progress = exports.progress = require('./progress');\\nexports.Landing = exports.landing = require('./landing');\\nexports.JSONCov = exports['json-cov'] = require('./json-cov');\\nexports.HTMLCov = exports['html-cov'] = require('./html-cov');\\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\\n\\n},{\\\"./base\\\":17,\\\"./doc\\\":18,\\\"./dot\\\":19,\\\"./html\\\":21,\\\"./html-cov\\\":20,\\\"./json\\\":25,\\\"./json-cov\\\":23,\\\"./json-stream\\\":24,\\\"./landing\\\":26,\\\"./list\\\":27,\\\"./markdown\\\":28,\\\"./min\\\":29,\\\"./nyan\\\":30,\\\"./progress\\\":31,\\\"./spec\\\":32,\\\"./tap\\\":33,\\\"./xunit\\\":34}],23:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `JSONCov`.\\n */\\n\\nexports = module.exports = JSONCov;\\n\\n/**\\n * Initialize a new `JsCoverage` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n * @param {boolean} output\\n */\\nfunction JSONCov(runner, output) {\\n  Base.call(this, runner);\\n\\n  output = arguments.length === 1 || output;\\n  var self = this;\\n  var tests = [];\\n  var failures = [];\\n  var passes = [];\\n\\n  runner.on('test end', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    passes.push(test);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    failures.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    var cov = global._$jscoverage || {};\\n    var result = self.cov = map(cov);\\n    result.stats = self.stats;\\n    result.tests = tests.map(clean);\\n    result.failures = failures.map(clean);\\n    result.passes = passes.map(clean);\\n    if (!output) {\\n      return;\\n    }\\n    process.stdout.write(JSON.stringify(result, null, 2));\\n  });\\n}\\n\\n/**\\n * Map jscoverage data to a JSON structure\\n * suitable for reporting.\\n *\\n * @api private\\n * @param {Object} cov\\n * @return {Object}\\n */\\n\\nfunction map(cov) {\\n  var ret = {\\n    instrumentation: 'node-jscoverage',\\n    sloc: 0,\\n    hits: 0,\\n    misses: 0,\\n    coverage: 0,\\n    files: []\\n  };\\n\\n  for (var filename in cov) {\\n    if (Object.prototype.hasOwnProperty.call(cov, filename)) {\\n      var data = coverage(filename, cov[filename]);\\n      ret.files.push(data);\\n      ret.hits += data.hits;\\n      ret.misses += data.misses;\\n      ret.sloc += data.sloc;\\n    }\\n  }\\n\\n  ret.files.sort(function(a, b) {\\n    return a.filename.localeCompare(b.filename);\\n  });\\n\\n  if (ret.sloc > 0) {\\n    ret.coverage = (ret.hits / ret.sloc) * 100;\\n  }\\n\\n  return ret;\\n}\\n\\n/**\\n * Map jscoverage data for a single source file\\n * to a JSON structure suitable for reporting.\\n *\\n * @api private\\n * @param {string} filename name of the source file\\n * @param {Object} data jscoverage coverage data\\n * @return {Object}\\n */\\nfunction coverage(filename, data) {\\n  var ret = {\\n    filename: filename,\\n    coverage: 0,\\n    hits: 0,\\n    misses: 0,\\n    sloc: 0,\\n    source: {}\\n  };\\n\\n  data.source.forEach(function(line, num) {\\n    num++;\\n\\n    if (data[num] === 0) {\\n      ret.misses++;\\n      ret.sloc++;\\n    } else if (data[num] !== undefined) {\\n      ret.hits++;\\n      ret.sloc++;\\n    }\\n\\n    ret.source[num] = {\\n      source: line,\\n      coverage: data[num] === undefined ? '' : data[num]\\n    };\\n  });\\n\\n  ret.coverage = ret.hits / ret.sloc * 100;\\n\\n  return ret;\\n}\\n\\n/**\\n * Return a plain-object representation of `test`\\n * free of cyclic properties etc.\\n *\\n * @api private\\n * @param {Object} test\\n * @return {Object}\\n */\\nfunction clean(test) {\\n  return {\\n    duration: test.duration,\\n    currentRetry: test.currentRetry(),\\n    fullTitle: test.fullTitle(),\\n    title: test.title\\n  };\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./base\\\":17,\\\"_process\\\":58}],24:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `List`.\\n */\\n\\nexports = module.exports = List;\\n\\n/**\\n * Initialize a new `List` test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction List(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var total = runner.total;\\n\\n  runner.on('start', function() {\\n    console.log(JSON.stringify(['start', { total: total }]));\\n  });\\n\\n  runner.on('pass', function(test) {\\n    console.log(JSON.stringify(['pass', clean(test)]));\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    test = clean(test);\\n    test.err = err.message;\\n    test.stack = err.stack || null;\\n    console.log(JSON.stringify(['fail', test]));\\n  });\\n\\n  runner.on('end', function() {\\n    process.stdout.write(JSON.stringify(['end', self.stats]));\\n  });\\n}\\n\\n/**\\n * Return a plain-object representation of `test`\\n * free of cyclic properties etc.\\n *\\n * @api private\\n * @param {Object} test\\n * @return {Object}\\n */\\nfunction clean(test) {\\n  return {\\n    title: test.title,\\n    fullTitle: test.fullTitle(),\\n    duration: test.duration,\\n    currentRetry: test.currentRetry()\\n  };\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./base\\\":17,\\\"_process\\\":58}],25:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `JSON`.\\n */\\n\\nexports = module.exports = JSONReporter;\\n\\n/**\\n * Initialize a new `JSON` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction JSONReporter(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var tests = [];\\n  var pending = [];\\n  var failures = [];\\n  var passes = [];\\n\\n  runner.on('test end', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    passes.push(test);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    failures.push(test);\\n  });\\n\\n  runner.on('pending', function(test) {\\n    pending.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    var obj = {\\n      stats: self.stats,\\n      tests: tests.map(clean),\\n      pending: pending.map(clean),\\n      failures: failures.map(clean),\\n      passes: passes.map(clean)\\n    };\\n\\n    runner.testResults = obj;\\n\\n    process.stdout.write(JSON.stringify(obj, null, 2));\\n  });\\n}\\n\\n/**\\n * Return a plain-object representation of `test`\\n * free of cyclic properties etc.\\n *\\n * @api private\\n * @param {Object} test\\n * @return {Object}\\n */\\nfunction clean(test) {\\n  return {\\n    title: test.title,\\n    fullTitle: test.fullTitle(),\\n    duration: test.duration,\\n    currentRetry: test.currentRetry(),\\n    err: errorJSON(test.err || {})\\n  };\\n}\\n\\n/**\\n * Transform `error` into a JSON object.\\n *\\n * @api private\\n * @param {Error} err\\n * @return {Object}\\n */\\nfunction errorJSON(err) {\\n  var res = {};\\n  Object.getOwnPropertyNames(err).forEach(function(key) {\\n    res[key] = err[key];\\n  }, err);\\n  return res;\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./base\\\":17,\\\"_process\\\":58}],26:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar cursor = Base.cursor;\\nvar color = Base.color;\\n\\n/**\\n * Expose `Landing`.\\n */\\n\\nexports = module.exports = Landing;\\n\\n/**\\n * Airplane color.\\n */\\n\\nBase.colors.plane = 0;\\n\\n/**\\n * Airplane crash color.\\n */\\n\\nBase.colors['plane crash'] = 31;\\n\\n/**\\n * Runway color.\\n */\\n\\nBase.colors.runway = 90;\\n\\n/**\\n * Initialize a new `Landing` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Landing(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .75 | 0;\\n  var total = runner.total;\\n  var stream = process.stdout;\\n  var plane = color('plane', '✈');\\n  var crashed = -1;\\n  var n = 0;\\n\\n  function runway() {\\n    var buf = Array(width).join('-');\\n    return '  ' + color('runway', buf);\\n  }\\n\\n  runner.on('start', function() {\\n    stream.write('\\\\n\\\\n\\\\n  ');\\n    cursor.hide();\\n  });\\n\\n  runner.on('test end', function(test) {\\n    // check if the plane crashed\\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\\n\\n    // show the crash\\n    if (test.state === 'failed') {\\n      plane = color('plane crash', '✈');\\n      crashed = col;\\n    }\\n\\n    // render landing strip\\n    stream.write('\\\\u001b[' + (width + 1) + 'D\\\\u001b[2A');\\n    stream.write(runway());\\n    stream.write('\\\\n  ');\\n    stream.write(color('runway', Array(col).join('⋅')));\\n    stream.write(plane);\\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\\\n'));\\n    stream.write(runway());\\n    stream.write('\\\\u001b[0m');\\n  });\\n\\n  runner.on('end', function() {\\n    cursor.show();\\n    console.log();\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Landing, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],27:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\nvar cursor = Base.cursor;\\n\\n/**\\n * Expose `List`.\\n */\\n\\nexports = module.exports = List;\\n\\n/**\\n * Initialize a new `List` test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction List(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var n = 0;\\n\\n  runner.on('start', function() {\\n    console.log();\\n  });\\n\\n  runner.on('test', function(test) {\\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\\n  });\\n\\n  runner.on('pending', function(test) {\\n    var fmt = color('checkmark', '  -')\\n      + color('pending', ' %s');\\n    console.log(fmt, test.fullTitle());\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var fmt = color('checkmark', '  ' + Base.symbols.dot)\\n      + color('pass', ' %s: ')\\n      + color(test.speed, '%dms');\\n    cursor.CR();\\n    console.log(fmt, test.fullTitle(), test.duration);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    cursor.CR();\\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\\n  });\\n\\n  runner.on('end', self.epilogue.bind(self));\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(List, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],28:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\n\\n/**\\n * Constants\\n */\\n\\nvar SUITE_PREFIX = '$';\\n\\n/**\\n * Expose `Markdown`.\\n */\\n\\nexports = module.exports = Markdown;\\n\\n/**\\n * Initialize a new `Markdown` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Markdown(runner) {\\n  Base.call(this, runner);\\n\\n  var level = 0;\\n  var buf = '';\\n\\n  function title(str) {\\n    return Array(level).join('#') + ' ' + str;\\n  }\\n\\n  function mapTOC(suite, obj) {\\n    var ret = obj;\\n    var key = SUITE_PREFIX + suite.title;\\n\\n    obj = obj[key] = obj[key] || { suite: suite };\\n    suite.suites.forEach(function(suite) {\\n      mapTOC(suite, obj);\\n    });\\n\\n    return ret;\\n  }\\n\\n  function stringifyTOC(obj, level) {\\n    ++level;\\n    var buf = '';\\n    var link;\\n    for (var key in obj) {\\n      if (key === 'suite') {\\n        continue;\\n      }\\n      if (key !== SUITE_PREFIX) {\\n        link = ' - [' + key.substring(1) + ']';\\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\\\n';\\n        buf += Array(level).join('  ') + link;\\n      }\\n      buf += stringifyTOC(obj[key], level);\\n    }\\n    return buf;\\n  }\\n\\n  function generateTOC(suite) {\\n    var obj = mapTOC(suite, {});\\n    return stringifyTOC(obj, 0);\\n  }\\n\\n  generateTOC(runner.suite);\\n\\n  runner.on('suite', function(suite) {\\n    ++level;\\n    var slug = utils.slug(suite.fullTitle());\\n    buf += '<a name=\\\"' + slug + '\\\"></a>' + '\\\\n';\\n    buf += title(suite.title) + '\\\\n';\\n  });\\n\\n  runner.on('suite end', function() {\\n    --level;\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var code = utils.clean(test.body);\\n    buf += test.title + '.\\\\n';\\n    buf += '\\\\n```js\\\\n';\\n    buf += code + '\\\\n';\\n    buf += '```\\\\n\\\\n';\\n  });\\n\\n  runner.on('end', function() {\\n    process.stdout.write('# TOC\\\\n');\\n    process.stdout.write(generateTOC(runner.suite));\\n    process.stdout.write(buf);\\n  });\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],29:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\n\\n/**\\n * Expose `Min`.\\n */\\n\\nexports = module.exports = Min;\\n\\n/**\\n * Initialize a new `Min` minimal test reporter (best used with --watch).\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Min(runner) {\\n  Base.call(this, runner);\\n\\n  runner.on('start', function() {\\n    // clear screen\\n    process.stdout.write('\\\\u001b[2J');\\n    // set cursor position\\n    process.stdout.write('\\\\u001b[1;3H');\\n  });\\n\\n  runner.on('end', this.epilogue.bind(this));\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Min, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],30:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\n\\n/**\\n * Expose `Dot`.\\n */\\n\\nexports = module.exports = NyanCat;\\n\\n/**\\n * Initialize a new `Dot` matrix test reporter.\\n *\\n * @param {Runner} runner\\n * @api public\\n */\\n\\nfunction NyanCat(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .75 | 0;\\n  var nyanCatWidth = this.nyanCatWidth = 11;\\n\\n  this.colorIndex = 0;\\n  this.numberOfLines = 4;\\n  this.rainbowColors = self.generateColors();\\n  this.scoreboardWidth = 5;\\n  this.tick = 0;\\n  this.trajectories = [[], [], [], []];\\n  this.trajectoryWidthMax = (width - nyanCatWidth);\\n\\n  runner.on('start', function() {\\n    Base.cursor.hide();\\n    self.draw();\\n  });\\n\\n  runner.on('pending', function() {\\n    self.draw();\\n  });\\n\\n  runner.on('pass', function() {\\n    self.draw();\\n  });\\n\\n  runner.on('fail', function() {\\n    self.draw();\\n  });\\n\\n  runner.on('end', function() {\\n    Base.cursor.show();\\n    for (var i = 0; i < self.numberOfLines; i++) {\\n      write('\\\\n');\\n    }\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(NyanCat, Base);\\n\\n/**\\n * Draw the nyan cat\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.draw = function() {\\n  this.appendRainbow();\\n  this.drawScoreboard();\\n  this.drawRainbow();\\n  this.drawNyanCat();\\n  this.tick = !this.tick;\\n};\\n\\n/**\\n * Draw the \\\"scoreboard\\\" showing the number\\n * of passes, failures and pending tests.\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.drawScoreboard = function() {\\n  var stats = this.stats;\\n\\n  function draw(type, n) {\\n    write(' ');\\n    write(Base.color(type, n));\\n    write('\\\\n');\\n  }\\n\\n  draw('green', stats.passes);\\n  draw('fail', stats.failures);\\n  draw('pending', stats.pending);\\n  write('\\\\n');\\n\\n  this.cursorUp(this.numberOfLines);\\n};\\n\\n/**\\n * Append the rainbow.\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.appendRainbow = function() {\\n  var segment = this.tick ? '_' : '-';\\n  var rainbowified = this.rainbowify(segment);\\n\\n  for (var index = 0; index < this.numberOfLines; index++) {\\n    var trajectory = this.trajectories[index];\\n    if (trajectory.length >= this.trajectoryWidthMax) {\\n      trajectory.shift();\\n    }\\n    trajectory.push(rainbowified);\\n  }\\n};\\n\\n/**\\n * Draw the rainbow.\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.drawRainbow = function() {\\n  var self = this;\\n\\n  this.trajectories.forEach(function(line) {\\n    write('\\\\u001b[' + self.scoreboardWidth + 'C');\\n    write(line.join(''));\\n    write('\\\\n');\\n  });\\n\\n  this.cursorUp(this.numberOfLines);\\n};\\n\\n/**\\n * Draw the nyan cat\\n *\\n * @api private\\n */\\nNyanCat.prototype.drawNyanCat = function() {\\n  var self = this;\\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\\n  var dist = '\\\\u001b[' + startWidth + 'C';\\n  var padding = '';\\n\\n  write(dist);\\n  write('_,------,');\\n  write('\\\\n');\\n\\n  write(dist);\\n  padding = self.tick ? '  ' : '   ';\\n  write('_|' + padding + '/\\\\\\\\_/\\\\\\\\ ');\\n  write('\\\\n');\\n\\n  write(dist);\\n  padding = self.tick ? '_' : '__';\\n  var tail = self.tick ? '~' : '^';\\n  write(tail + '|' + padding + this.face() + ' ');\\n  write('\\\\n');\\n\\n  write(dist);\\n  padding = self.tick ? ' ' : '  ';\\n  write(padding + '\\\"\\\"  \\\"\\\" ');\\n  write('\\\\n');\\n\\n  this.cursorUp(this.numberOfLines);\\n};\\n\\n/**\\n * Draw nyan cat face.\\n *\\n * @api private\\n * @return {string}\\n */\\n\\nNyanCat.prototype.face = function() {\\n  var stats = this.stats;\\n  if (stats.failures) {\\n    return '( x .x)';\\n  } else if (stats.pending) {\\n    return '( o .o)';\\n  } else if (stats.passes) {\\n    return '( ^ .^)';\\n  }\\n  return '( - .-)';\\n};\\n\\n/**\\n * Move cursor up `n`.\\n *\\n * @api private\\n * @param {number} n\\n */\\n\\nNyanCat.prototype.cursorUp = function(n) {\\n  write('\\\\u001b[' + n + 'A');\\n};\\n\\n/**\\n * Move cursor down `n`.\\n *\\n * @api private\\n * @param {number} n\\n */\\n\\nNyanCat.prototype.cursorDown = function(n) {\\n  write('\\\\u001b[' + n + 'B');\\n};\\n\\n/**\\n * Generate rainbow colors.\\n *\\n * @api private\\n * @return {Array}\\n */\\nNyanCat.prototype.generateColors = function() {\\n  var colors = [];\\n\\n  for (var i = 0; i < (6 * 7); i++) {\\n    var pi3 = Math.floor(Math.PI / 3);\\n    var n = (i * (1.0 / 6));\\n    var r = Math.floor(3 * Math.sin(n) + 3);\\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\\n    colors.push(36 * r + 6 * g + b + 16);\\n  }\\n\\n  return colors;\\n};\\n\\n/**\\n * Apply rainbow to the given `str`.\\n *\\n * @api private\\n * @param {string} str\\n * @return {string}\\n */\\nNyanCat.prototype.rainbowify = function(str) {\\n  if (!Base.useColors) {\\n    return str;\\n  }\\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\\n  this.colorIndex += 1;\\n  return '\\\\u001b[38;5;' + color + 'm' + str + '\\\\u001b[0m';\\n};\\n\\n/**\\n * Stdout helper.\\n *\\n * @param {string} string A message to write to stdout.\\n */\\nfunction write(string) {\\n  process.stdout.write(string);\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],31:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\nvar cursor = Base.cursor;\\n\\n/**\\n * Expose `Progress`.\\n */\\n\\nexports = module.exports = Progress;\\n\\n/**\\n * General progress bar color.\\n */\\n\\nBase.colors.progress = 90;\\n\\n/**\\n * Initialize a new `Progress` bar test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n * @param {Object} options\\n */\\nfunction Progress(runner, options) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .50 | 0;\\n  var total = runner.total;\\n  var complete = 0;\\n  var lastN = -1;\\n\\n  // default chars\\n  options = options || {};\\n  options.open = options.open || '[';\\n  options.complete = options.complete || '▬';\\n  options.incomplete = options.incomplete || Base.symbols.dot;\\n  options.close = options.close || ']';\\n  options.verbose = false;\\n\\n  // tests started\\n  runner.on('start', function() {\\n    console.log();\\n    cursor.hide();\\n  });\\n\\n  // tests complete\\n  runner.on('test end', function() {\\n    complete++;\\n\\n    var percent = complete / total;\\n    var n = width * percent | 0;\\n    var i = width - n;\\n\\n    if (n === lastN && !options.verbose) {\\n      // Don't re-render the line if it hasn't changed\\n      return;\\n    }\\n    lastN = n;\\n\\n    cursor.CR();\\n    process.stdout.write('\\\\u001b[J');\\n    process.stdout.write(color('progress', '  ' + options.open));\\n    process.stdout.write(Array(n).join(options.complete));\\n    process.stdout.write(Array(i).join(options.incomplete));\\n    process.stdout.write(color('progress', options.close));\\n    if (options.verbose) {\\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\\n    }\\n  });\\n\\n  // tests are complete, output some stats\\n  // and the failures if any\\n  runner.on('end', function() {\\n    cursor.show();\\n    console.log();\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Progress, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58}],32:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\nvar cursor = Base.cursor;\\n\\n/**\\n * Expose `Spec`.\\n */\\n\\nexports = module.exports = Spec;\\n\\n/**\\n * Initialize a new `Spec` test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Spec(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var indents = 0;\\n  var n = 0;\\n\\n  function indent() {\\n    return Array(indents).join('  ');\\n  }\\n\\n  runner.on('start', function() {\\n    console.log();\\n  });\\n\\n  runner.on('suite', function(suite) {\\n    ++indents;\\n    console.log(color('suite', '%s%s'), indent(), suite.title);\\n  });\\n\\n  runner.on('suite end', function() {\\n    --indents;\\n    if (indents === 1) {\\n      console.log();\\n    }\\n  });\\n\\n  runner.on('pending', function(test) {\\n    var fmt = indent() + color('pending', '  - %s');\\n    console.log(fmt, test.title);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var fmt;\\n    if (test.speed === 'fast') {\\n      fmt = indent()\\n        + color('checkmark', '  ' + Base.symbols.ok)\\n        + color('pass', ' %s');\\n      cursor.CR();\\n      console.log(fmt, test.title);\\n    } else {\\n      fmt = indent()\\n        + color('checkmark', '  ' + Base.symbols.ok)\\n        + color('pass', ' %s')\\n        + color(test.speed, ' (%dms)');\\n      cursor.CR();\\n      console.log(fmt, test.title, test.duration);\\n    }\\n  });\\n\\n  runner.on('fail', function(test) {\\n    cursor.CR();\\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\\n  });\\n\\n  runner.on('end', self.epilogue.bind(self));\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Spec, Base);\\n\\n},{\\\"../utils\\\":39,\\\"./base\\\":17}],33:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `TAP`.\\n */\\n\\nexports = module.exports = TAP;\\n\\n/**\\n * Initialize a new `TAP` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction TAP(runner) {\\n  Base.call(this, runner);\\n\\n  var n = 1;\\n  var passes = 0;\\n  var failures = 0;\\n\\n  runner.on('start', function() {\\n    var total = runner.grepTotal(runner.suite);\\n    console.log('%d..%d', 1, total);\\n  });\\n\\n  runner.on('test end', function() {\\n    ++n;\\n  });\\n\\n  runner.on('pending', function(test) {\\n    console.log('ok %d %s # SKIP -', n, title(test));\\n  });\\n\\n  runner.on('pass', function(test) {\\n    passes++;\\n    console.log('ok %d %s', n, title(test));\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    failures++;\\n    console.log('not ok %d %s', n, title(test));\\n    if (err.stack) {\\n      console.log(err.stack.replace(/^/gm, '  '));\\n    }\\n  });\\n\\n  runner.on('end', function() {\\n    console.log('# tests ' + (passes + failures));\\n    console.log('# pass ' + passes);\\n    console.log('# fail ' + failures);\\n  });\\n}\\n\\n/**\\n * Return a TAP-safe title of `test`\\n *\\n * @api private\\n * @param {Object} test\\n * @return {String}\\n */\\nfunction title(test) {\\n  return test.fullTitle().replace(/#/g, '');\\n}\\n\\n},{\\\"./base\\\":17}],34:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\nvar inherits = utils.inherits;\\nvar fs = require('fs');\\nvar escape = utils.escape;\\nvar mkdirp = require('mkdirp');\\nvar path = require('path');\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Expose `XUnit`.\\n */\\n\\nexports = module.exports = XUnit;\\n\\n/**\\n * Initialize a new `XUnit` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction XUnit(runner, options) {\\n  Base.call(this, runner);\\n\\n  var stats = this.stats;\\n  var tests = [];\\n  var self = this;\\n\\n  if (options.reporterOptions && options.reporterOptions.output) {\\n    if (!fs.createWriteStream) {\\n      throw new Error('file output not supported in browser');\\n    }\\n    mkdirp.sync(path.dirname(options.reporterOptions.output));\\n    self.fileStream = fs.createWriteStream(options.reporterOptions.output);\\n  }\\n\\n  runner.on('pending', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    self.write(tag('testsuite', {\\n      name: 'Mocha Tests',\\n      tests: stats.tests,\\n      failures: stats.failures,\\n      errors: stats.failures,\\n      skipped: stats.tests - stats.failures - stats.passes,\\n      timestamp: (new Date()).toUTCString(),\\n      time: (stats.duration / 1000) || 0\\n    }, false));\\n\\n    tests.forEach(function(t) {\\n      self.test(t);\\n    });\\n\\n    self.write('</testsuite>');\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(XUnit, Base);\\n\\n/**\\n * Override done to close the stream (if it's a file).\\n *\\n * @param failures\\n * @param {Function} fn\\n */\\nXUnit.prototype.done = function(failures, fn) {\\n  if (this.fileStream) {\\n    this.fileStream.end(function() {\\n      fn(failures);\\n    });\\n  } else {\\n    fn(failures);\\n  }\\n};\\n\\n/**\\n * Write out the given line.\\n *\\n * @param {string} line\\n */\\nXUnit.prototype.write = function(line) {\\n  if (this.fileStream) {\\n    this.fileStream.write(line + '\\\\n');\\n  } else if (typeof process === 'object' && process.stdout) {\\n    process.stdout.write(line + '\\\\n');\\n  } else {\\n    console.log(line);\\n  }\\n};\\n\\n/**\\n * Output tag for the given `test.`\\n *\\n * @param {Test} test\\n */\\nXUnit.prototype.test = function(test) {\\n  var attrs = {\\n    classname: test.parent.fullTitle(),\\n    name: test.title,\\n    time: (test.duration / 1000) || 0\\n  };\\n\\n  if (test.state === 'failed') {\\n    var err = test.err;\\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\\\\n' + escape(err.stack))));\\n  } else if (test.isPending()) {\\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\\n  } else {\\n    this.write(tag('testcase', attrs, true));\\n  }\\n};\\n\\n/**\\n * HTML tag helper.\\n *\\n * @param name\\n * @param attrs\\n * @param close\\n * @param content\\n * @return {string}\\n */\\nfunction tag(name, attrs, close, content) {\\n  var end = close ? '/>' : '>';\\n  var pairs = [];\\n  var tag;\\n\\n  for (var key in attrs) {\\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\\n      pairs.push(key + '=\\\"' + escape(attrs[key]) + '\\\"');\\n    }\\n  }\\n\\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\\n  if (content) {\\n    tag += content + '</' + name + end;\\n  }\\n  return tag;\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":58,\\\"fs\\\":43,\\\"mkdirp\\\":55,\\\"path\\\":43}],35:[function(require,module,exports){\\n(function (global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar EventEmitter = require('events').EventEmitter;\\nvar Pending = require('./pending');\\nvar debug = require('debug')('mocha:runnable');\\nvar milliseconds = require('./ms');\\nvar utils = require('./utils');\\nvar inherits = utils.inherits;\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Object#toString().\\n */\\n\\nvar toString = Object.prototype.toString;\\n\\n/**\\n * Expose `Runnable`.\\n */\\n\\nmodule.exports = Runnable;\\n\\n/**\\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\\n *\\n * @param {String} title\\n * @param {Function} fn\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n */\\nfunction Runnable(title, fn) {\\n  this.title = title;\\n  this.fn = fn;\\n  this.body = (fn || '').toString();\\n  this.async = fn && fn.length;\\n  this.sync = !this.async;\\n  this._timeout = 2000;\\n  this._slow = 75;\\n  this._enableTimeouts = true;\\n  this.timedOut = false;\\n  this._trace = new Error('done() called multiple times');\\n  this._retries = -1;\\n  this._currentRetry = 0;\\n  this.pending = false;\\n}\\n\\n/**\\n * Inherit from `EventEmitter.prototype`.\\n */\\ninherits(Runnable, EventEmitter);\\n\\n/**\\n * Set & get timeout `ms`.\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Runnable|number} ms or Runnable instance.\\n */\\nRunnable.prototype.timeout = function(ms) {\\n  if (!arguments.length) {\\n    return this._timeout;\\n  }\\n  if (ms === 0) {\\n    this._enableTimeouts = false;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('timeout %d', ms);\\n  this._timeout = ms;\\n  if (this.timer) {\\n    this.resetTimeout();\\n  }\\n  return this;\\n};\\n\\n/**\\n * Set & get slow `ms`.\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Runnable|number} ms or Runnable instance.\\n */\\nRunnable.prototype.slow = function(ms) {\\n  if (!arguments.length) {\\n    return this._slow;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('timeout %d', ms);\\n  this._slow = ms;\\n  return this;\\n};\\n\\n/**\\n * Set and get whether timeout is `enabled`.\\n *\\n * @api private\\n * @param {boolean} enabled\\n * @return {Runnable|boolean} enabled or Runnable instance.\\n */\\nRunnable.prototype.enableTimeouts = function(enabled) {\\n  if (!arguments.length) {\\n    return this._enableTimeouts;\\n  }\\n  debug('enableTimeouts %s', enabled);\\n  this._enableTimeouts = enabled;\\n  return this;\\n};\\n\\n/**\\n * Halt and mark as pending.\\n *\\n * @api public\\n */\\nRunnable.prototype.skip = function() {\\n  throw new Pending();\\n};\\n\\n/**\\n * Check if this runnable or its parent suite is marked as pending.\\n *\\n * @api private\\n */\\nRunnable.prototype.isPending = function() {\\n  return this.pending || (this.parent && this.parent.isPending());\\n};\\n\\n/**\\n * Set number of retries.\\n *\\n * @api private\\n */\\nRunnable.prototype.retries = function(n) {\\n  if (!arguments.length) {\\n    return this._retries;\\n  }\\n  this._retries = n;\\n};\\n\\n/**\\n * Get current retry\\n *\\n * @api private\\n */\\nRunnable.prototype.currentRetry = function(n) {\\n  if (!arguments.length) {\\n    return this._currentRetry;\\n  }\\n  this._currentRetry = n;\\n};\\n\\n/**\\n * Return the full title generated by recursively concatenating the parent's\\n * full title.\\n *\\n * @api public\\n * @return {string}\\n */\\nRunnable.prototype.fullTitle = function() {\\n  return this.parent.fullTitle() + ' ' + this.title;\\n};\\n\\n/**\\n * Clear the timeout.\\n *\\n * @api private\\n */\\nRunnable.prototype.clearTimeout = function() {\\n  clearTimeout(this.timer);\\n};\\n\\n/**\\n * Inspect the runnable void of private properties.\\n *\\n * @api private\\n * @return {string}\\n */\\nRunnable.prototype.inspect = function() {\\n  return JSON.stringify(this, function(key, val) {\\n    if (key[0] === '_') {\\n      return;\\n    }\\n    if (key === 'parent') {\\n      return '#<Suite>';\\n    }\\n    if (key === 'ctx') {\\n      return '#<Context>';\\n    }\\n    return val;\\n  }, 2);\\n};\\n\\n/**\\n * Reset the timeout.\\n *\\n * @api private\\n */\\nRunnable.prototype.resetTimeout = function() {\\n  var self = this;\\n  var ms = this.timeout() || 1e9;\\n\\n  if (!this._enableTimeouts) {\\n    return;\\n  }\\n  this.clearTimeout();\\n  this.timer = setTimeout(function() {\\n    if (!self._enableTimeouts) {\\n      return;\\n    }\\n    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));\\n    self.timedOut = true;\\n  }, ms);\\n};\\n\\n/**\\n * Whitelist a list of globals for this test run.\\n *\\n * @api private\\n * @param {string[]} globals\\n */\\nRunnable.prototype.globals = function(globals) {\\n  if (!arguments.length) {\\n    return this._allowedGlobals;\\n  }\\n  this._allowedGlobals = globals;\\n};\\n\\n/**\\n * Run the test and invoke `fn(err)`.\\n *\\n * @param {Function} fn\\n * @api private\\n */\\nRunnable.prototype.run = function(fn) {\\n  var self = this;\\n  var start = new Date();\\n  var ctx = this.ctx;\\n  var finished;\\n  var emitted;\\n\\n  // Sometimes the ctx exists, but it is not runnable\\n  if (ctx && ctx.runnable) {\\n    ctx.runnable(this);\\n  }\\n\\n  // called multiple times\\n  function multiple(err) {\\n    if (emitted) {\\n      return;\\n    }\\n    emitted = true;\\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\\n  }\\n\\n  // finished\\n  function done(err) {\\n    var ms = self.timeout();\\n    if (self.timedOut) {\\n      return;\\n    }\\n    if (finished) {\\n      return multiple(err || self._trace);\\n    }\\n\\n    self.clearTimeout();\\n    self.duration = new Date() - start;\\n    finished = true;\\n    if (!err && self.duration > ms && self._enableTimeouts) {\\n      err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');\\n    }\\n    fn(err);\\n  }\\n\\n  // for .resetTimeout()\\n  this.callback = done;\\n\\n  // explicit async with `done` argument\\n  if (this.async) {\\n    this.resetTimeout();\\n\\n    if (this.allowUncaught) {\\n      return callFnAsync(this.fn);\\n    }\\n    try {\\n      callFnAsync(this.fn);\\n    } catch (err) {\\n      done(utils.getError(err));\\n    }\\n    return;\\n  }\\n\\n  if (this.allowUncaught) {\\n    callFn(this.fn);\\n    done();\\n    return;\\n  }\\n\\n  // sync or promise-returning\\n  try {\\n    if (this.isPending()) {\\n      done();\\n    } else {\\n      callFn(this.fn);\\n    }\\n  } catch (err) {\\n    done(utils.getError(err));\\n  }\\n\\n  function callFn(fn) {\\n    var result = fn.call(ctx);\\n    if (result && typeof result.then === 'function') {\\n      self.resetTimeout();\\n      result\\n        .then(function() {\\n          done();\\n          // Return null so libraries like bluebird do not warn about\\n          // subsequently constructed Promises.\\n          return null;\\n        },\\n        function(reason) {\\n          done(reason || new Error('Promise rejected with no or falsy reason'));\\n        });\\n    } else {\\n      if (self.asyncOnly) {\\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\\n      }\\n\\n      done();\\n    }\\n  }\\n\\n  function callFnAsync(fn) {\\n    fn.call(ctx, function(err) {\\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\\n        return done(err);\\n      }\\n      if (err) {\\n        if (Object.prototype.toString.call(err) === '[object Object]') {\\n          return done(new Error('done() invoked with non-Error: '\\n            + JSON.stringify(err)));\\n        }\\n        return done(new Error('done() invoked with non-Error: ' + err));\\n      }\\n      done();\\n    });\\n  }\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./ms\\\":15,\\\"./pending\\\":16,\\\"./utils\\\":39,\\\"debug\\\":2,\\\"events\\\":3}],36:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar EventEmitter = require('events').EventEmitter;\\nvar Pending = require('./pending');\\nvar utils = require('./utils');\\nvar inherits = utils.inherits;\\nvar debug = require('debug')('mocha:runner');\\nvar Runnable = require('./runnable');\\nvar filter = utils.filter;\\nvar indexOf = utils.indexOf;\\nvar keys = utils.keys;\\nvar stackFilter = utils.stackTraceFilter();\\nvar stringify = utils.stringify;\\nvar type = utils.type;\\nvar undefinedError = utils.undefinedError;\\nvar isArray = utils.isArray;\\n\\n/**\\n * Non-enumerable globals.\\n */\\n\\nvar globals = [\\n  'setTimeout',\\n  'clearTimeout',\\n  'setInterval',\\n  'clearInterval',\\n  'XMLHttpRequest',\\n  'Date',\\n  'setImmediate',\\n  'clearImmediate'\\n];\\n\\n/**\\n * Expose `Runner`.\\n */\\n\\nmodule.exports = Runner;\\n\\n/**\\n * Initialize a `Runner` for the given `suite`.\\n *\\n * Events:\\n *\\n *   - `start`  execution started\\n *   - `end`  execution complete\\n *   - `suite`  (suite) test suite execution started\\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\\n *   - `test`  (test) test execution started\\n *   - `test end`  (test) test completed\\n *   - `hook`  (hook) hook execution started\\n *   - `hook end`  (hook) hook complete\\n *   - `pass`  (test) test passed\\n *   - `fail`  (test, err) test failed\\n *   - `pending`  (test) test pending\\n *\\n * @api public\\n * @param {Suite} suite Root suite\\n * @param {boolean} [delay] Whether or not to delay execution of root suite\\n * until ready.\\n */\\nfunction Runner(suite, delay) {\\n  var self = this;\\n  this._globals = [];\\n  this._abort = false;\\n  this._delay = delay;\\n  this.suite = suite;\\n  this.started = false;\\n  this.total = suite.total();\\n  this.failures = 0;\\n  this.on('test end', function(test) {\\n    self.checkGlobals(test);\\n  });\\n  this.on('hook end', function(hook) {\\n    self.checkGlobals(hook);\\n  });\\n  this._defaultGrep = /.*/;\\n  this.grep(this._defaultGrep);\\n  this.globals(this.globalProps().concat(extraGlobals()));\\n}\\n\\n/**\\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\\n *\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.immediately = global.setImmediate || process.nextTick;\\n\\n/**\\n * Inherit from `EventEmitter.prototype`.\\n */\\ninherits(Runner, EventEmitter);\\n\\n/**\\n * Run tests with full titles matching `re`. Updates runner.total\\n * with number of tests matched.\\n *\\n * @param {RegExp} re\\n * @param {Boolean} invert\\n * @return {Runner} for chaining\\n * @api public\\n * @param {RegExp} re\\n * @param {boolean} invert\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.grep = function(re, invert) {\\n  debug('grep %s', re);\\n  this._grep = re;\\n  this._invert = invert;\\n  this.total = this.grepTotal(this.suite);\\n  return this;\\n};\\n\\n/**\\n * Returns the number of tests matching the grep search for the\\n * given suite.\\n *\\n * @param {Suite} suite\\n * @return {Number}\\n * @api public\\n * @param {Suite} suite\\n * @return {number}\\n */\\nRunner.prototype.grepTotal = function(suite) {\\n  var self = this;\\n  var total = 0;\\n\\n  suite.eachTest(function(test) {\\n    var match = self._grep.test(test.fullTitle());\\n    if (self._invert) {\\n      match = !match;\\n    }\\n    if (match) {\\n      total++;\\n    }\\n  });\\n\\n  return total;\\n};\\n\\n/**\\n * Return a list of global properties.\\n *\\n * @return {Array}\\n * @api private\\n */\\nRunner.prototype.globalProps = function() {\\n  var props = keys(global);\\n\\n  // non-enumerables\\n  for (var i = 0; i < globals.length; ++i) {\\n    if (~indexOf(props, globals[i])) {\\n      continue;\\n    }\\n    props.push(globals[i]);\\n  }\\n\\n  return props;\\n};\\n\\n/**\\n * Allow the given `arr` of globals.\\n *\\n * @param {Array} arr\\n * @return {Runner} for chaining\\n * @api public\\n * @param {Array} arr\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.globals = function(arr) {\\n  if (!arguments.length) {\\n    return this._globals;\\n  }\\n  debug('globals %j', arr);\\n  this._globals = this._globals.concat(arr);\\n  return this;\\n};\\n\\n/**\\n * Check for global variable leaks.\\n *\\n * @api private\\n */\\nRunner.prototype.checkGlobals = function(test) {\\n  if (this.ignoreLeaks) {\\n    return;\\n  }\\n  var ok = this._globals;\\n\\n  var globals = this.globalProps();\\n  var leaks;\\n\\n  if (test) {\\n    ok = ok.concat(test._allowedGlobals || []);\\n  }\\n\\n  if (this.prevGlobalsLength === globals.length) {\\n    return;\\n  }\\n  this.prevGlobalsLength = globals.length;\\n\\n  leaks = filterLeaks(ok, globals);\\n  this._globals = this._globals.concat(leaks);\\n\\n  if (leaks.length > 1) {\\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\\n  } else if (leaks.length) {\\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\\n  }\\n};\\n\\n/**\\n * Fail the given `test`.\\n *\\n * @api private\\n * @param {Test} test\\n * @param {Error} err\\n */\\nRunner.prototype.fail = function(test, err) {\\n  ++this.failures;\\n  test.state = 'failed';\\n\\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\\n  }\\n\\n  err.stack = (this.fullStackTrace || !err.stack)\\n    ? err.stack\\n    : stackFilter(err.stack);\\n\\n  this.emit('fail', test, err);\\n};\\n\\n/**\\n * Fail the given `hook` with `err`.\\n *\\n * Hook failures work in the following pattern:\\n * - If bail, then exit\\n * - Failed `before` hook skips all tests in a suite and subsuites,\\n *   but jumps to corresponding `after` hook\\n * - Failed `before each` hook skips remaining tests in a\\n *   suite and jumps to corresponding `after each` hook,\\n *   which is run only once\\n * - Failed `after` hook does not alter\\n *   execution order\\n * - Failed `after each` hook skips remaining tests in a\\n *   suite and subsuites, but executes other `after each`\\n *   hooks\\n *\\n * @api private\\n * @param {Hook} hook\\n * @param {Error} err\\n */\\nRunner.prototype.failHook = function(hook, err) {\\n  if (hook.ctx && hook.ctx.currentTest) {\\n    hook.originalTitle = hook.originalTitle || hook.title;\\n    hook.title = hook.originalTitle + ' for \\\"' + hook.ctx.currentTest.title + '\\\"';\\n  }\\n\\n  this.fail(hook, err);\\n  if (this.suite.bail()) {\\n    this.emit('end');\\n  }\\n};\\n\\n/**\\n * Run hook `name` callbacks and then invoke `fn()`.\\n *\\n * @api private\\n * @param {string} name\\n * @param {Function} fn\\n */\\n\\nRunner.prototype.hook = function(name, fn) {\\n  var suite = this.suite;\\n  var hooks = suite['_' + name];\\n  var self = this;\\n\\n  function next(i) {\\n    var hook = hooks[i];\\n    if (!hook) {\\n      return fn();\\n    }\\n    self.currentRunnable = hook;\\n\\n    hook.ctx.currentTest = self.test;\\n\\n    self.emit('hook', hook);\\n\\n    if (!hook.listeners('error').length) {\\n      hook.on('error', function(err) {\\n        self.failHook(hook, err);\\n      });\\n    }\\n\\n    hook.run(function(err) {\\n      var testError = hook.error();\\n      if (testError) {\\n        self.fail(self.test, testError);\\n      }\\n      if (err) {\\n        if (err instanceof Pending) {\\n          suite.pending = true;\\n        } else {\\n          self.failHook(hook, err);\\n\\n          // stop executing hooks, notify callee of hook err\\n          return fn(err);\\n        }\\n      }\\n      self.emit('hook end', hook);\\n      delete hook.ctx.currentTest;\\n      next(++i);\\n    });\\n  }\\n\\n  Runner.immediately(function() {\\n    next(0);\\n  });\\n};\\n\\n/**\\n * Run hook `name` for the given array of `suites`\\n * in order, and callback `fn(err, errSuite)`.\\n *\\n * @api private\\n * @param {string} name\\n * @param {Array} suites\\n * @param {Function} fn\\n */\\nRunner.prototype.hooks = function(name, suites, fn) {\\n  var self = this;\\n  var orig = this.suite;\\n\\n  function next(suite) {\\n    self.suite = suite;\\n\\n    if (!suite) {\\n      self.suite = orig;\\n      return fn();\\n    }\\n\\n    self.hook(name, function(err) {\\n      if (err) {\\n        var errSuite = self.suite;\\n        self.suite = orig;\\n        return fn(err, errSuite);\\n      }\\n\\n      next(suites.pop());\\n    });\\n  }\\n\\n  next(suites.pop());\\n};\\n\\n/**\\n * Run hooks from the top level down.\\n *\\n * @param {String} name\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.prototype.hookUp = function(name, fn) {\\n  var suites = [this.suite].concat(this.parents()).reverse();\\n  this.hooks(name, suites, fn);\\n};\\n\\n/**\\n * Run hooks from the bottom up.\\n *\\n * @param {String} name\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.prototype.hookDown = function(name, fn) {\\n  var suites = [this.suite].concat(this.parents());\\n  this.hooks(name, suites, fn);\\n};\\n\\n/**\\n * Return an array of parent Suites from\\n * closest to furthest.\\n *\\n * @return {Array}\\n * @api private\\n */\\nRunner.prototype.parents = function() {\\n  var suite = this.suite;\\n  var suites = [];\\n  while (suite.parent) {\\n    suite = suite.parent;\\n    suites.push(suite);\\n  }\\n  return suites;\\n};\\n\\n/**\\n * Run the current test and callback `fn(err)`.\\n *\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.prototype.runTest = function(fn) {\\n  var self = this;\\n  var test = this.test;\\n\\n  if (this.asyncOnly) {\\n    test.asyncOnly = true;\\n  }\\n\\n  if (this.allowUncaught) {\\n    test.allowUncaught = true;\\n    return test.run(fn);\\n  }\\n  try {\\n    test.on('error', function(err) {\\n      self.fail(test, err);\\n    });\\n    test.run(fn);\\n  } catch (err) {\\n    fn(err);\\n  }\\n};\\n\\n/**\\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\\n *\\n * @api private\\n * @param {Suite} suite\\n * @param {Function} fn\\n */\\nRunner.prototype.runTests = function(suite, fn) {\\n  var self = this;\\n  var tests = suite.tests.slice();\\n  var test;\\n\\n  function hookErr(_, errSuite, after) {\\n    // before/after Each hook for errSuite failed:\\n    var orig = self.suite;\\n\\n    // for failed 'after each' hook start from errSuite parent,\\n    // otherwise start from errSuite itself\\n    self.suite = after ? errSuite.parent : errSuite;\\n\\n    if (self.suite) {\\n      // call hookUp afterEach\\n      self.hookUp('afterEach', function(err2, errSuite2) {\\n        self.suite = orig;\\n        // some hooks may fail even now\\n        if (err2) {\\n          return hookErr(err2, errSuite2, true);\\n        }\\n        // report error suite\\n        fn(errSuite);\\n      });\\n    } else {\\n      // there is no need calling other 'after each' hooks\\n      self.suite = orig;\\n      fn(errSuite);\\n    }\\n  }\\n\\n  function next(err, errSuite) {\\n    // if we bail after first err\\n    if (self.failures && suite._bail) {\\n      return fn();\\n    }\\n\\n    if (self._abort) {\\n      return fn();\\n    }\\n\\n    if (err) {\\n      return hookErr(err, errSuite, true);\\n    }\\n\\n    // next test\\n    test = tests.shift();\\n\\n    // all done\\n    if (!test) {\\n      return fn();\\n    }\\n\\n    // grep\\n    var match = self._grep.test(test.fullTitle());\\n    if (self._invert) {\\n      match = !match;\\n    }\\n    if (!match) {\\n      // Run immediately only if we have defined a grep. When we\\n      // define a grep — It can cause maximum callstack error if\\n      // the grep is doing a large recursive loop by neglecting\\n      // all tests. The run immediately function also comes with\\n      // a performance cost. So we don't want to run immediately\\n      // if we run the whole test suite, because running the whole\\n      // test suite don't do any immediate recursive loops. Thus,\\n      // allowing a JS runtime to breathe.\\n      if (self._grep !== self._defaultGrep) {\\n        Runner.immediately(next);\\n      } else {\\n        next();\\n      }\\n      return;\\n    }\\n\\n    if (test.isPending()) {\\n      self.emit('pending', test);\\n      self.emit('test end', test);\\n      return next();\\n    }\\n\\n    // execute test and hook(s)\\n    self.emit('test', self.test = test);\\n    self.hookDown('beforeEach', function(err, errSuite) {\\n      if (suite.isPending()) {\\n        self.emit('pending', test);\\n        self.emit('test end', test);\\n        return next();\\n      }\\n      if (err) {\\n        return hookErr(err, errSuite, false);\\n      }\\n      self.currentRunnable = self.test;\\n      self.runTest(function(err) {\\n        test = self.test;\\n        if (err) {\\n          var retry = test.currentRetry();\\n          if (err instanceof Pending) {\\n            test.pending = true;\\n            self.emit('pending', test);\\n          } else if (retry < test.retries()) {\\n            var clonedTest = test.clone();\\n            clonedTest.currentRetry(retry + 1);\\n            tests.unshift(clonedTest);\\n\\n            // Early return + hook trigger so that it doesn't\\n            // increment the count wrong\\n            return self.hookUp('afterEach', next);\\n          } else {\\n            self.fail(test, err);\\n          }\\n          self.emit('test end', test);\\n\\n          if (err instanceof Pending) {\\n            return next();\\n          }\\n\\n          return self.hookUp('afterEach', next);\\n        }\\n\\n        test.state = 'passed';\\n        self.emit('pass', test);\\n        self.emit('test end', test);\\n        self.hookUp('afterEach', next);\\n      });\\n    });\\n  }\\n\\n  this.next = next;\\n  this.hookErr = hookErr;\\n  next();\\n};\\n\\n/**\\n * Run the given `suite` and invoke the callback `fn()` when complete.\\n *\\n * @api private\\n * @param {Suite} suite\\n * @param {Function} fn\\n */\\nRunner.prototype.runSuite = function(suite, fn) {\\n  var i = 0;\\n  var self = this;\\n  var total = this.grepTotal(suite);\\n  var afterAllHookCalled = false;\\n\\n  debug('run suite %s', suite.fullTitle());\\n\\n  if (!total || (self.failures && suite._bail)) {\\n    return fn();\\n  }\\n\\n  this.emit('suite', this.suite = suite);\\n\\n  function next(errSuite) {\\n    if (errSuite) {\\n      // current suite failed on a hook from errSuite\\n      if (errSuite === suite) {\\n        // if errSuite is current suite\\n        // continue to the next sibling suite\\n        return done();\\n      }\\n      // errSuite is among the parents of current suite\\n      // stop execution of errSuite and all sub-suites\\n      return done(errSuite);\\n    }\\n\\n    if (self._abort) {\\n      return done();\\n    }\\n\\n    var curr = suite.suites[i++];\\n    if (!curr) {\\n      return done();\\n    }\\n\\n    // Avoid grep neglecting large number of tests causing a\\n    // huge recursive loop and thus a maximum call stack error.\\n    // See comment in `this.runTests()` for more information.\\n    if (self._grep !== self._defaultGrep) {\\n      Runner.immediately(function() {\\n        self.runSuite(curr, next);\\n      });\\n    } else {\\n      self.runSuite(curr, next);\\n    }\\n  }\\n\\n  function done(errSuite) {\\n    self.suite = suite;\\n    self.nextSuite = next;\\n\\n    if (afterAllHookCalled) {\\n      fn(errSuite);\\n    } else {\\n      // mark that the afterAll block has been called once\\n      // and so can be skipped if there is an error in it.\\n      afterAllHookCalled = true;\\n\\n      // remove reference to test\\n      delete self.test;\\n\\n      self.hook('afterAll', function() {\\n        self.emit('suite end', suite);\\n        fn(errSuite);\\n      });\\n    }\\n  }\\n\\n  this.nextSuite = next;\\n\\n  this.hook('beforeAll', function(err) {\\n    if (err) {\\n      return done();\\n    }\\n    self.runTests(suite, next);\\n  });\\n};\\n\\n/**\\n * Handle uncaught exceptions.\\n *\\n * @param {Error} err\\n * @api private\\n */\\nRunner.prototype.uncaught = function(err) {\\n  if (err) {\\n    debug('uncaught exception %s', err !== function() {\\n      return this;\\n    }.call(err) ? err : (err.message || err));\\n  } else {\\n    debug('uncaught undefined exception');\\n    err = undefinedError();\\n  }\\n  err.uncaught = true;\\n\\n  var runnable = this.currentRunnable;\\n\\n  if (!runnable) {\\n    runnable = new Runnable('Uncaught error outside test suite');\\n    runnable.parent = this.suite;\\n\\n    if (this.started) {\\n      this.fail(runnable, err);\\n    } else {\\n      // Can't recover from this failure\\n      this.emit('start');\\n      this.fail(runnable, err);\\n      this.emit('end');\\n    }\\n\\n    return;\\n  }\\n\\n  runnable.clearTimeout();\\n\\n  // Ignore errors if complete\\n  if (runnable.state) {\\n    return;\\n  }\\n  this.fail(runnable, err);\\n\\n  // recover from test\\n  if (runnable.type === 'test') {\\n    this.emit('test end', runnable);\\n    this.hookUp('afterEach', this.next);\\n    return;\\n  }\\n\\n // recover from hooks\\n  if (runnable.type === 'hook') {\\n    var errSuite = this.suite;\\n    // if hook failure is in afterEach block\\n    if (runnable.fullTitle().indexOf('after each') > -1) {\\n      return this.hookErr(err, errSuite, true);\\n    }\\n    // if hook failure is in beforeEach block\\n    if (runnable.fullTitle().indexOf('before each') > -1) {\\n      return this.hookErr(err, errSuite, false);\\n    }\\n    // if hook failure is in after or before blocks\\n    return this.nextSuite(errSuite);\\n  }\\n\\n  // bail\\n  this.emit('end');\\n};\\n\\n/**\\n * Cleans up the references to all the deferred functions\\n * (before/after/beforeEach/afterEach) and tests of a Suite.\\n * These must be deleted otherwise a memory leak can happen,\\n * as those functions may reference variables from closures,\\n * thus those variables can never be garbage collected as long\\n * as the deferred functions exist.\\n *\\n * @param {Suite} suite\\n */\\nfunction cleanSuiteReferences(suite) {\\n  function cleanArrReferences(arr) {\\n    for (var i = 0; i < arr.length; i++) {\\n      delete arr[i].fn;\\n    }\\n  }\\n\\n  if (isArray(suite._beforeAll)) {\\n    cleanArrReferences(suite._beforeAll);\\n  }\\n\\n  if (isArray(suite._beforeEach)) {\\n    cleanArrReferences(suite._beforeEach);\\n  }\\n\\n  if (isArray(suite._afterAll)) {\\n    cleanArrReferences(suite._afterAll);\\n  }\\n\\n  if (isArray(suite._afterEach)) {\\n    cleanArrReferences(suite._afterEach);\\n  }\\n\\n  for (var i = 0; i < suite.tests.length; i++) {\\n    delete suite.tests[i].fn;\\n  }\\n}\\n\\n/**\\n * Run the root suite and invoke `fn(failures)`\\n * on completion.\\n *\\n * @param {Function} fn\\n * @return {Runner} for chaining\\n * @api public\\n * @param {Function} fn\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.run = function(fn) {\\n  var self = this;\\n  var rootSuite = this.suite;\\n\\n  fn = fn || function() {};\\n\\n  function uncaught(err) {\\n    self.uncaught(err);\\n  }\\n\\n  function start() {\\n    self.started = true;\\n    self.emit('start');\\n    self.runSuite(rootSuite, function() {\\n      debug('finished running');\\n      self.emit('end');\\n    });\\n  }\\n\\n  debug('start');\\n\\n  // references cleanup to avoid memory leaks\\n  this.on('suite end', cleanSuiteReferences);\\n\\n  // callback\\n  this.on('end', function() {\\n    debug('end');\\n    process.removeListener('uncaughtException', uncaught);\\n    fn(self.failures);\\n  });\\n\\n  // uncaught exception\\n  process.on('uncaughtException', uncaught);\\n\\n  if (this._delay) {\\n    // for reporters, I guess.\\n    // might be nice to debounce some dots while we wait.\\n    this.emit('waiting', rootSuite);\\n    rootSuite.once('run', start);\\n  } else {\\n    start();\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Cleanly abort execution.\\n *\\n * @api public\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.abort = function() {\\n  debug('aborting');\\n  this._abort = true;\\n\\n  return this;\\n};\\n\\n/**\\n * Filter leaks with the given globals flagged as `ok`.\\n *\\n * @api private\\n * @param {Array} ok\\n * @param {Array} globals\\n * @return {Array}\\n */\\nfunction filterLeaks(ok, globals) {\\n  return filter(globals, function(key) {\\n    // Firefox and Chrome exposes iframes as index inside the window object\\n    if (/^d+/.test(key)) {\\n      return false;\\n    }\\n\\n    // in firefox\\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\\n    // it is assigned in some seconds\\n    if (global.navigator && (/^getInterface/).test(key)) {\\n      return false;\\n    }\\n\\n    // an iframe could be approached by window[iframeIndex]\\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\\n    if (global.navigator && (/^\\\\d+/).test(key)) {\\n      return false;\\n    }\\n\\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\\n    if (/^mocha-/.test(key)) {\\n      return false;\\n    }\\n\\n    var matched = filter(ok, function(ok) {\\n      if (~ok.indexOf('*')) {\\n        return key.indexOf(ok.split('*')[0]) === 0;\\n      }\\n      return key === ok;\\n    });\\n    return !matched.length && (!global.navigator || key !== 'onerror');\\n  });\\n}\\n\\n/**\\n * Array of globals dependent on the environment.\\n *\\n * @return {Array}\\n * @api private\\n */\\nfunction extraGlobals() {\\n  if (typeof process === 'object' && typeof process.version === 'string') {\\n    var parts = process.version.split('.');\\n    var nodeVersion = utils.reduce(parts, function(a, v) {\\n      return a << 8 | v;\\n    });\\n\\n    // 'errno' was renamed to process._errno in v0.9.11.\\n\\n    if (nodeVersion < 0x00090B) {\\n      return ['errno'];\\n    }\\n  }\\n\\n  return [];\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./pending\\\":16,\\\"./runnable\\\":35,\\\"./utils\\\":39,\\\"_process\\\":58,\\\"debug\\\":2,\\\"events\\\":3}],37:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar EventEmitter = require('events').EventEmitter;\\nvar Hook = require('./hook');\\nvar utils = require('./utils');\\nvar inherits = utils.inherits;\\nvar debug = require('debug')('mocha:suite');\\nvar milliseconds = require('./ms');\\n\\n/**\\n * Expose `Suite`.\\n */\\n\\nexports = module.exports = Suite;\\n\\n/**\\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\\n * with the same title is already present, that suite is returned to provide\\n * nicer reporter and more flexible meta-testing.\\n *\\n * @api public\\n * @param {Suite} parent\\n * @param {string} title\\n * @return {Suite}\\n */\\nexports.create = function(parent, title) {\\n  var suite = new Suite(title, parent.ctx);\\n  suite.parent = parent;\\n  title = suite.fullTitle();\\n  parent.addSuite(suite);\\n  return suite;\\n};\\n\\n/**\\n * Initialize a new `Suite` with the given `title` and `ctx`.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Context} parentContext\\n */\\nfunction Suite(title, parentContext) {\\n  this.title = title;\\n  function Context() {}\\n  Context.prototype = parentContext;\\n  this.ctx = new Context();\\n  this.suites = [];\\n  this.tests = [];\\n  this.pending = false;\\n  this._beforeEach = [];\\n  this._beforeAll = [];\\n  this._afterEach = [];\\n  this._afterAll = [];\\n  this.root = !title;\\n  this._timeout = 2000;\\n  this._enableTimeouts = true;\\n  this._slow = 75;\\n  this._bail = false;\\n  this._retries = -1;\\n  this.delayed = false;\\n}\\n\\n/**\\n * Inherit from `EventEmitter.prototype`.\\n */\\ninherits(Suite, EventEmitter);\\n\\n/**\\n * Return a clone of this `Suite`.\\n *\\n * @api private\\n * @return {Suite}\\n */\\nSuite.prototype.clone = function() {\\n  var suite = new Suite(this.title);\\n  debug('clone');\\n  suite.ctx = this.ctx;\\n  suite.timeout(this.timeout());\\n  suite.retries(this.retries());\\n  suite.enableTimeouts(this.enableTimeouts());\\n  suite.slow(this.slow());\\n  suite.bail(this.bail());\\n  return suite;\\n};\\n\\n/**\\n * Set timeout `ms` or short-hand such as \\\"2s\\\".\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.timeout = function(ms) {\\n  if (!arguments.length) {\\n    return this._timeout;\\n  }\\n  if (ms.toString() === '0') {\\n    this._enableTimeouts = false;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('timeout %d', ms);\\n  this._timeout = parseInt(ms, 10);\\n  return this;\\n};\\n\\n/**\\n * Set number of times to retry a failed test.\\n *\\n * @api private\\n * @param {number|string} n\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.retries = function(n) {\\n  if (!arguments.length) {\\n    return this._retries;\\n  }\\n  debug('retries %d', n);\\n  this._retries = parseInt(n, 10) || 0;\\n  return this;\\n};\\n\\n/**\\n  * Set timeout to `enabled`.\\n  *\\n  * @api private\\n  * @param {boolean} enabled\\n  * @return {Suite|boolean} self or enabled\\n  */\\nSuite.prototype.enableTimeouts = function(enabled) {\\n  if (!arguments.length) {\\n    return this._enableTimeouts;\\n  }\\n  debug('enableTimeouts %s', enabled);\\n  this._enableTimeouts = enabled;\\n  return this;\\n};\\n\\n/**\\n * Set slow `ms` or short-hand such as \\\"2s\\\".\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.slow = function(ms) {\\n  if (!arguments.length) {\\n    return this._slow;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('slow %d', ms);\\n  this._slow = ms;\\n  return this;\\n};\\n\\n/**\\n * Sets whether to bail after first error.\\n *\\n * @api private\\n * @param {boolean} bail\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.bail = function(bail) {\\n  if (!arguments.length) {\\n    return this._bail;\\n  }\\n  debug('bail %s', bail);\\n  this._bail = bail;\\n  return this;\\n};\\n\\n/**\\n * Check if this suite or its parent suite is marked as pending.\\n *\\n * @api private\\n */\\nSuite.prototype.isPending = function() {\\n  return this.pending || (this.parent && this.parent.isPending());\\n};\\n\\n/**\\n * Run `fn(test[, done])` before running tests.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.beforeAll = function(title, fn) {\\n  if (this.isPending()) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"before all\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.retries(this.retries());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._beforeAll.push(hook);\\n  this.emit('beforeAll', hook);\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` after running tests.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.afterAll = function(title, fn) {\\n  if (this.isPending()) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"after all\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.retries(this.retries());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._afterAll.push(hook);\\n  this.emit('afterAll', hook);\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` before each test case.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.beforeEach = function(title, fn) {\\n  if (this.isPending()) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"before each\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.retries(this.retries());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._beforeEach.push(hook);\\n  this.emit('beforeEach', hook);\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` after each test case.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.afterEach = function(title, fn) {\\n  if (this.isPending()) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"after each\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.retries(this.retries());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._afterEach.push(hook);\\n  this.emit('afterEach', hook);\\n  return this;\\n};\\n\\n/**\\n * Add a test `suite`.\\n *\\n * @api private\\n * @param {Suite} suite\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.addSuite = function(suite) {\\n  suite.parent = this;\\n  suite.timeout(this.timeout());\\n  suite.retries(this.retries());\\n  suite.enableTimeouts(this.enableTimeouts());\\n  suite.slow(this.slow());\\n  suite.bail(this.bail());\\n  this.suites.push(suite);\\n  this.emit('suite', suite);\\n  return this;\\n};\\n\\n/**\\n * Add a `test` to this suite.\\n *\\n * @api private\\n * @param {Test} test\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.addTest = function(test) {\\n  test.parent = this;\\n  test.timeout(this.timeout());\\n  test.retries(this.retries());\\n  test.enableTimeouts(this.enableTimeouts());\\n  test.slow(this.slow());\\n  test.ctx = this.ctx;\\n  this.tests.push(test);\\n  this.emit('test', test);\\n  return this;\\n};\\n\\n/**\\n * Return the full title generated by recursively concatenating the parent's\\n * full title.\\n *\\n * @api public\\n * @return {string}\\n */\\nSuite.prototype.fullTitle = function() {\\n  if (this.parent) {\\n    var full = this.parent.fullTitle();\\n    if (full) {\\n      return full + ' ' + this.title;\\n    }\\n  }\\n  return this.title;\\n};\\n\\n/**\\n * Return the total number of tests.\\n *\\n * @api public\\n * @return {number}\\n */\\nSuite.prototype.total = function() {\\n  return utils.reduce(this.suites, function(sum, suite) {\\n    return sum + suite.total();\\n  }, 0) + this.tests.length;\\n};\\n\\n/**\\n * Iterates through each suite recursively to find all tests. Applies a\\n * function in the format `fn(test)`.\\n *\\n * @api private\\n * @param {Function} fn\\n * @return {Suite}\\n */\\nSuite.prototype.eachTest = function(fn) {\\n  utils.forEach(this.tests, fn);\\n  utils.forEach(this.suites, function(suite) {\\n    suite.eachTest(fn);\\n  });\\n  return this;\\n};\\n\\n/**\\n * This will run the root suite if we happen to be running in delayed mode.\\n */\\nSuite.prototype.run = function run() {\\n  if (this.root) {\\n    this.emit('run');\\n  }\\n};\\n\\n},{\\\"./hook\\\":7,\\\"./ms\\\":15,\\\"./utils\\\":39,\\\"debug\\\":2,\\\"events\\\":3}],38:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Runnable = require('./runnable');\\nvar inherits = require('./utils').inherits;\\n\\n/**\\n * Expose `Test`.\\n */\\n\\nmodule.exports = Test;\\n\\n/**\\n * Initialize a new `Test` with the given `title` and callback `fn`.\\n *\\n * @api private\\n * @param {String} title\\n * @param {Function} fn\\n */\\nfunction Test(title, fn) {\\n  Runnable.call(this, title, fn);\\n  this.pending = !fn;\\n  this.type = 'test';\\n}\\n\\n/**\\n * Inherit from `Runnable.prototype`.\\n */\\ninherits(Test, Runnable);\\n\\nTest.prototype.clone = function() {\\n  var test = new Test(this.title, this.fn);\\n  test.timeout(this.timeout());\\n  test.slow(this.slow());\\n  test.enableTimeouts(this.enableTimeouts());\\n  test.retries(this.retries());\\n  test.currentRetry(this.currentRetry());\\n  test.globals(this.globals());\\n  test.parent = this.parent;\\n  test.file = this.file;\\n  test.ctx = this.ctx;\\n  return test;\\n};\\n\\n},{\\\"./runnable\\\":35,\\\"./utils\\\":39}],39:[function(require,module,exports){\\n(function (process,Buffer){\\n/* eslint-env browser */\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar basename = require('path').basename;\\nvar debug = require('debug')('mocha:watch');\\nvar exists = require('fs').existsSync || require('path').existsSync;\\nvar glob = require('glob');\\nvar join = require('path').join;\\nvar readdirSync = require('fs').readdirSync;\\nvar statSync = require('fs').statSync;\\nvar watchFile = require('fs').watchFile;\\nvar toISOString = require('to-iso-string');\\n\\n/**\\n * Ignored directories.\\n */\\n\\nvar ignore = ['node_modules', '.git'];\\n\\nexports.inherits = require('util').inherits;\\n\\n/**\\n * Escape special characters in the given string of html.\\n *\\n * @api private\\n * @param  {string} html\\n * @return {string}\\n */\\nexports.escape = function(html) {\\n  return String(html)\\n    .replace(/&/g, '&amp;')\\n    .replace(/\\\"/g, '&quot;')\\n    .replace(/</g, '&lt;')\\n    .replace(/>/g, '&gt;');\\n};\\n\\n/**\\n * Array#forEach (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @param {Object} scope\\n */\\nexports.forEach = function(arr, fn, scope) {\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    fn.call(scope, arr[i], i);\\n  }\\n};\\n\\n/**\\n * Test if the given obj is type of string.\\n *\\n * @api private\\n * @param {Object} obj\\n * @return {boolean}\\n */\\nexports.isString = function(obj) {\\n  return typeof obj === 'string';\\n};\\n\\n/**\\n * Array#map (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @param {Object} scope\\n * @return {Array}\\n */\\nexports.map = function(arr, fn, scope) {\\n  var result = [];\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    result.push(fn.call(scope, arr[i], i, arr));\\n  }\\n  return result;\\n};\\n\\n/**\\n * Array#indexOf (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Object} obj to find index of\\n * @param {number} start\\n * @return {number}\\n */\\nexports.indexOf = function(arr, obj, start) {\\n  for (var i = start || 0, l = arr.length; i < l; i++) {\\n    if (arr[i] === obj) {\\n      return i;\\n    }\\n  }\\n  return -1;\\n};\\n\\n/**\\n * Array#reduce (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @param {Object} val Initial value.\\n * @return {*}\\n */\\nexports.reduce = function(arr, fn, val) {\\n  var rval = val;\\n\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    rval = fn(rval, arr[i], i, arr);\\n  }\\n\\n  return rval;\\n};\\n\\n/**\\n * Array#filter (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @return {Array}\\n */\\nexports.filter = function(arr, fn) {\\n  var ret = [];\\n\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    var val = arr[i];\\n    if (fn(val, i, arr)) {\\n      ret.push(val);\\n    }\\n  }\\n\\n  return ret;\\n};\\n\\n/**\\n * Object.keys (<=IE8)\\n *\\n * @api private\\n * @param {Object} obj\\n * @return {Array} keys\\n */\\nexports.keys = typeof Object.keys === 'function' ? Object.keys : function(obj) {\\n  var keys = [];\\n  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\\n\\n  for (var key in obj) {\\n    if (has.call(obj, key)) {\\n      keys.push(key);\\n    }\\n  }\\n\\n  return keys;\\n};\\n\\n/**\\n * Watch the given `files` for changes\\n * and invoke `fn(file)` on modification.\\n *\\n * @api private\\n * @param {Array} files\\n * @param {Function} fn\\n */\\nexports.watch = function(files, fn) {\\n  var options = { interval: 100 };\\n  files.forEach(function(file) {\\n    debug('file %s', file);\\n    watchFile(file, options, function(curr, prev) {\\n      if (prev.mtime < curr.mtime) {\\n        fn(file);\\n      }\\n    });\\n  });\\n};\\n\\n/**\\n * Array.isArray (<=IE8)\\n *\\n * @api private\\n * @param {Object} obj\\n * @return {Boolean}\\n */\\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\\n  return Object.prototype.toString.call(obj) === '[object Array]';\\n};\\n\\nexports.isArray = isArray;\\n\\n/**\\n * Buffer.prototype.toJSON polyfill.\\n *\\n * @type {Function}\\n */\\nif (typeof Buffer !== 'undefined' && Buffer.prototype) {\\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function() {\\n    return Array.prototype.slice.call(this, 0);\\n  };\\n}\\n\\n/**\\n * Ignored files.\\n *\\n * @api private\\n * @param {string} path\\n * @return {boolean}\\n */\\nfunction ignored(path) {\\n  return !~ignore.indexOf(path);\\n}\\n\\n/**\\n * Lookup files in the given `dir`.\\n *\\n * @api private\\n * @param {string} dir\\n * @param {string[]} [ext=['.js']]\\n * @param {Array} [ret=[]]\\n * @return {Array}\\n */\\nexports.files = function(dir, ext, ret) {\\n  ret = ret || [];\\n  ext = ext || ['js'];\\n\\n  var re = new RegExp('\\\\\\\\.(' + ext.join('|') + ')$');\\n\\n  readdirSync(dir)\\n    .filter(ignored)\\n    .forEach(function(path) {\\n      path = join(dir, path);\\n      if (statSync(path).isDirectory()) {\\n        exports.files(path, ext, ret);\\n      } else if (path.match(re)) {\\n        ret.push(path);\\n      }\\n    });\\n\\n  return ret;\\n};\\n\\n/**\\n * Compute a slug from the given `str`.\\n *\\n * @api private\\n * @param {string} str\\n * @return {string}\\n */\\nexports.slug = function(str) {\\n  return str\\n    .toLowerCase()\\n    .replace(/ +/g, '-')\\n    .replace(/[^-\\\\w]/g, '');\\n};\\n\\n/**\\n * Strip the function definition from `str`, and re-indent for pre whitespace.\\n *\\n * @param {string} str\\n * @return {string}\\n */\\nexports.clean = function(str) {\\n  str = str\\n    .replace(/\\\\r\\\\n?|[\\\\n\\\\u2028\\\\u2029]/g, '\\\\n').replace(/^\\\\uFEFF/, '')\\n    .replace(/^function *\\\\(.*\\\\)\\\\s*\\\\{|\\\\(.*\\\\) *=> *\\\\{?/, '')\\n    .replace(/\\\\s+\\\\}$/, '');\\n\\n  var spaces = str.match(/^\\\\n?( *)/)[1].length;\\n  var tabs = str.match(/^\\\\n?(\\\\t*)/)[1].length;\\n  var re = new RegExp('^\\\\n?' + (tabs ? '\\\\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');\\n\\n  str = str.replace(re, '');\\n\\n  return exports.trim(str);\\n};\\n\\n/**\\n * Trim the given `str`.\\n *\\n * @api private\\n * @param {string} str\\n * @return {string}\\n */\\nexports.trim = function(str) {\\n  return str.replace(/^\\\\s+|\\\\s+$/g, '');\\n};\\n\\n/**\\n * Parse the given `qs`.\\n *\\n * @api private\\n * @param {string} qs\\n * @return {Object}\\n */\\nexports.parseQuery = function(qs) {\\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair) {\\n    var i = pair.indexOf('=');\\n    var key = pair.slice(0, i);\\n    var val = pair.slice(++i);\\n\\n    obj[key] = decodeURIComponent(val);\\n    return obj;\\n  }, {});\\n};\\n\\n/**\\n * Highlight the given string of `js`.\\n *\\n * @api private\\n * @param {string} js\\n * @return {string}\\n */\\nfunction highlight(js) {\\n  return js\\n    .replace(/</g, '&lt;')\\n    .replace(/>/g, '&gt;')\\n    .replace(/\\\\/\\\\/(.*)/gm, '<span class=\\\"comment\\\">//$1</span>')\\n    .replace(/('.*?')/gm, '<span class=\\\"string\\\">$1</span>')\\n    .replace(/(\\\\d+\\\\.\\\\d+)/gm, '<span class=\\\"number\\\">$1</span>')\\n    .replace(/(\\\\d+)/gm, '<span class=\\\"number\\\">$1</span>')\\n    .replace(/\\\\bnew[ \\\\t]+(\\\\w+)/gm, '<span class=\\\"keyword\\\">new</span> <span class=\\\"init\\\">$1</span>')\\n    .replace(/\\\\b(function|new|throw|return|var|if|else)\\\\b/gm, '<span class=\\\"keyword\\\">$1</span>');\\n}\\n\\n/**\\n * Highlight the contents of tag `name`.\\n *\\n * @api private\\n * @param {string} name\\n */\\nexports.highlightTags = function(name) {\\n  var code = document.getElementById('mocha').getElementsByTagName(name);\\n  for (var i = 0, len = code.length; i < len; ++i) {\\n    code[i].innerHTML = highlight(code[i].innerHTML);\\n  }\\n};\\n\\n/**\\n * If a value could have properties, and has none, this function is called,\\n * which returns a string representation of the empty value.\\n *\\n * Functions w/ no properties return `'[Function]'`\\n * Arrays w/ length === 0 return `'[]'`\\n * Objects w/ no properties return `'{}'`\\n * All else: return result of `value.toString()`\\n *\\n * @api private\\n * @param {*} value The value to inspect.\\n * @param {string} [type] The type of the value, if known.\\n * @returns {string}\\n */\\nfunction emptyRepresentation(value, type) {\\n  type = type || exports.type(value);\\n\\n  switch (type) {\\n    case 'function':\\n      return '[Function]';\\n    case 'object':\\n      return '{}';\\n    case 'array':\\n      return '[]';\\n    default:\\n      return value.toString();\\n  }\\n}\\n\\n/**\\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\\n * is.\\n *\\n * @api private\\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\\n * @param {*} value The value to test.\\n * @returns {string}\\n * @example\\n * type({}) // 'object'\\n * type([]) // 'array'\\n * type(1) // 'number'\\n * type(false) // 'boolean'\\n * type(Infinity) // 'number'\\n * type(null) // 'null'\\n * type(new Date()) // 'date'\\n * type(/foo/) // 'regexp'\\n * type('type') // 'string'\\n * type(global) // 'global'\\n */\\nexports.type = function type(value) {\\n  if (value === undefined) {\\n    return 'undefined';\\n  } else if (value === null) {\\n    return 'null';\\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\\n    return 'buffer';\\n  }\\n  return Object.prototype.toString.call(value)\\n    .replace(/^\\\\[.+\\\\s(.+?)\\\\]$/, '$1')\\n    .toLowerCase();\\n};\\n\\n/**\\n * Stringify `value`. Different behavior depending on type of value:\\n *\\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\\n * - If `value` is an *empty* object, function, or array, return result of function\\n *   {@link emptyRepresentation}.\\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\\n *   JSON.stringify().\\n *\\n * @api private\\n * @see exports.type\\n * @param {*} value\\n * @return {string}\\n */\\nexports.stringify = function(value) {\\n  var type = exports.type(value);\\n\\n  if (!~exports.indexOf(['object', 'array', 'function'], type)) {\\n    if (type !== 'buffer') {\\n      return jsonStringify(value);\\n    }\\n    var json = value.toJSON();\\n    // Based on the toJSON result\\n    return jsonStringify(json.data && json.type ? json.data : json, 2)\\n      .replace(/,(\\\\n|$)/g, '$1');\\n  }\\n\\n  for (var prop in value) {\\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\\n      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\\\\n|$)/g, '$1');\\n    }\\n  }\\n\\n  return emptyRepresentation(value, type);\\n};\\n\\n/**\\n * like JSON.stringify but more sense.\\n *\\n * @api private\\n * @param {Object}  object\\n * @param {number=} spaces\\n * @param {number=} depth\\n * @returns {*}\\n */\\nfunction jsonStringify(object, spaces, depth) {\\n  if (typeof spaces === 'undefined') {\\n    // primitive types\\n    return _stringify(object);\\n  }\\n\\n  depth = depth || 1;\\n  var space = spaces * depth;\\n  var str = isArray(object) ? '[' : '{';\\n  var end = isArray(object) ? ']' : '}';\\n  var length = typeof object.length === 'number' ? object.length : exports.keys(object).length;\\n  // `.repeat()` polyfill\\n  function repeat(s, n) {\\n    return new Array(n).join(s);\\n  }\\n\\n  function _stringify(val) {\\n    switch (exports.type(val)) {\\n      case 'null':\\n      case 'undefined':\\n        val = '[' + val + ']';\\n        break;\\n      case 'array':\\n      case 'object':\\n        val = jsonStringify(val, spaces, depth + 1);\\n        break;\\n      case 'boolean':\\n      case 'regexp':\\n      case 'symbol':\\n      case 'number':\\n        val = val === 0 && (1 / val) === -Infinity // `-0`\\n          ? '-0'\\n          : val.toString();\\n        break;\\n      case 'date':\\n        var sDate;\\n        if (isNaN(val.getTime())) { // Invalid date\\n          sDate = val.toString();\\n        } else {\\n          sDate = val.toISOString ? val.toISOString() : toISOString(val);\\n        }\\n        val = '[Date: ' + sDate + ']';\\n        break;\\n      case 'buffer':\\n        var json = val.toJSON();\\n        // Based on the toJSON result\\n        json = json.data && json.type ? json.data : json;\\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\\n        break;\\n      default:\\n        val = (val === '[Function]' || val === '[Circular]')\\n          ? val\\n          : JSON.stringify(val); // string\\n    }\\n    return val;\\n  }\\n\\n  for (var i in object) {\\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\\n      continue; // not my business\\n    }\\n    --length;\\n    str += '\\\\n ' + repeat(' ', space)\\n      + (isArray(object) ? '' : '\\\"' + i + '\\\": ') // key\\n      + _stringify(object[i])                     // value\\n      + (length ? ',' : '');                     // comma\\n  }\\n\\n  return str\\n    // [], {}\\n    + (str.length !== 1 ? '\\\\n' + repeat(' ', --space) + end : end);\\n}\\n\\n/**\\n * Test if a value is a buffer.\\n *\\n * @api private\\n * @param {*} value The value to test.\\n * @return {boolean} True if `value` is a buffer, otherwise false\\n */\\nexports.isBuffer = function(value) {\\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\\n};\\n\\n/**\\n * Return a new Thing that has the keys in sorted order. Recursive.\\n *\\n * If the Thing...\\n * - has already been seen, return string `'[Circular]'`\\n * - is `undefined`, return string `'[undefined]'`\\n * - is `null`, return value `null`\\n * - is some other primitive, return the value\\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\\n *\\n * @api private\\n * @see {@link exports.stringify}\\n * @param {*} value Thing to inspect.  May or may not have properties.\\n * @param {Array} [stack=[]] Stack of seen values\\n * @return {(Object|Array|Function|string|undefined)}\\n */\\nexports.canonicalize = function(value, stack) {\\n  var canonicalizedObj;\\n  /* eslint-disable no-unused-vars */\\n  var prop;\\n  /* eslint-enable no-unused-vars */\\n  var type = exports.type(value);\\n  function withStack(value, fn) {\\n    stack.push(value);\\n    fn();\\n    stack.pop();\\n  }\\n\\n  stack = stack || [];\\n\\n  if (exports.indexOf(stack, value) !== -1) {\\n    return '[Circular]';\\n  }\\n\\n  switch (type) {\\n    case 'undefined':\\n    case 'buffer':\\n    case 'null':\\n      canonicalizedObj = value;\\n      break;\\n    case 'array':\\n      withStack(value, function() {\\n        canonicalizedObj = exports.map(value, function(item) {\\n          return exports.canonicalize(item, stack);\\n        });\\n      });\\n      break;\\n    case 'function':\\n      /* eslint-disable guard-for-in */\\n      for (prop in value) {\\n        canonicalizedObj = {};\\n        break;\\n      }\\n      /* eslint-enable guard-for-in */\\n      if (!canonicalizedObj) {\\n        canonicalizedObj = emptyRepresentation(value, type);\\n        break;\\n      }\\n    /* falls through */\\n    case 'object':\\n      canonicalizedObj = canonicalizedObj || {};\\n      withStack(value, function() {\\n        exports.forEach(exports.keys(value).sort(), function(key) {\\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\\n        });\\n      });\\n      break;\\n    case 'date':\\n    case 'number':\\n    case 'regexp':\\n    case 'boolean':\\n    case 'symbol':\\n      canonicalizedObj = value;\\n      break;\\n    default:\\n      canonicalizedObj = value + '';\\n  }\\n\\n  return canonicalizedObj;\\n};\\n\\n/**\\n * Lookup file names at the given `path`.\\n *\\n * @api public\\n * @param {string} path Base path to start searching from.\\n * @param {string[]} extensions File extensions to look for.\\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\\n * @return {string[]} An array of paths.\\n */\\nexports.lookupFiles = function lookupFiles(path, extensions, recursive) {\\n  var files = [];\\n  var re = new RegExp('\\\\\\\\.(' + extensions.join('|') + ')$');\\n\\n  if (!exists(path)) {\\n    if (exists(path + '.js')) {\\n      path += '.js';\\n    } else {\\n      files = glob.sync(path);\\n      if (!files.length) {\\n        throw new Error(\\\"cannot resolve path (or pattern) '\\\" + path + \\\"'\\\");\\n      }\\n      return files;\\n    }\\n  }\\n\\n  try {\\n    var stat = statSync(path);\\n    if (stat.isFile()) {\\n      return path;\\n    }\\n  } catch (err) {\\n    // ignore error\\n    return;\\n  }\\n\\n  readdirSync(path).forEach(function(file) {\\n    file = join(path, file);\\n    try {\\n      var stat = statSync(file);\\n      if (stat.isDirectory()) {\\n        if (recursive) {\\n          files = files.concat(lookupFiles(file, extensions, recursive));\\n        }\\n        return;\\n      }\\n    } catch (err) {\\n      // ignore error\\n      return;\\n    }\\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {\\n      return;\\n    }\\n    files.push(file);\\n  });\\n\\n  return files;\\n};\\n\\n/**\\n * Generate an undefined error with a message warning the user.\\n *\\n * @return {Error}\\n */\\n\\nexports.undefinedError = function() {\\n  return new Error('Caught undefined error, did you throw without specifying what?');\\n};\\n\\n/**\\n * Generate an undefined error if `err` is not defined.\\n *\\n * @param {Error} err\\n * @return {Error}\\n */\\n\\nexports.getError = function(err) {\\n  return err || exports.undefinedError();\\n};\\n\\n/**\\n * @summary\\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\\n * @description\\n * When invoking this function you get a filter function that get the Error.stack as an input,\\n * and return a prettify output.\\n * (i.e: strip Mocha and internal node functions from stack trace).\\n * @returns {Function}\\n */\\nexports.stackTraceFilter = function() {\\n  // TODO: Replace with `process.browser`\\n  var slash = '/';\\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\\n  var cwd = is.node\\n      ? process.cwd() + slash\\n      : (typeof location === 'undefined' ? window.location : location).href.replace(/\\\\/[^\\\\/]*$/, '/');\\n\\n  function isMochaInternal(line) {\\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash))\\n      || (~line.indexOf('components' + slash + 'mochajs' + slash))\\n      || (~line.indexOf('components' + slash + 'mocha' + slash))\\n      || (~line.indexOf(slash + 'mocha.js'));\\n  }\\n\\n  function isNodeInternal(line) {\\n    return (~line.indexOf('(timers.js:'))\\n      || (~line.indexOf('(events.js:'))\\n      || (~line.indexOf('(node.js:'))\\n      || (~line.indexOf('(module.js:'))\\n      || (~line.indexOf('GeneratorFunctionPrototype.next (native)'))\\n      || false;\\n  }\\n\\n  return function(stack) {\\n    stack = stack.split('\\\\n');\\n\\n    stack = exports.reduce(stack, function(list, line) {\\n      if (isMochaInternal(line)) {\\n        return list;\\n      }\\n\\n      if (is.node && isNodeInternal(line)) {\\n        return list;\\n      }\\n\\n      // Clean up cwd(absolute)\\n      if (/\\\\(?.+:\\\\d+:\\\\d+\\\\)?$/.test(line)) {\\n        line = line.replace(cwd, '');\\n      }\\n\\n      list.push(line);\\n      return list;\\n    }, []);\\n\\n    return stack.join('\\\\n');\\n  };\\n};\\n\\n}).call(this,require('_process'),require(\\\"buffer\\\").Buffer)\\n},{\\\"_process\\\":58,\\\"buffer\\\":45,\\\"debug\\\":2,\\\"fs\\\":43,\\\"glob\\\":43,\\\"path\\\":43,\\\"to-iso-string\\\":72,\\\"util\\\":75}],40:[function(require,module,exports){\\n'use strict'\\n\\nexports.toByteArray = toByteArray\\nexports.fromByteArray = fromByteArray\\n\\nvar lookup = []\\nvar revLookup = []\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\nfunction init () {\\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\n  for (var i = 0, len = code.length; i < len; ++i) {\\n    lookup[i] = code[i]\\n    revLookup[code.charCodeAt(i)] = i\\n  }\\n\\n  revLookup['-'.charCodeAt(0)] = 62\\n  revLookup['_'.charCodeAt(0)] = 63\\n}\\n\\ninit()\\n\\nfunction toByteArray (b64) {\\n  var i, j, l, tmp, placeHolders, arr\\n  var len = b64.length\\n\\n  if (len % 4 > 0) {\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\n  }\\n\\n  // the number of equal signs (place holders)\\n  // if there are two placeholders, than the two characters before it\\n  // represent one byte\\n  // if there is only one, then the three characters before it represent 2 bytes\\n  // this is just a cheap hack to not do indexOf twice\\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\\n\\n  // base64 is 4/3 + up to two characters of the original data\\n  arr = new Arr(len * 3 / 4 - placeHolders)\\n\\n  // if there are placeholders, only get up to the last complete 4 chars\\n  l = placeHolders > 0 ? len - 4 : len\\n\\n  var L = 0\\n\\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\\n    arr[L++] = (tmp >> 16) & 0xFF\\n    arr[L++] = (tmp >> 8) & 0xFF\\n    arr[L++] = tmp & 0xFF\\n  }\\n\\n  if (placeHolders === 2) {\\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n    arr[L++] = tmp & 0xFF\\n  } else if (placeHolders === 1) {\\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n    arr[L++] = (tmp >> 8) & 0xFF\\n    arr[L++] = tmp & 0xFF\\n  }\\n\\n  return arr\\n}\\n\\nfunction tripletToBase64 (num) {\\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\\n}\\n\\nfunction encodeChunk (uint8, start, end) {\\n  var tmp\\n  var output = []\\n  for (var i = start; i < end; i += 3) {\\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\\n    output.push(tripletToBase64(tmp))\\n  }\\n  return output.join('')\\n}\\n\\nfunction fromByteArray (uint8) {\\n  var tmp\\n  var len = uint8.length\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n  var output = ''\\n  var parts = []\\n  var maxChunkLength = 16383 // must be multiple of 3\\n\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\n  }\\n\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\n  if (extraBytes === 1) {\\n    tmp = uint8[len - 1]\\n    output += lookup[tmp >> 2]\\n    output += lookup[(tmp << 4) & 0x3F]\\n    output += '=='\\n  } else if (extraBytes === 2) {\\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\\n    output += lookup[tmp >> 10]\\n    output += lookup[(tmp >> 4) & 0x3F]\\n    output += lookup[(tmp << 2) & 0x3F]\\n    output += '='\\n  }\\n\\n  parts.push(output)\\n\\n  return parts.join('')\\n}\\n\\n},{}],41:[function(require,module,exports){\\n\\n},{}],42:[function(require,module,exports){\\n(function (process){\\nvar WritableStream = require('stream').Writable\\nvar inherits = require('util').inherits\\n\\nmodule.exports = BrowserStdout\\n\\n\\ninherits(BrowserStdout, WritableStream)\\n\\nfunction BrowserStdout(opts) {\\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\\n\\n  opts = opts || {}\\n  WritableStream.call(this, opts)\\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\\n}\\n\\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\\n  var output = chunks.toString ? chunks.toString() : chunks\\n  if (this.label === false) {\\n    console.log(output)\\n  } else {\\n    console.log(this.label+':', output)\\n  }\\n  process.nextTick(cb)\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"_process\\\":58,\\\"stream\\\":59,\\\"util\\\":75}],43:[function(require,module,exports){\\narguments[4][41][0].apply(exports,arguments)\\n},{\\\"dup\\\":41}],44:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar buffer = require('buffer');\\nvar Buffer = buffer.Buffer;\\nvar SlowBuffer = buffer.SlowBuffer;\\nvar MAX_LEN = buffer.kMaxLength || 2147483647;\\nexports.alloc = function alloc(size, fill, encoding) {\\n  if (typeof Buffer.alloc === 'function') {\\n    return Buffer.alloc(size, fill, encoding);\\n  }\\n  if (typeof encoding === 'number') {\\n    throw new TypeError('encoding must not be number');\\n  }\\n  if (typeof size !== 'number') {\\n    throw new TypeError('size must be a number');\\n  }\\n  if (size > MAX_LEN) {\\n    throw new RangeError('size is too large');\\n  }\\n  var enc = encoding;\\n  var _fill = fill;\\n  if (_fill === undefined) {\\n    enc = undefined;\\n    _fill = 0;\\n  }\\n  var buf = new Buffer(size);\\n  if (typeof _fill === 'string') {\\n    var fillBuf = new Buffer(_fill, enc);\\n    var flen = fillBuf.length;\\n    var i = -1;\\n    while (++i < size) {\\n      buf[i] = fillBuf[i % flen];\\n    }\\n  } else {\\n    buf.fill(_fill);\\n  }\\n  return buf;\\n}\\nexports.allocUnsafe = function allocUnsafe(size) {\\n  if (typeof Buffer.allocUnsafe === 'function') {\\n    return Buffer.allocUnsafe(size);\\n  }\\n  if (typeof size !== 'number') {\\n    throw new TypeError('size must be a number');\\n  }\\n  if (size > MAX_LEN) {\\n    throw new RangeError('size is too large');\\n  }\\n  return new Buffer(size);\\n}\\nexports.from = function from(value, encodingOrOffset, length) {\\n  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {\\n    return Buffer.from(value, encodingOrOffset, length);\\n  }\\n  if (typeof value === 'number') {\\n    throw new TypeError('\\\"value\\\" argument must not be a number');\\n  }\\n  if (typeof value === 'string') {\\n    return new Buffer(value, encodingOrOffset);\\n  }\\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\\n    var offset = encodingOrOffset;\\n    if (arguments.length === 1) {\\n      return new Buffer(value);\\n    }\\n    if (typeof offset === 'undefined') {\\n      offset = 0;\\n    }\\n    var len = length;\\n    if (typeof len === 'undefined') {\\n      len = value.byteLength - offset;\\n    }\\n    if (offset >= value.byteLength) {\\n      throw new RangeError('\\\\'offset\\\\' is out of bounds');\\n    }\\n    if (len > value.byteLength - offset) {\\n      throw new RangeError('\\\\'length\\\\' is out of bounds');\\n    }\\n    return new Buffer(value.slice(offset, offset + len));\\n  }\\n  if (Buffer.isBuffer(value)) {\\n    var out = new Buffer(value.length);\\n    value.copy(out, 0, 0, value.length);\\n    return out;\\n  }\\n  if (value) {\\n    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {\\n      return new Buffer(value);\\n    }\\n    if (value.type === 'Buffer' && Array.isArray(value.data)) {\\n      return new Buffer(value.data);\\n    }\\n  }\\n\\n  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');\\n}\\nexports.allocUnsafeSlow = function allocUnsafeSlow(size) {\\n  if (typeof Buffer.allocUnsafeSlow === 'function') {\\n    return Buffer.allocUnsafeSlow(size);\\n  }\\n  if (typeof size !== 'number') {\\n    throw new TypeError('size must be a number');\\n  }\\n  if (size >= MAX_LEN) {\\n    throw new RangeError('size is too large');\\n  }\\n  return new SlowBuffer(size);\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"buffer\\\":45}],45:[function(require,module,exports){\\n(function (global){\\n/*!\\n * The buffer module from node.js, for the browser.\\n *\\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\\n * @license  MIT\\n */\\n/* eslint-disable no-proto */\\n\\n'use strict'\\n\\nvar base64 = require('base64-js')\\nvar ieee754 = require('ieee754')\\nvar isArray = require('isarray')\\n\\nexports.Buffer = Buffer\\nexports.SlowBuffer = SlowBuffer\\nexports.INSPECT_MAX_BYTES = 50\\n\\n/**\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\n *   === true    Use Uint8Array implementation (fastest)\\n *   === false   Use Object implementation (most compatible, even IE6)\\n *\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\n * Opera 11.6+, iOS 4.2+.\\n *\\n * Due to various browser bugs, sometimes the Object implementation will be used even\\n * when the browser supports typed arrays.\\n *\\n * Note:\\n *\\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\\n *\\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\\n *\\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\\n *     incorrect length in some situations.\\n\\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\\n * get the Object implementation, which is slower but behaves correctly.\\n */\\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\\n  ? global.TYPED_ARRAY_SUPPORT\\n  : typedArraySupport()\\n\\n/*\\n * Export kMaxLength after typed array support is determined.\\n */\\nexports.kMaxLength = kMaxLength()\\n\\nfunction typedArraySupport () {\\n  try {\\n    var arr = new Uint8Array(1)\\n    arr.foo = function () { return 42 }\\n    return arr.foo() === 42 && // typed array instances can be augmented\\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\\n  } catch (e) {\\n    return false\\n  }\\n}\\n\\nfunction kMaxLength () {\\n  return Buffer.TYPED_ARRAY_SUPPORT\\n    ? 0x7fffffff\\n    : 0x3fffffff\\n}\\n\\nfunction createBuffer (that, length) {\\n  if (kMaxLength() < length) {\\n    throw new RangeError('Invalid typed array length')\\n  }\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    // Return an augmented `Uint8Array` instance, for best performance\\n    that = new Uint8Array(length)\\n    that.__proto__ = Buffer.prototype\\n  } else {\\n    // Fallback: Return an object instance of the Buffer class\\n    if (that === null) {\\n      that = new Buffer(length)\\n    }\\n    that.length = length\\n  }\\n\\n  return that\\n}\\n\\n/**\\n * The Buffer constructor returns instances of `Uint8Array` that have their\\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\\n * returns a single octet.\\n *\\n * The `Uint8Array` prototype remains unmodified.\\n */\\n\\nfunction Buffer (arg, encodingOrOffset, length) {\\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\\n    return new Buffer(arg, encodingOrOffset, length)\\n  }\\n\\n  // Common case.\\n  if (typeof arg === 'number') {\\n    if (typeof encodingOrOffset === 'string') {\\n      throw new Error(\\n        'If encoding is specified then the first argument must be a string'\\n      )\\n    }\\n    return allocUnsafe(this, arg)\\n  }\\n  return from(this, arg, encodingOrOffset, length)\\n}\\n\\nBuffer.poolSize = 8192 // not used by this implementation\\n\\n// TODO: Legacy, not needed anymore. Remove in next major version.\\nBuffer._augment = function (arr) {\\n  arr.__proto__ = Buffer.prototype\\n  return arr\\n}\\n\\nfunction from (that, value, encodingOrOffset, length) {\\n  if (typeof value === 'number') {\\n    throw new TypeError('\\\"value\\\" argument must not be a number')\\n  }\\n\\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\\n  }\\n\\n  if (typeof value === 'string') {\\n    return fromString(that, value, encodingOrOffset)\\n  }\\n\\n  return fromObject(that, value)\\n}\\n\\n/**\\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\\n * if value is a number.\\n * Buffer.from(str[, encoding])\\n * Buffer.from(array)\\n * Buffer.from(buffer)\\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\\n **/\\nBuffer.from = function (value, encodingOrOffset, length) {\\n  return from(null, value, encodingOrOffset, length)\\n}\\n\\nif (Buffer.TYPED_ARRAY_SUPPORT) {\\n  Buffer.prototype.__proto__ = Uint8Array.prototype\\n  Buffer.__proto__ = Uint8Array\\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\\n      Buffer[Symbol.species] === Buffer) {\\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\\n    Object.defineProperty(Buffer, Symbol.species, {\\n      value: null,\\n      configurable: true\\n    })\\n  }\\n}\\n\\nfunction assertSize (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('\\\"size\\\" argument must be a number')\\n  }\\n}\\n\\nfunction alloc (that, size, fill, encoding) {\\n  assertSize(size)\\n  if (size <= 0) {\\n    return createBuffer(that, size)\\n  }\\n  if (fill !== undefined) {\\n    // Only pay attention to encoding if it's a string. This\\n    // prevents accidentally sending in a number that would\\n    // be interpretted as a start offset.\\n    return typeof encoding === 'string'\\n      ? createBuffer(that, size).fill(fill, encoding)\\n      : createBuffer(that, size).fill(fill)\\n  }\\n  return createBuffer(that, size)\\n}\\n\\n/**\\n * Creates a new filled Buffer instance.\\n * alloc(size[, fill[, encoding]])\\n **/\\nBuffer.alloc = function (size, fill, encoding) {\\n  return alloc(null, size, fill, encoding)\\n}\\n\\nfunction allocUnsafe (that, size) {\\n  assertSize(size)\\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\\n    for (var i = 0; i < size; i++) {\\n      that[i] = 0\\n    }\\n  }\\n  return that\\n}\\n\\n/**\\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\\n * */\\nBuffer.allocUnsafe = function (size) {\\n  return allocUnsafe(null, size)\\n}\\n/**\\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\\n */\\nBuffer.allocUnsafeSlow = function (size) {\\n  return allocUnsafe(null, size)\\n}\\n\\nfunction fromString (that, string, encoding) {\\n  if (typeof encoding !== 'string' || encoding === '') {\\n    encoding = 'utf8'\\n  }\\n\\n  if (!Buffer.isEncoding(encoding)) {\\n    throw new TypeError('\\\"encoding\\\" must be a valid string encoding')\\n  }\\n\\n  var length = byteLength(string, encoding) | 0\\n  that = createBuffer(that, length)\\n\\n  that.write(string, encoding)\\n  return that\\n}\\n\\nfunction fromArrayLike (that, array) {\\n  var length = checked(array.length) | 0\\n  that = createBuffer(that, length)\\n  for (var i = 0; i < length; i += 1) {\\n    that[i] = array[i] & 255\\n  }\\n  return that\\n}\\n\\nfunction fromArrayBuffer (that, array, byteOffset, length) {\\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\\n\\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\\n    throw new RangeError('\\\\'offset\\\\' is out of bounds')\\n  }\\n\\n  if (array.byteLength < byteOffset + (length || 0)) {\\n    throw new RangeError('\\\\'length\\\\' is out of bounds')\\n  }\\n\\n  if (length === undefined) {\\n    array = new Uint8Array(array, byteOffset)\\n  } else {\\n    array = new Uint8Array(array, byteOffset, length)\\n  }\\n\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    // Return an augmented `Uint8Array` instance, for best performance\\n    that = array\\n    that.__proto__ = Buffer.prototype\\n  } else {\\n    // Fallback: Return an object instance of the Buffer class\\n    that = fromArrayLike(that, array)\\n  }\\n  return that\\n}\\n\\nfunction fromObject (that, obj) {\\n  if (Buffer.isBuffer(obj)) {\\n    var len = checked(obj.length) | 0\\n    that = createBuffer(that, len)\\n\\n    if (that.length === 0) {\\n      return that\\n    }\\n\\n    obj.copy(that, 0, 0, len)\\n    return that\\n  }\\n\\n  if (obj) {\\n    if ((typeof ArrayBuffer !== 'undefined' &&\\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\\n        return createBuffer(that, 0)\\n      }\\n      return fromArrayLike(that, obj)\\n    }\\n\\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\\n      return fromArrayLike(that, obj.data)\\n    }\\n  }\\n\\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\\n}\\n\\nfunction checked (length) {\\n  // Note: cannot use `length < kMaxLength` here because that fails when\\n  // length is NaN (which is otherwise coerced to zero.)\\n  if (length >= kMaxLength()) {\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\\n  }\\n  return length | 0\\n}\\n\\nfunction SlowBuffer (length) {\\n  if (+length != length) { // eslint-disable-line eqeqeq\\n    length = 0\\n  }\\n  return Buffer.alloc(+length)\\n}\\n\\nBuffer.isBuffer = function isBuffer (b) {\\n  return !!(b != null && b._isBuffer)\\n}\\n\\nBuffer.compare = function compare (a, b) {\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\n    throw new TypeError('Arguments must be Buffers')\\n  }\\n\\n  if (a === b) return 0\\n\\n  var x = a.length\\n  var y = b.length\\n\\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\\n    if (a[i] !== b[i]) {\\n      x = a[i]\\n      y = b[i]\\n      break\\n    }\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\nBuffer.isEncoding = function isEncoding (encoding) {\\n  switch (String(encoding).toLowerCase()) {\\n    case 'hex':\\n    case 'utf8':\\n    case 'utf-8':\\n    case 'ascii':\\n    case 'binary':\\n    case 'base64':\\n    case 'raw':\\n    case 'ucs2':\\n    case 'ucs-2':\\n    case 'utf16le':\\n    case 'utf-16le':\\n      return true\\n    default:\\n      return false\\n  }\\n}\\n\\nBuffer.concat = function concat (list, length) {\\n  if (!isArray(list)) {\\n    throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\n  }\\n\\n  if (list.length === 0) {\\n    return Buffer.alloc(0)\\n  }\\n\\n  var i\\n  if (length === undefined) {\\n    length = 0\\n    for (i = 0; i < list.length; i++) {\\n      length += list[i].length\\n    }\\n  }\\n\\n  var buffer = Buffer.allocUnsafe(length)\\n  var pos = 0\\n  for (i = 0; i < list.length; i++) {\\n    var buf = list[i]\\n    if (!Buffer.isBuffer(buf)) {\\n      throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\n    }\\n    buf.copy(buffer, pos)\\n    pos += buf.length\\n  }\\n  return buffer\\n}\\n\\nfunction byteLength (string, encoding) {\\n  if (Buffer.isBuffer(string)) {\\n    return string.length\\n  }\\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\\n    return string.byteLength\\n  }\\n  if (typeof string !== 'string') {\\n    string = '' + string\\n  }\\n\\n  var len = string.length\\n  if (len === 0) return 0\\n\\n  // Use a for loop to avoid recursion\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'ascii':\\n      case 'binary':\\n      // Deprecated\\n      case 'raw':\\n      case 'raws':\\n        return len\\n      case 'utf8':\\n      case 'utf-8':\\n      case undefined:\\n        return utf8ToBytes(string).length\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return len * 2\\n      case 'hex':\\n        return len >>> 1\\n      case 'base64':\\n        return base64ToBytes(string).length\\n      default:\\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\nBuffer.byteLength = byteLength\\n\\nfunction slowToString (encoding, start, end) {\\n  var loweredCase = false\\n\\n  // No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\n  // property of a typed array.\\n\\n  // This behaves neither like String nor Uint8Array in that we set start/end\\n  // to their upper/lower bounds if the value passed is out of range.\\n  // undefined is handled specially as per ECMA-262 6th Edition,\\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\n  if (start === undefined || start < 0) {\\n    start = 0\\n  }\\n  // Return early if start > this.length. Done here to prevent potential uint32\\n  // coercion fail below.\\n  if (start > this.length) {\\n    return ''\\n  }\\n\\n  if (end === undefined || end > this.length) {\\n    end = this.length\\n  }\\n\\n  if (end <= 0) {\\n    return ''\\n  }\\n\\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\n  end >>>= 0\\n  start >>>= 0\\n\\n  if (end <= start) {\\n    return ''\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  while (true) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexSlice(this, start, end)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Slice(this, start, end)\\n\\n      case 'ascii':\\n        return asciiSlice(this, start, end)\\n\\n      case 'binary':\\n        return binarySlice(this, start, end)\\n\\n      case 'base64':\\n        return base64Slice(this, start, end)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return utf16leSlice(this, start, end)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = (encoding + '').toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\\n// Buffer instances.\\nBuffer.prototype._isBuffer = true\\n\\nfunction swap (b, n, m) {\\n  var i = b[n]\\n  b[n] = b[m]\\n  b[m] = i\\n}\\n\\nBuffer.prototype.swap16 = function swap16 () {\\n  var len = this.length\\n  if (len % 2 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\\n  }\\n  for (var i = 0; i < len; i += 2) {\\n    swap(this, i, i + 1)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.swap32 = function swap32 () {\\n  var len = this.length\\n  if (len % 4 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\\n  }\\n  for (var i = 0; i < len; i += 4) {\\n    swap(this, i, i + 3)\\n    swap(this, i + 1, i + 2)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.toString = function toString () {\\n  var length = this.length | 0\\n  if (length === 0) return ''\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\n  return slowToString.apply(this, arguments)\\n}\\n\\nBuffer.prototype.equals = function equals (b) {\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\n  if (this === b) return true\\n  return Buffer.compare(this, b) === 0\\n}\\n\\nBuffer.prototype.inspect = function inspect () {\\n  var str = ''\\n  var max = exports.INSPECT_MAX_BYTES\\n  if (this.length > 0) {\\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\\n    if (this.length > max) str += ' ... '\\n  }\\n  return '<Buffer ' + str + '>'\\n}\\n\\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\\n  if (!Buffer.isBuffer(target)) {\\n    throw new TypeError('Argument must be a Buffer')\\n  }\\n\\n  if (start === undefined) {\\n    start = 0\\n  }\\n  if (end === undefined) {\\n    end = target ? target.length : 0\\n  }\\n  if (thisStart === undefined) {\\n    thisStart = 0\\n  }\\n  if (thisEnd === undefined) {\\n    thisEnd = this.length\\n  }\\n\\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\n    throw new RangeError('out of range index')\\n  }\\n\\n  if (thisStart >= thisEnd && start >= end) {\\n    return 0\\n  }\\n  if (thisStart >= thisEnd) {\\n    return -1\\n  }\\n  if (start >= end) {\\n    return 1\\n  }\\n\\n  start >>>= 0\\n  end >>>= 0\\n  thisStart >>>= 0\\n  thisEnd >>>= 0\\n\\n  if (this === target) return 0\\n\\n  var x = thisEnd - thisStart\\n  var y = end - start\\n  var len = Math.min(x, y)\\n\\n  var thisCopy = this.slice(thisStart, thisEnd)\\n  var targetCopy = target.slice(start, end)\\n\\n  for (var i = 0; i < len; ++i) {\\n    if (thisCopy[i] !== targetCopy[i]) {\\n      x = thisCopy[i]\\n      y = targetCopy[i]\\n      break\\n    }\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\nfunction arrayIndexOf (arr, val, byteOffset, encoding) {\\n  var indexSize = 1\\n  var arrLength = arr.length\\n  var valLength = val.length\\n\\n  if (encoding !== undefined) {\\n    encoding = String(encoding).toLowerCase()\\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\\n        encoding === 'utf16le' || encoding === 'utf-16le') {\\n      if (arr.length < 2 || val.length < 2) {\\n        return -1\\n      }\\n      indexSize = 2\\n      arrLength /= 2\\n      valLength /= 2\\n      byteOffset /= 2\\n    }\\n  }\\n\\n  function read (buf, i) {\\n    if (indexSize === 1) {\\n      return buf[i]\\n    } else {\\n      return buf.readUInt16BE(i * indexSize)\\n    }\\n  }\\n\\n  var foundIndex = -1\\n  for (var i = 0; byteOffset + i < arrLength; i++) {\\n    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\n      if (foundIndex === -1) foundIndex = i\\n      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize\\n    } else {\\n      if (foundIndex !== -1) i -= i - foundIndex\\n      foundIndex = -1\\n    }\\n  }\\n  return -1\\n}\\n\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\\n  if (typeof byteOffset === 'string') {\\n    encoding = byteOffset\\n    byteOffset = 0\\n  } else if (byteOffset > 0x7fffffff) {\\n    byteOffset = 0x7fffffff\\n  } else if (byteOffset < -0x80000000) {\\n    byteOffset = -0x80000000\\n  }\\n  byteOffset >>= 0\\n\\n  if (this.length === 0) return -1\\n  if (byteOffset >= this.length) return -1\\n\\n  // Negative offsets start from the end of the buffer\\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\\n\\n  if (typeof val === 'string') {\\n    val = Buffer.from(val, encoding)\\n  }\\n\\n  if (Buffer.isBuffer(val)) {\\n    // special case: looking for empty string/buffer always fails\\n    if (val.length === 0) {\\n      return -1\\n    }\\n    return arrayIndexOf(this, val, byteOffset, encoding)\\n  }\\n  if (typeof val === 'number') {\\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\\n    }\\n    return arrayIndexOf(this, [ val ], byteOffset, encoding)\\n  }\\n\\n  throw new TypeError('val must be string, number or Buffer')\\n}\\n\\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\\n  return this.indexOf(val, byteOffset, encoding) !== -1\\n}\\n\\nfunction hexWrite (buf, string, offset, length) {\\n  offset = Number(offset) || 0\\n  var remaining = buf.length - offset\\n  if (!length) {\\n    length = remaining\\n  } else {\\n    length = Number(length)\\n    if (length > remaining) {\\n      length = remaining\\n    }\\n  }\\n\\n  // must be an even number of digits\\n  var strLen = string.length\\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\\n\\n  if (length > strLen / 2) {\\n    length = strLen / 2\\n  }\\n  for (var i = 0; i < length; i++) {\\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\\n    if (isNaN(parsed)) return i\\n    buf[offset + i] = parsed\\n  }\\n  return i\\n}\\n\\nfunction utf8Write (buf, string, offset, length) {\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nfunction asciiWrite (buf, string, offset, length) {\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\n}\\n\\nfunction binaryWrite (buf, string, offset, length) {\\n  return asciiWrite(buf, string, offset, length)\\n}\\n\\nfunction base64Write (buf, string, offset, length) {\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\n}\\n\\nfunction ucs2Write (buf, string, offset, length) {\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\n  // Buffer#write(string)\\n  if (offset === undefined) {\\n    encoding = 'utf8'\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, encoding)\\n  } else if (length === undefined && typeof offset === 'string') {\\n    encoding = offset\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, offset[, length][, encoding])\\n  } else if (isFinite(offset)) {\\n    offset = offset | 0\\n    if (isFinite(length)) {\\n      length = length | 0\\n      if (encoding === undefined) encoding = 'utf8'\\n    } else {\\n      encoding = length\\n      length = undefined\\n    }\\n  // legacy write(string, encoding, offset, length) - remove in v0.13\\n  } else {\\n    throw new Error(\\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\\n    )\\n  }\\n\\n  var remaining = this.length - offset\\n  if (length === undefined || length > remaining) length = remaining\\n\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\n    throw new RangeError('Attempt to write outside buffer bounds')\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexWrite(this, string, offset, length)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Write(this, string, offset, length)\\n\\n      case 'ascii':\\n        return asciiWrite(this, string, offset, length)\\n\\n      case 'binary':\\n        return binaryWrite(this, string, offset, length)\\n\\n      case 'base64':\\n        // Warning: maxLength not taken into account in base64Write\\n        return base64Write(this, string, offset, length)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return ucs2Write(this, string, offset, length)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\nBuffer.prototype.toJSON = function toJSON () {\\n  return {\\n    type: 'Buffer',\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\n  }\\n}\\n\\nfunction base64Slice (buf, start, end) {\\n  if (start === 0 && end === buf.length) {\\n    return base64.fromByteArray(buf)\\n  } else {\\n    return base64.fromByteArray(buf.slice(start, end))\\n  }\\n}\\n\\nfunction utf8Slice (buf, start, end) {\\n  end = Math.min(buf.length, end)\\n  var res = []\\n\\n  var i = start\\n  while (i < end) {\\n    var firstByte = buf[i]\\n    var codePoint = null\\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\\n      : (firstByte > 0xDF) ? 3\\n      : (firstByte > 0xBF) ? 2\\n      : 1\\n\\n    if (i + bytesPerSequence <= end) {\\n      var secondByte, thirdByte, fourthByte, tempCodePoint\\n\\n      switch (bytesPerSequence) {\\n        case 1:\\n          if (firstByte < 0x80) {\\n            codePoint = firstByte\\n          }\\n          break\\n        case 2:\\n          secondByte = buf[i + 1]\\n          if ((secondByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\n            if (tempCodePoint > 0x7F) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 3:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 4:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          fourthByte = buf[i + 3]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n      }\\n    }\\n\\n    if (codePoint === null) {\\n      // we did not generate a valid codePoint so insert a\\n      // replacement char (U+FFFD) and advance only 1 byte\\n      codePoint = 0xFFFD\\n      bytesPerSequence = 1\\n    } else if (codePoint > 0xFFFF) {\\n      // encode to utf16 (surrogate pair dance)\\n      codePoint -= 0x10000\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\n    }\\n\\n    res.push(codePoint)\\n    i += bytesPerSequence\\n  }\\n\\n  return decodeCodePointsArray(res)\\n}\\n\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\n// the lowest limit is Chrome, with 0x10000 args.\\n// We go 1 magnitude less, for safety\\nvar MAX_ARGUMENTS_LENGTH = 0x1000\\n\\nfunction decodeCodePointsArray (codePoints) {\\n  var len = codePoints.length\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\n  }\\n\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\n  var res = ''\\n  var i = 0\\n  while (i < len) {\\n    res += String.fromCharCode.apply(\\n      String,\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\n    )\\n  }\\n  return res\\n}\\n\\nfunction asciiSlice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; i++) {\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\n  }\\n  return ret\\n}\\n\\nfunction binarySlice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; i++) {\\n    ret += String.fromCharCode(buf[i])\\n  }\\n  return ret\\n}\\n\\nfunction hexSlice (buf, start, end) {\\n  var len = buf.length\\n\\n  if (!start || start < 0) start = 0\\n  if (!end || end < 0 || end > len) end = len\\n\\n  var out = ''\\n  for (var i = start; i < end; i++) {\\n    out += toHex(buf[i])\\n  }\\n  return out\\n}\\n\\nfunction utf16leSlice (buf, start, end) {\\n  var bytes = buf.slice(start, end)\\n  var res = ''\\n  for (var i = 0; i < bytes.length; i += 2) {\\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\\n  }\\n  return res\\n}\\n\\nBuffer.prototype.slice = function slice (start, end) {\\n  var len = this.length\\n  start = ~~start\\n  end = end === undefined ? len : ~~end\\n\\n  if (start < 0) {\\n    start += len\\n    if (start < 0) start = 0\\n  } else if (start > len) {\\n    start = len\\n  }\\n\\n  if (end < 0) {\\n    end += len\\n    if (end < 0) end = 0\\n  } else if (end > len) {\\n    end = len\\n  }\\n\\n  if (end < start) end = start\\n\\n  var newBuf\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    newBuf = this.subarray(start, end)\\n    newBuf.__proto__ = Buffer.prototype\\n  } else {\\n    var sliceLen = end - start\\n    newBuf = new Buffer(sliceLen, undefined)\\n    for (var i = 0; i < sliceLen; i++) {\\n      newBuf[i] = this[i + start]\\n    }\\n  }\\n\\n  return newBuf\\n}\\n\\n/*\\n * Need to make sure that buffer isn't trying to write out of bounds.\\n */\\nfunction checkOffset (offset, ext, length) {\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\n}\\n\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    checkOffset(offset, byteLength, this.length)\\n  }\\n\\n  var val = this[offset + --byteLength]\\n  var mul = 1\\n  while (byteLength > 0 && (mul *= 0x100)) {\\n    val += this[offset + --byteLength] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  return this[offset]\\n}\\n\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return this[offset] | (this[offset + 1] << 8)\\n}\\n\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return (this[offset] << 8) | this[offset + 1]\\n}\\n\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return ((this[offset]) |\\n      (this[offset + 1] << 8) |\\n      (this[offset + 2] << 16)) +\\n      (this[offset + 3] * 0x1000000)\\n}\\n\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] * 0x1000000) +\\n    ((this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    this[offset + 3])\\n}\\n\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var i = byteLength\\n  var mul = 1\\n  var val = this[offset + --i]\\n  while (i > 0 && (mul *= 0x100)) {\\n    val += this[offset + --i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  if (!(this[offset] & 0x80)) return (this[offset])\\n  return ((0xff - this[offset] + 1) * -1)\\n}\\n\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset] | (this[offset + 1] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset + 1] | (this[offset] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset]) |\\n    (this[offset + 1] << 8) |\\n    (this[offset + 2] << 16) |\\n    (this[offset + 3] << 24)\\n}\\n\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] << 24) |\\n    (this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    (this[offset + 3])\\n}\\n\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, true, 23, 4)\\n}\\n\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, false, 23, 4)\\n}\\n\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, true, 52, 8)\\n}\\n\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, false, 52, 8)\\n}\\n\\nfunction checkInt (buf, value, offset, ext, max, min) {\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance')\\n  if (value > max || value < min) throw new RangeError('\\\"value\\\" argument is out of bounds')\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\n}\\n\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\n  }\\n\\n  var mul = 1\\n  var i = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\\n  this[offset] = (value & 0xff)\\n  return offset + 1\\n}\\n\\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\\n  if (value < 0) value = 0xffff + value + 1\\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\\n      (littleEndian ? i : 1 - i) * 8\\n  }\\n}\\n\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value & 0xff)\\n    this[offset + 1] = (value >>> 8)\\n  } else {\\n    objectWriteUInt16(this, value, offset, true)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 8)\\n    this[offset + 1] = (value & 0xff)\\n  } else {\\n    objectWriteUInt16(this, value, offset, false)\\n  }\\n  return offset + 2\\n}\\n\\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\\n  if (value < 0) value = 0xffffffff + value + 1\\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\\n  }\\n}\\n\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset + 3] = (value >>> 24)\\n    this[offset + 2] = (value >>> 16)\\n    this[offset + 1] = (value >>> 8)\\n    this[offset] = (value & 0xff)\\n  } else {\\n    objectWriteUInt32(this, value, offset, true)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 24)\\n    this[offset + 1] = (value >>> 16)\\n    this[offset + 2] = (value >>> 8)\\n    this[offset + 3] = (value & 0xff)\\n  } else {\\n    objectWriteUInt32(this, value, offset, false)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, 8 * byteLength - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = 0\\n  var mul = 1\\n  var sub = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\n      sub = 1\\n    }\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, 8 * byteLength - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  var sub = 0\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\n      sub = 1\\n    }\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\\n  if (value < 0) value = 0xff + value + 1\\n  this[offset] = (value & 0xff)\\n  return offset + 1\\n}\\n\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value & 0xff)\\n    this[offset + 1] = (value >>> 8)\\n  } else {\\n    objectWriteUInt16(this, value, offset, true)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 8)\\n    this[offset + 1] = (value & 0xff)\\n  } else {\\n    objectWriteUInt16(this, value, offset, false)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value & 0xff)\\n    this[offset + 1] = (value >>> 8)\\n    this[offset + 2] = (value >>> 16)\\n    this[offset + 3] = (value >>> 24)\\n  } else {\\n    objectWriteUInt32(this, value, offset, true)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (value < 0) value = 0xffffffff + value + 1\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 24)\\n    this[offset + 1] = (value >>> 16)\\n    this[offset + 2] = (value >>> 8)\\n    this[offset + 3] = (value & 0xff)\\n  } else {\\n    objectWriteUInt32(this, value, offset, false)\\n  }\\n  return offset + 4\\n}\\n\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\n  if (offset < 0) throw new RangeError('Index out of range')\\n}\\n\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, false, noAssert)\\n}\\n\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\n  return offset + 8\\n}\\n\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, false, noAssert)\\n}\\n\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\n  if (!start) start = 0\\n  if (!end && end !== 0) end = this.length\\n  if (targetStart >= target.length) targetStart = target.length\\n  if (!targetStart) targetStart = 0\\n  if (end > 0 && end < start) end = start\\n\\n  // Copy 0 bytes; we're done\\n  if (end === start) return 0\\n  if (target.length === 0 || this.length === 0) return 0\\n\\n  // Fatal error conditions\\n  if (targetStart < 0) {\\n    throw new RangeError('targetStart out of bounds')\\n  }\\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\n\\n  // Are we oob?\\n  if (end > this.length) end = this.length\\n  if (target.length - targetStart < end - start) {\\n    end = target.length - targetStart + start\\n  }\\n\\n  var len = end - start\\n  var i\\n\\n  if (this === target && start < targetStart && targetStart < end) {\\n    // descending copy from end\\n    for (i = len - 1; i >= 0; i--) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\\n    // ascending copy from start\\n    for (i = 0; i < len; i++) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else {\\n    Uint8Array.prototype.set.call(\\n      target,\\n      this.subarray(start, start + len),\\n      targetStart\\n    )\\n  }\\n\\n  return len\\n}\\n\\n// Usage:\\n//    buffer.fill(number[, offset[, end]])\\n//    buffer.fill(buffer[, offset[, end]])\\n//    buffer.fill(string[, offset[, end]][, encoding])\\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\\n  // Handle string cases:\\n  if (typeof val === 'string') {\\n    if (typeof start === 'string') {\\n      encoding = start\\n      start = 0\\n      end = this.length\\n    } else if (typeof end === 'string') {\\n      encoding = end\\n      end = this.length\\n    }\\n    if (val.length === 1) {\\n      var code = val.charCodeAt(0)\\n      if (code < 256) {\\n        val = code\\n      }\\n    }\\n    if (encoding !== undefined && typeof encoding !== 'string') {\\n      throw new TypeError('encoding must be a string')\\n    }\\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\\n      throw new TypeError('Unknown encoding: ' + encoding)\\n    }\\n  } else if (typeof val === 'number') {\\n    val = val & 255\\n  }\\n\\n  // Invalid ranges are not set to a default, so can range check early.\\n  if (start < 0 || this.length < start || this.length < end) {\\n    throw new RangeError('Out of range index')\\n  }\\n\\n  if (end <= start) {\\n    return this\\n  }\\n\\n  start = start >>> 0\\n  end = end === undefined ? this.length : end >>> 0\\n\\n  if (!val) val = 0\\n\\n  var i\\n  if (typeof val === 'number') {\\n    for (i = start; i < end; i++) {\\n      this[i] = val\\n    }\\n  } else {\\n    var bytes = Buffer.isBuffer(val)\\n      ? val\\n      : utf8ToBytes(new Buffer(val, encoding).toString())\\n    var len = bytes.length\\n    for (i = 0; i < end - start; i++) {\\n      this[i + start] = bytes[i % len]\\n    }\\n  }\\n\\n  return this\\n}\\n\\n// HELPER FUNCTIONS\\n// ================\\n\\nvar INVALID_BASE64_RE = /[^+\\\\/0-9A-Za-z-_]/g\\n\\nfunction base64clean (str) {\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\\n  // Node converts strings with length < 2 to ''\\n  if (str.length < 2) return ''\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\n  while (str.length % 4 !== 0) {\\n    str = str + '='\\n  }\\n  return str\\n}\\n\\nfunction stringtrim (str) {\\n  if (str.trim) return str.trim()\\n  return str.replace(/^\\\\s+|\\\\s+$/g, '')\\n}\\n\\nfunction toHex (n) {\\n  if (n < 16) return '0' + n.toString(16)\\n  return n.toString(16)\\n}\\n\\nfunction utf8ToBytes (string, units) {\\n  units = units || Infinity\\n  var codePoint\\n  var length = string.length\\n  var leadSurrogate = null\\n  var bytes = []\\n\\n  for (var i = 0; i < length; i++) {\\n    codePoint = string.charCodeAt(i)\\n\\n    // is surrogate component\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\n      // last char was a lead\\n      if (!leadSurrogate) {\\n        // no lead yet\\n        if (codePoint > 0xDBFF) {\\n          // unexpected trail\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        } else if (i + 1 === length) {\\n          // unpaired lead\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        }\\n\\n        // valid lead\\n        leadSurrogate = codePoint\\n\\n        continue\\n      }\\n\\n      // 2 leads in a row\\n      if (codePoint < 0xDC00) {\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n        leadSurrogate = codePoint\\n        continue\\n      }\\n\\n      // valid surrogate pair\\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\\n    } else if (leadSurrogate) {\\n      // valid bmp char, but last char was a lead\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n    }\\n\\n    leadSurrogate = null\\n\\n    // encode utf8\\n    if (codePoint < 0x80) {\\n      if ((units -= 1) < 0) break\\n      bytes.push(codePoint)\\n    } else if (codePoint < 0x800) {\\n      if ((units -= 2) < 0) break\\n      bytes.push(\\n        codePoint >> 0x6 | 0xC0,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x10000) {\\n      if ((units -= 3) < 0) break\\n      bytes.push(\\n        codePoint >> 0xC | 0xE0,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x110000) {\\n      if ((units -= 4) < 0) break\\n      bytes.push(\\n        codePoint >> 0x12 | 0xF0,\\n        codePoint >> 0xC & 0x3F | 0x80,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else {\\n      throw new Error('Invalid code point')\\n    }\\n  }\\n\\n  return bytes\\n}\\n\\nfunction asciiToBytes (str) {\\n  var byteArray = []\\n  for (var i = 0; i < str.length; i++) {\\n    // Node's code seems to be doing this and not & 0x7F..\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\n  }\\n  return byteArray\\n}\\n\\nfunction utf16leToBytes (str, units) {\\n  var c, hi, lo\\n  var byteArray = []\\n  for (var i = 0; i < str.length; i++) {\\n    if ((units -= 2) < 0) break\\n\\n    c = str.charCodeAt(i)\\n    hi = c >> 8\\n    lo = c % 256\\n    byteArray.push(lo)\\n    byteArray.push(hi)\\n  }\\n\\n  return byteArray\\n}\\n\\nfunction base64ToBytes (str) {\\n  return base64.toByteArray(base64clean(str))\\n}\\n\\nfunction blitBuffer (src, dst, offset, length) {\\n  for (var i = 0; i < length; i++) {\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\n    dst[i + offset] = src[i]\\n  }\\n  return i\\n}\\n\\nfunction isnan (val) {\\n  return val !== val // eslint-disable-line no-self-compare\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"base64-js\\\":40,\\\"ieee754\\\":52,\\\"isarray\\\":46}],46:[function(require,module,exports){\\nvar toString = {}.toString;\\n\\nmodule.exports = Array.isArray || function (arr) {\\n  return toString.call(arr) == '[object Array]';\\n};\\n\\n},{}],47:[function(require,module,exports){\\n(function (Buffer){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\n// because it is fragile and can be easily faked with `Object.create()`.\\n\\nfunction isArray(arg) {\\n  if (Array.isArray) {\\n    return Array.isArray(arg);\\n  }\\n  return objectToString(arg) === '[object Array]';\\n}\\nexports.isArray = isArray;\\n\\nfunction isBoolean(arg) {\\n  return typeof arg === 'boolean';\\n}\\nexports.isBoolean = isBoolean;\\n\\nfunction isNull(arg) {\\n  return arg === null;\\n}\\nexports.isNull = isNull;\\n\\nfunction isNullOrUndefined(arg) {\\n  return arg == null;\\n}\\nexports.isNullOrUndefined = isNullOrUndefined;\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\nexports.isNumber = isNumber;\\n\\nfunction isString(arg) {\\n  return typeof arg === 'string';\\n}\\nexports.isString = isString;\\n\\nfunction isSymbol(arg) {\\n  return typeof arg === 'symbol';\\n}\\nexports.isSymbol = isSymbol;\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\nexports.isUndefined = isUndefined;\\n\\nfunction isRegExp(re) {\\n  return objectToString(re) === '[object RegExp]';\\n}\\nexports.isRegExp = isRegExp;\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\nexports.isObject = isObject;\\n\\nfunction isDate(d) {\\n  return objectToString(d) === '[object Date]';\\n}\\nexports.isDate = isDate;\\n\\nfunction isError(e) {\\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\\n}\\nexports.isError = isError;\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\nexports.isFunction = isFunction;\\n\\nfunction isPrimitive(arg) {\\n  return arg === null ||\\n         typeof arg === 'boolean' ||\\n         typeof arg === 'number' ||\\n         typeof arg === 'string' ||\\n         typeof arg === 'symbol' ||  // ES6 symbol\\n         typeof arg === 'undefined';\\n}\\nexports.isPrimitive = isPrimitive;\\n\\nexports.isBuffer = Buffer.isBuffer;\\n\\nfunction objectToString(o) {\\n  return Object.prototype.toString.call(o);\\n}\\n\\n}).call(this,{\\\"isBuffer\\\":require(\\\"../../is-buffer/index.js\\\")})\\n},{\\\"../../is-buffer/index.js\\\":54}],48:[function(require,module,exports){\\n/* See LICENSE file for terms of use */\\n\\n/*\\n * Text diff implementation.\\n *\\n * This library supports the following APIS:\\n * JsDiff.diffChars: Character by character diff\\n * JsDiff.diffWords: Word (as defined by \\\\b regex) diff which ignores whitespace\\n * JsDiff.diffLines: Line based diff\\n *\\n * JsDiff.diffCss: Diff targeted at CSS content\\n *\\n * These methods are based on the implementation proposed in\\n * \\\"An O(ND) Difference Algorithm and its Variations\\\" (Myers, 1986).\\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\\n */\\n(function(global, undefined) {\\n  var objectPrototypeToString = Object.prototype.toString;\\n\\n  /*istanbul ignore next*/\\n  function map(arr, mapper, that) {\\n    if (Array.prototype.map) {\\n      return Array.prototype.map.call(arr, mapper, that);\\n    }\\n\\n    var other = new Array(arr.length);\\n\\n    for (var i = 0, n = arr.length; i < n; i++) {\\n      other[i] = mapper.call(that, arr[i], i, arr);\\n    }\\n    return other;\\n  }\\n  function clonePath(path) {\\n    return { newPos: path.newPos, components: path.components.slice(0) };\\n  }\\n  function removeEmpty(array) {\\n    var ret = [];\\n    for (var i = 0; i < array.length; i++) {\\n      if (array[i]) {\\n        ret.push(array[i]);\\n      }\\n    }\\n    return ret;\\n  }\\n  function escapeHTML(s) {\\n    var n = s;\\n    n = n.replace(/&/g, '&amp;');\\n    n = n.replace(/</g, '&lt;');\\n    n = n.replace(/>/g, '&gt;');\\n    n = n.replace(/\\\"/g, '&quot;');\\n\\n    return n;\\n  }\\n\\n  // This function handles the presence of circular references by bailing out when encountering an\\n  // object that is already on the \\\"stack\\\" of items being processed.\\n  function canonicalize(obj, stack, replacementStack) {\\n    stack = stack || [];\\n    replacementStack = replacementStack || [];\\n\\n    var i;\\n\\n    for (i = 0; i < stack.length; i += 1) {\\n      if (stack[i] === obj) {\\n        return replacementStack[i];\\n      }\\n    }\\n\\n    var canonicalizedObj;\\n\\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\\n      stack.push(obj);\\n      canonicalizedObj = new Array(obj.length);\\n      replacementStack.push(canonicalizedObj);\\n      for (i = 0; i < obj.length; i += 1) {\\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\\n      }\\n      stack.pop();\\n      replacementStack.pop();\\n    } else if (typeof obj === 'object' && obj !== null) {\\n      stack.push(obj);\\n      canonicalizedObj = {};\\n      replacementStack.push(canonicalizedObj);\\n      var sortedKeys = [],\\n          key;\\n      for (key in obj) {\\n        sortedKeys.push(key);\\n      }\\n      sortedKeys.sort();\\n      for (i = 0; i < sortedKeys.length; i += 1) {\\n        key = sortedKeys[i];\\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\\n      }\\n      stack.pop();\\n      replacementStack.pop();\\n    } else {\\n      canonicalizedObj = obj;\\n    }\\n    return canonicalizedObj;\\n  }\\n\\n  function buildValues(components, newString, oldString, useLongestToken) {\\n    var componentPos = 0,\\n        componentLen = components.length,\\n        newPos = 0,\\n        oldPos = 0;\\n\\n    for (; componentPos < componentLen; componentPos++) {\\n      var component = components[componentPos];\\n      if (!component.removed) {\\n        if (!component.added && useLongestToken) {\\n          var value = newString.slice(newPos, newPos + component.count);\\n          value = map(value, function(value, i) {\\n            var oldValue = oldString[oldPos + i];\\n            return oldValue.length > value.length ? oldValue : value;\\n          });\\n\\n          component.value = value.join('');\\n        } else {\\n          component.value = newString.slice(newPos, newPos + component.count).join('');\\n        }\\n        newPos += component.count;\\n\\n        // Common case\\n        if (!component.added) {\\n          oldPos += component.count;\\n        }\\n      } else {\\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\\n        oldPos += component.count;\\n\\n        // Reverse add and remove so removes are output first to match common convention\\n        // The diffing algorithm is tied to add then remove output and this is the simplest\\n        // route to get the desired output with minimal overhead.\\n        if (componentPos && components[componentPos - 1].added) {\\n          var tmp = components[componentPos - 1];\\n          components[componentPos - 1] = components[componentPos];\\n          components[componentPos] = tmp;\\n        }\\n      }\\n    }\\n\\n    return components;\\n  }\\n\\n  function Diff(ignoreWhitespace) {\\n    this.ignoreWhitespace = ignoreWhitespace;\\n  }\\n  Diff.prototype = {\\n    diff: function(oldString, newString, callback) {\\n      var self = this;\\n\\n      function done(value) {\\n        if (callback) {\\n          setTimeout(function() { callback(undefined, value); }, 0);\\n          return true;\\n        } else {\\n          return value;\\n        }\\n      }\\n\\n      // Handle the identity case (this is due to unrolling editLength == 0\\n      if (newString === oldString) {\\n        return done([{ value: newString }]);\\n      }\\n      if (!newString) {\\n        return done([{ value: oldString, removed: true }]);\\n      }\\n      if (!oldString) {\\n        return done([{ value: newString, added: true }]);\\n      }\\n\\n      newString = this.tokenize(newString);\\n      oldString = this.tokenize(oldString);\\n\\n      var newLen = newString.length, oldLen = oldString.length;\\n      var editLength = 1;\\n      var maxEditLength = newLen + oldLen;\\n      var bestPath = [{ newPos: -1, components: [] }];\\n\\n      // Seed editLength = 0, i.e. the content starts with the same values\\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\\n        // Identity per the equality and tokenizer\\n        return done([{value: newString.join('')}]);\\n      }\\n\\n      // Main worker method. checks all permutations of a given edit length for acceptance.\\n      function execEditLength() {\\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\\n          var basePath;\\n          var addPath = bestPath[diagonalPath - 1],\\n              removePath = bestPath[diagonalPath + 1],\\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\\n          if (addPath) {\\n            // No one else is going to attempt to use this value, clear it\\n            bestPath[diagonalPath - 1] = undefined;\\n          }\\n\\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\\n          if (!canAdd && !canRemove) {\\n            // If this path is a terminal then prune\\n            bestPath[diagonalPath] = undefined;\\n            continue;\\n          }\\n\\n          // Select the diagonal that we want to branch from. We select the prior\\n          // path whose position in the new string is the farthest from the origin\\n          // and does not pass the bounds of the diff graph\\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\\n            basePath = clonePath(removePath);\\n            self.pushComponent(basePath.components, undefined, true);\\n          } else {\\n            basePath = addPath;   // No need to clone, we've pulled it from the list\\n            basePath.newPos++;\\n            self.pushComponent(basePath.components, true, undefined);\\n          }\\n\\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\\n\\n          // If we have hit the end of both strings, then we are done\\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\\n          } else {\\n            // Otherwise track this path as a potential candidate and continue.\\n            bestPath[diagonalPath] = basePath;\\n          }\\n        }\\n\\n        editLength++;\\n      }\\n\\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\\n      // sync and async mode which is never fun. Loops over execEditLength until a value\\n      // is produced.\\n      if (callback) {\\n        (function exec() {\\n          setTimeout(function() {\\n            // This should not happen, but we want to be safe.\\n            /*istanbul ignore next */\\n            if (editLength > maxEditLength) {\\n              return callback();\\n            }\\n\\n            if (!execEditLength()) {\\n              exec();\\n            }\\n          }, 0);\\n        }());\\n      } else {\\n        while (editLength <= maxEditLength) {\\n          var ret = execEditLength();\\n          if (ret) {\\n            return ret;\\n          }\\n        }\\n      }\\n    },\\n\\n    pushComponent: function(components, added, removed) {\\n      var last = components[components.length - 1];\\n      if (last && last.added === added && last.removed === removed) {\\n        // We need to clone here as the component clone operation is just\\n        // as shallow array clone\\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\\n      } else {\\n        components.push({count: 1, added: added, removed: removed });\\n      }\\n    },\\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\\n      var newLen = newString.length,\\n          oldLen = oldString.length,\\n          newPos = basePath.newPos,\\n          oldPos = newPos - diagonalPath,\\n\\n          commonCount = 0;\\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\\n        newPos++;\\n        oldPos++;\\n        commonCount++;\\n      }\\n\\n      if (commonCount) {\\n        basePath.components.push({count: commonCount});\\n      }\\n\\n      basePath.newPos = newPos;\\n      return oldPos;\\n    },\\n\\n    equals: function(left, right) {\\n      var reWhitespace = /\\\\S/;\\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\\n    },\\n    tokenize: function(value) {\\n      return value.split('');\\n    }\\n  };\\n\\n  var CharDiff = new Diff();\\n\\n  var WordDiff = new Diff(true);\\n  var WordWithSpaceDiff = new Diff();\\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\\n    return removeEmpty(value.split(/(\\\\s+|\\\\b)/));\\n  };\\n\\n  var CssDiff = new Diff(true);\\n  CssDiff.tokenize = function(value) {\\n    return removeEmpty(value.split(/([{}:;,]|\\\\s+)/));\\n  };\\n\\n  var LineDiff = new Diff();\\n\\n  var TrimmedLineDiff = new Diff();\\n  TrimmedLineDiff.ignoreTrim = true;\\n\\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\\n    var retLines = [],\\n        lines = value.split(/^/m);\\n    for (var i = 0; i < lines.length; i++) {\\n      var line = lines[i],\\n          lastLine = lines[i - 1],\\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\\n\\n      // Merge lines that may contain windows new lines\\n      if (line === '\\\\n' && lastLineLastChar === '\\\\r') {\\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\\\r\\\\n';\\n      } else {\\n        if (this.ignoreTrim) {\\n          line = line.trim();\\n          // add a newline unless this is the last line.\\n          if (i < lines.length - 1) {\\n            line += '\\\\n';\\n          }\\n        }\\n        retLines.push(line);\\n      }\\n    }\\n\\n    return retLines;\\n  };\\n\\n  var PatchDiff = new Diff();\\n  PatchDiff.tokenize = function(value) {\\n    var ret = [],\\n        linesAndNewlines = value.split(/(\\\\n|\\\\r\\\\n)/);\\n\\n    // Ignore the final empty token that occurs if the string ends with a new line\\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\\n      linesAndNewlines.pop();\\n    }\\n\\n    // Merge the content and line separators into single tokens\\n    for (var i = 0; i < linesAndNewlines.length; i++) {\\n      var line = linesAndNewlines[i];\\n\\n      if (i % 2) {\\n        ret[ret.length - 1] += line;\\n      } else {\\n        ret.push(line);\\n      }\\n    }\\n    return ret;\\n  };\\n\\n  var SentenceDiff = new Diff();\\n  SentenceDiff.tokenize = function(value) {\\n    return removeEmpty(value.split(/(\\\\S.+?[.!?])(?=\\\\s+|$)/));\\n  };\\n\\n  var JsonDiff = new Diff();\\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\\n  JsonDiff.useLongestToken = true;\\n  JsonDiff.tokenize = LineDiff.tokenize;\\n  JsonDiff.equals = function(left, right) {\\n    return LineDiff.equals(left.replace(/,([\\\\r\\\\n])/g, '$1'), right.replace(/,([\\\\r\\\\n])/g, '$1'));\\n  };\\n\\n  var JsDiff = {\\n    Diff: Diff,\\n\\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\\n\\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\\n\\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\\n    diffJson: function(oldObj, newObj, callback) {\\n      return JsonDiff.diff(\\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\\n        callback\\n      );\\n    },\\n\\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\\n      var ret = [];\\n\\n      if (oldFileName == newFileName) {\\n        ret.push('Index: ' + oldFileName);\\n      }\\n      ret.push('===================================================================');\\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\\\t' + oldHeader));\\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\\\t' + newHeader));\\n\\n      var diff = PatchDiff.diff(oldStr, newStr);\\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\\n\\n      // Formats a given set of lines for printing as context lines in a patch\\n      function contextLines(lines) {\\n        return map(lines, function(entry) { return ' ' + entry; });\\n      }\\n\\n      // Outputs the no newline at end of file warning if needed\\n      function eofNL(curRange, i, current) {\\n        var last = diff[diff.length - 2],\\n            isLast = i === diff.length - 2,\\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\\n\\n        // Figure out if this is the last line for the given file and missing NL\\n        if (!(/\\\\n$/.test(current.value)) && (isLast || isLastOfType)) {\\n          curRange.push('\\\\\\\\ No newline at end of file');\\n        }\\n      }\\n\\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\\n          oldLine = 1, newLine = 1;\\n      for (var i = 0; i < diff.length; i++) {\\n        var current = diff[i],\\n            lines = current.lines || current.value.replace(/\\\\n$/, '').split('\\\\n');\\n        current.lines = lines;\\n\\n        if (current.added || current.removed) {\\n          // If we have previous context, start with that\\n          if (!oldRangeStart) {\\n            var prev = diff[i - 1];\\n            oldRangeStart = oldLine;\\n            newRangeStart = newLine;\\n\\n            if (prev) {\\n              curRange = contextLines(prev.lines.slice(-4));\\n              oldRangeStart -= curRange.length;\\n              newRangeStart -= curRange.length;\\n            }\\n          }\\n\\n          // Output our changes\\n          curRange.push.apply(curRange, map(lines, function(entry) {\\n            return (current.added ? '+' : '-') + entry;\\n          }));\\n          eofNL(curRange, i, current);\\n\\n          // Track the updated file position\\n          if (current.added) {\\n            newLine += lines.length;\\n          } else {\\n            oldLine += lines.length;\\n          }\\n        } else {\\n          // Identical context lines. Track line changes\\n          if (oldRangeStart) {\\n            // Close out any changes that have been output (or join overlapping)\\n            if (lines.length <= 8 && i < diff.length - 2) {\\n              // Overlapping\\n              curRange.push.apply(curRange, contextLines(lines));\\n            } else {\\n              // end the range and output\\n              var contextSize = Math.min(lines.length, 4);\\n              ret.push(\\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\\n                  + ' @@');\\n              ret.push.apply(ret, curRange);\\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\\n              if (lines.length <= 4) {\\n                eofNL(ret, i, current);\\n              }\\n\\n              oldRangeStart = 0;\\n              newRangeStart = 0;\\n              curRange = [];\\n            }\\n          }\\n          oldLine += lines.length;\\n          newLine += lines.length;\\n        }\\n      }\\n\\n      return ret.join('\\\\n') + '\\\\n';\\n    },\\n\\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\\n    },\\n\\n    applyPatch: function(oldStr, uniDiff) {\\n      var diffstr = uniDiff.split('\\\\n'),\\n          hunks = [],\\n          i = 0,\\n          remEOFNL = false,\\n          addEOFNL = false;\\n\\n      // Skip to the first change hunk\\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\\n        i++;\\n      }\\n\\n      // Parse the unified diff\\n      for (; i < diffstr.length; i++) {\\n        if (diffstr[i][0] === '@') {\\n          var chnukHeader = diffstr[i].split(/@@ -(\\\\d+),(\\\\d+) \\\\+(\\\\d+),(\\\\d+) @@/);\\n          hunks.unshift({\\n            start: chnukHeader[3],\\n            oldlength: +chnukHeader[2],\\n            removed: [],\\n            newlength: chnukHeader[4],\\n            added: []\\n          });\\n        } else if (diffstr[i][0] === '+') {\\n          hunks[0].added.push(diffstr[i].substr(1));\\n        } else if (diffstr[i][0] === '-') {\\n          hunks[0].removed.push(diffstr[i].substr(1));\\n        } else if (diffstr[i][0] === ' ') {\\n          hunks[0].added.push(diffstr[i].substr(1));\\n          hunks[0].removed.push(diffstr[i].substr(1));\\n        } else if (diffstr[i][0] === '\\\\\\\\') {\\n          if (diffstr[i - 1][0] === '+') {\\n            remEOFNL = true;\\n          } else if (diffstr[i - 1][0] === '-') {\\n            addEOFNL = true;\\n          }\\n        }\\n      }\\n\\n      // Apply the diff to the input\\n      var lines = oldStr.split('\\\\n');\\n      for (i = hunks.length - 1; i >= 0; i--) {\\n        var hunk = hunks[i];\\n        // Sanity check the input string. Bail if we don't match.\\n        for (var j = 0; j < hunk.oldlength; j++) {\\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\\n            return false;\\n          }\\n        }\\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\\n      }\\n\\n      // Handle EOFNL insertion/removal\\n      if (remEOFNL) {\\n        while (!lines[lines.length - 1]) {\\n          lines.pop();\\n        }\\n      } else if (addEOFNL) {\\n        lines.push('');\\n      }\\n      return lines.join('\\\\n');\\n    },\\n\\n    convertChangesToXML: function(changes) {\\n      var ret = [];\\n      for (var i = 0; i < changes.length; i++) {\\n        var change = changes[i];\\n        if (change.added) {\\n          ret.push('<ins>');\\n        } else if (change.removed) {\\n          ret.push('<del>');\\n        }\\n\\n        ret.push(escapeHTML(change.value));\\n\\n        if (change.added) {\\n          ret.push('</ins>');\\n        } else if (change.removed) {\\n          ret.push('</del>');\\n        }\\n      }\\n      return ret.join('');\\n    },\\n\\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\\n    convertChangesToDMP: function(changes) {\\n      var ret = [],\\n          change,\\n          operation;\\n      for (var i = 0; i < changes.length; i++) {\\n        change = changes[i];\\n        if (change.added) {\\n          operation = 1;\\n        } else if (change.removed) {\\n          operation = -1;\\n        } else {\\n          operation = 0;\\n        }\\n\\n        ret.push([operation, change.value]);\\n      }\\n      return ret;\\n    },\\n\\n    canonicalize: canonicalize\\n  };\\n\\n  /*istanbul ignore next */\\n  /*global module */\\n  if (typeof module !== 'undefined' && module.exports) {\\n    module.exports = JsDiff;\\n  } else if (typeof define === 'function' && define.amd) {\\n    /*global define */\\n    define([], function() { return JsDiff; });\\n  } else if (typeof global.JsDiff === 'undefined') {\\n    global.JsDiff = JsDiff;\\n  }\\n}(this));\\n\\n},{}],49:[function(require,module,exports){\\n'use strict';\\n\\nvar matchOperatorsRe = /[|\\\\\\\\{}()[\\\\]^$+*?.]/g;\\n\\nmodule.exports = function (str) {\\n\\tif (typeof str !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\treturn str.replace(matchOperatorsRe,  '\\\\\\\\$&');\\n};\\n\\n},{}],50:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nfunction EventEmitter() {\\n  this._events = this._events || {};\\n  this._maxListeners = this._maxListeners || undefined;\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function(n) {\\n  if (!isNumber(n) || n < 0 || isNaN(n))\\n    throw TypeError('n must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nEventEmitter.prototype.emit = function(type) {\\n  var er, handler, len, args, i, listeners;\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // If there is no 'error' event listener then throw.\\n  if (type === 'error') {\\n    if (!this._events.error ||\\n        (isObject(this._events.error) && !this._events.error.length)) {\\n      er = arguments[1];\\n      if (er instanceof Error) {\\n        throw er; // Unhandled 'error' event\\n      }\\n      throw TypeError('Uncaught, unspecified \\\"error\\\" event.');\\n    }\\n  }\\n\\n  handler = this._events[type];\\n\\n  if (isUndefined(handler))\\n    return false;\\n\\n  if (isFunction(handler)) {\\n    switch (arguments.length) {\\n      // fast cases\\n      case 1:\\n        handler.call(this);\\n        break;\\n      case 2:\\n        handler.call(this, arguments[1]);\\n        break;\\n      case 3:\\n        handler.call(this, arguments[1], arguments[2]);\\n        break;\\n      // slower\\n      default:\\n        args = Array.prototype.slice.call(arguments, 1);\\n        handler.apply(this, args);\\n    }\\n  } else if (isObject(handler)) {\\n    args = Array.prototype.slice.call(arguments, 1);\\n    listeners = handler.slice();\\n    len = listeners.length;\\n    for (i = 0; i < len; i++)\\n      listeners[i].apply(this, args);\\n  }\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function(type, listener) {\\n  var m;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n  // adding it to the listeners, first emit \\\"newListener\\\".\\n  if (this._events.newListener)\\n    this.emit('newListener', type,\\n              isFunction(listener.listener) ?\\n              listener.listener : listener);\\n\\n  if (!this._events[type])\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    this._events[type] = listener;\\n  else if (isObject(this._events[type]))\\n    // If we've already got an array, just append.\\n    this._events[type].push(listener);\\n  else\\n    // Adding the second element, need to change to array.\\n    this._events[type] = [this._events[type], listener];\\n\\n  // Check for listener leak\\n  if (isObject(this._events[type]) && !this._events[type].warned) {\\n    if (!isUndefined(this._maxListeners)) {\\n      m = this._maxListeners;\\n    } else {\\n      m = EventEmitter.defaultMaxListeners;\\n    }\\n\\n    if (m && m > 0 && this._events[type].length > m) {\\n      this._events[type].warned = true;\\n      console.error('(node) warning: possible EventEmitter memory ' +\\n                    'leak detected. %d listeners added. ' +\\n                    'Use emitter.setMaxListeners() to increase limit.',\\n                    this._events[type].length);\\n      if (typeof console.trace === 'function') {\\n        // not supported in IE 10\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function(type, listener) {\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener = function(type, listener) {\\n  var list, position, length, i;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events || !this._events[type])\\n    return this;\\n\\n  list = this._events[type];\\n  length = list.length;\\n  position = -1;\\n\\n  if (list === listener ||\\n      (isFunction(list.listener) && list.listener === listener)) {\\n    delete this._events[type];\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n\\n  } else if (isObject(list)) {\\n    for (i = length; i-- > 0;) {\\n      if (list[i] === listener ||\\n          (list[i].listener && list[i].listener === listener)) {\\n        position = i;\\n        break;\\n      }\\n    }\\n\\n    if (position < 0)\\n      return this;\\n\\n    if (list.length === 1) {\\n      list.length = 0;\\n      delete this._events[type];\\n    } else {\\n      list.splice(position, 1);\\n    }\\n\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.removeAllListeners = function(type) {\\n  var key, listeners;\\n\\n  if (!this._events)\\n    return this;\\n\\n  // not listening for removeListener, no need to emit\\n  if (!this._events.removeListener) {\\n    if (arguments.length === 0)\\n      this._events = {};\\n    else if (this._events[type])\\n      delete this._events[type];\\n    return this;\\n  }\\n\\n  // emit removeListener for all listeners on all events\\n  if (arguments.length === 0) {\\n    for (key in this._events) {\\n      if (key === 'removeListener') continue;\\n      this.removeAllListeners(key);\\n    }\\n    this.removeAllListeners('removeListener');\\n    this._events = {};\\n    return this;\\n  }\\n\\n  listeners = this._events[type];\\n\\n  if (isFunction(listeners)) {\\n    this.removeListener(type, listeners);\\n  } else if (listeners) {\\n    // LIFO order\\n    while (listeners.length)\\n      this.removeListener(type, listeners[listeners.length - 1]);\\n  }\\n  delete this._events[type];\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.listeners = function(type) {\\n  var ret;\\n  if (!this._events || !this._events[type])\\n    ret = [];\\n  else if (isFunction(this._events[type]))\\n    ret = [this._events[type]];\\n  else\\n    ret = this._events[type].slice();\\n  return ret;\\n};\\n\\nEventEmitter.prototype.listenerCount = function(type) {\\n  if (this._events) {\\n    var evlistener = this._events[type];\\n\\n    if (isFunction(evlistener))\\n      return 1;\\n    else if (evlistener)\\n      return evlistener.length;\\n  }\\n  return 0;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  return emitter.listenerCount(type);\\n};\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\n\\n},{}],51:[function(require,module,exports){\\n(function (process){\\n// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar exec = require('child_process').exec\\n  , fs = require('fs')\\n  , path = require('path')\\n  , exists = fs.existsSync || path.existsSync\\n  , os = require('os')\\n  , quote = JSON.stringify\\n  , cmd;\\n\\nfunction which(name) {\\n  var paths = process.env.PATH.split(':');\\n  var loc;\\n\\n  for (var i = 0, len = paths.length; i < len; ++i) {\\n    loc = path.join(paths[i], name);\\n    if (exists(loc)) return loc;\\n  }\\n}\\n\\nswitch(os.type()) {\\n  case 'Darwin':\\n    if (which('terminal-notifier')) {\\n      cmd = {\\n          type: \\\"Darwin-NotificationCenter\\\"\\n        , pkg: \\\"terminal-notifier\\\"\\n        , msg: '-message'\\n        , title: '-title'\\n        , subtitle: '-subtitle'\\n        , icon: '-appIcon'\\n        , sound:  '-sound'\\n        , url: '-open'\\n        , priority: {\\n              cmd: '-execute'\\n            , range: []\\n          }\\n      };\\n    } else {\\n      cmd = {\\n          type: \\\"Darwin-Growl\\\"\\n        , pkg: \\\"growlnotify\\\"\\n        , msg: '-m'\\n        , sticky: '--sticky'\\n        , priority: {\\n              cmd: '--priority'\\n            , range: [\\n                -2\\n              , -1\\n              , 0\\n              , 1\\n              , 2\\n              , \\\"Very Low\\\"\\n              , \\\"Moderate\\\"\\n              , \\\"Normal\\\"\\n              , \\\"High\\\"\\n              , \\\"Emergency\\\"\\n            ]\\n          }\\n      };\\n    }\\n    break;\\n  case 'Linux':\\n    if (which('growl')) {\\n      cmd = {\\n          type: \\\"Linux-Growl\\\"\\n        , pkg: \\\"growl\\\"\\n        , msg: '-m'\\n        , title: '-title'\\n        , subtitle: '-subtitle'\\n        , host: {\\n            cmd: '-H'\\n          , hostname: '192.168.33.1'\\n        }\\n      };\\n    } else {\\n      cmd = {\\n          type: \\\"Linux\\\"\\n        , pkg: \\\"notify-send\\\"\\n        , msg: ''\\n        , sticky: '-t 0'\\n        , icon: '-i'\\n        , priority: {\\n            cmd: '-u'\\n          , range: [\\n              \\\"low\\\"\\n            , \\\"normal\\\"\\n            , \\\"critical\\\"\\n          ]\\n        }\\n      };\\n    }\\n    break;\\n  case 'Windows_NT':\\n    cmd = {\\n        type: \\\"Windows\\\"\\n      , pkg: \\\"growlnotify\\\"\\n      , msg: ''\\n      , sticky: '/s:true'\\n      , title: '/t:'\\n      , icon: '/i:'\\n      , url: '/cu:'\\n      , priority: {\\n            cmd: '/p:'\\n          , range: [\\n              -2\\n            , -1\\n            , 0\\n            , 1\\n            , 2\\n          ]\\n        }\\n    };\\n    break;\\n}\\n\\n/**\\n * Expose `growl`.\\n */\\n\\nexports = module.exports = growl;\\n\\n/**\\n * Node-growl version.\\n */\\n\\nexports.version = '1.4.1'\\n\\n/**\\n * Send growl notification _msg_ with _options_.\\n *\\n * Options:\\n *\\n *  - title   Notification title\\n *  - sticky  Make the notification stick (defaults to false)\\n *  - priority  Specify an int or named key (default is 0)\\n *  - name    Application name (defaults to growlnotify)\\n *  - sound   Sound efect ( in OSx defined in preferences -> sound -> effects) * works only in OSX > 10.8x\\n *  - image\\n *    - path to an icon sets --iconpath\\n *    - path to an image sets --image\\n *    - capitalized word sets --appIcon\\n *    - filename uses extname as --icon\\n *    - otherwise treated as --icon\\n *\\n * Examples:\\n *\\n *   growl('New email')\\n *   growl('5 new emails', { title: 'Thunderbird' })\\n *   growl('5 new emails', { title: 'Thunderbird', sound: 'Purr' })\\n *   growl('Email sent', function(){\\n *     // ... notification sent\\n *   })\\n *\\n * @param {string} msg\\n * @param {object} options\\n * @param {function} fn\\n * @api public\\n */\\n\\nfunction growl(msg, options, fn) {\\n  var image\\n    , args\\n    , options = options || {}\\n    , fn = fn || function(){};\\n\\n  if (options.exec) {\\n    cmd = {\\n        type: \\\"Custom\\\"\\n      , pkg: options.exec\\n      , range: []\\n    };\\n  }\\n\\n  // noop\\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\\n  args = [cmd.pkg];\\n\\n  // image\\n  if (image = options.image) {\\n    switch(cmd.type) {\\n      case 'Darwin-Growl':\\n        var flag, ext = path.extname(image).substr(1)\\n        flag = flag || ext == 'icns' && 'iconpath'\\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\\n        flag = flag || ext && (image = ext) && 'icon'\\n        flag = flag || 'icon'\\n        args.push('--' + flag, quote(image))\\n        break;\\n      case 'Darwin-NotificationCenter':\\n        args.push(cmd.icon, quote(image));\\n        break;\\n      case 'Linux':\\n        args.push(cmd.icon, quote(image));\\n        // libnotify defaults to sticky, set a hint for transient notifications\\n        if (!options.sticky) args.push('--hint=int:transient:1');\\n        break;\\n      case 'Windows':\\n        args.push(cmd.icon + quote(image));\\n        break;\\n    }\\n  }\\n\\n  // sticky\\n  if (options.sticky) args.push(cmd.sticky);\\n\\n  // priority\\n  if (options.priority) {\\n    var priority = options.priority + '';\\n    var checkindexOf = cmd.priority.range.indexOf(priority);\\n    if (~cmd.priority.range.indexOf(priority)) {\\n      args.push(cmd.priority, options.priority);\\n    }\\n  }\\n\\n  //sound\\n  if(options.sound && cmd.type === 'Darwin-NotificationCenter'){\\n    args.push(cmd.sound, options.sound)\\n  }\\n\\n  // name\\n  if (options.name && cmd.type === \\\"Darwin-Growl\\\") {\\n    args.push('--name', options.name);\\n  }\\n\\n  switch(cmd.type) {\\n    case 'Darwin-Growl':\\n      args.push(cmd.msg);\\n      args.push(quote(msg).replace(/\\\\\\\\n/g, '\\\\n'));\\n      if (options.title) args.push(quote(options.title));\\n      break;\\n    case 'Darwin-NotificationCenter':\\n      args.push(cmd.msg);\\n      var stringifiedMsg = quote(msg);\\n      var escapedMsg = stringifiedMsg.replace(/\\\\\\\\n/g, '\\\\n');\\n      args.push(escapedMsg);\\n      if (options.title) {\\n        args.push(cmd.title);\\n        args.push(quote(options.title));\\n      }\\n      if (options.subtitle) {\\n        args.push(cmd.subtitle);\\n        args.push(quote(options.subtitle));\\n      }\\n      if (options.url) {\\n        args.push(cmd.url);\\n        args.push(quote(options.url));\\n      }\\n      break;\\n    case 'Linux-Growl':\\n      args.push(cmd.msg);\\n      args.push(quote(msg).replace(/\\\\\\\\n/g, '\\\\n'));\\n      if (options.title) args.push(quote(options.title));\\n      if (cmd.host) {\\n        args.push(cmd.host.cmd, cmd.host.hostname)\\n      }\\n      break;\\n    case 'Linux':\\n      if (options.title) {\\n        args.push(quote(options.title));\\n        args.push(cmd.msg);\\n        args.push(quote(msg).replace(/\\\\\\\\n/g, '\\\\n'));\\n      } else {\\n        args.push(quote(msg).replace(/\\\\\\\\n/g, '\\\\n'));\\n      }\\n      break;\\n    case 'Windows':\\n      args.push(quote(msg).replace(/\\\\\\\\n/g, '\\\\n'));\\n      if (options.title) args.push(cmd.title + quote(options.title));\\n      if (options.url) args.push(cmd.url + quote(options.url));\\n      break;\\n    case 'Custom':\\n      args[0] = (function(origCommand) {\\n        var message = options.title\\n          ? options.title + ': ' + msg\\n          : msg;\\n        var command = origCommand.replace(/(^|[^%])%s/g, '$1' + quote(message));\\n        if (command === origCommand) args.push(quote(message));\\n        return command;\\n      })(args[0]);\\n      break;\\n  }\\n\\n  // execute\\n  exec(args.join(' '), fn);\\n};\\n\\n}).call(this,require('_process'))\\n},{\\\"_process\\\":58,\\\"child_process\\\":43,\\\"fs\\\":43,\\\"os\\\":56,\\\"path\\\":43}],52:[function(require,module,exports){\\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\\n  var e, m\\n  var eLen = nBytes * 8 - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var nBits = -7\\n  var i = isLE ? (nBytes - 1) : 0\\n  var d = isLE ? -1 : 1\\n  var s = buffer[offset + i]\\n\\n  i += d\\n\\n  e = s & ((1 << (-nBits)) - 1)\\n  s >>= (-nBits)\\n  nBits += eLen\\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  m = e & ((1 << (-nBits)) - 1)\\n  e >>= (-nBits)\\n  nBits += mLen\\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  if (e === 0) {\\n    e = 1 - eBias\\n  } else if (e === eMax) {\\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\\n  } else {\\n    m = m + Math.pow(2, mLen)\\n    e = e - eBias\\n  }\\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\\n}\\n\\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\\n  var e, m, c\\n  var eLen = nBytes * 8 - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\\n  var i = isLE ? 0 : (nBytes - 1)\\n  var d = isLE ? 1 : -1\\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\\n\\n  value = Math.abs(value)\\n\\n  if (isNaN(value) || value === Infinity) {\\n    m = isNaN(value) ? 1 : 0\\n    e = eMax\\n  } else {\\n    e = Math.floor(Math.log(value) / Math.LN2)\\n    if (value * (c = Math.pow(2, -e)) < 1) {\\n      e--\\n      c *= 2\\n    }\\n    if (e + eBias >= 1) {\\n      value += rt / c\\n    } else {\\n      value += rt * Math.pow(2, 1 - eBias)\\n    }\\n    if (value * c >= 2) {\\n      e++\\n      c /= 2\\n    }\\n\\n    if (e + eBias >= eMax) {\\n      m = 0\\n      e = eMax\\n    } else if (e + eBias >= 1) {\\n      m = (value * c - 1) * Math.pow(2, mLen)\\n      e = e + eBias\\n    } else {\\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\\n      e = 0\\n    }\\n  }\\n\\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\\n\\n  e = (e << mLen) | m\\n  eLen += mLen\\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\\n\\n  buffer[offset + i - d] |= s * 128\\n}\\n\\n},{}],53:[function(require,module,exports){\\nif (typeof Object.create === 'function') {\\n  // implementation from standard node.js 'util' module\\n  module.exports = function inherits(ctor, superCtor) {\\n    ctor.super_ = superCtor\\n    ctor.prototype = Object.create(superCtor.prototype, {\\n      constructor: {\\n        value: ctor,\\n        enumerable: false,\\n        writable: true,\\n        configurable: true\\n      }\\n    });\\n  };\\n} else {\\n  // old school shim for old browsers\\n  module.exports = function inherits(ctor, superCtor) {\\n    ctor.super_ = superCtor\\n    var TempCtor = function () {}\\n    TempCtor.prototype = superCtor.prototype\\n    ctor.prototype = new TempCtor()\\n    ctor.prototype.constructor = ctor\\n  }\\n}\\n\\n},{}],54:[function(require,module,exports){\\n/**\\n * Determine if an object is Buffer\\n *\\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\\n * License:  MIT\\n *\\n * `npm install is-buffer`\\n */\\n\\nmodule.exports = function (obj) {\\n  return !!(obj != null &&\\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\\n      (obj.constructor &&\\n      typeof obj.constructor.isBuffer === 'function' &&\\n      obj.constructor.isBuffer(obj))\\n    ))\\n}\\n\\n},{}],55:[function(require,module,exports){\\n(function (process){\\nvar path = require('path');\\nvar fs = require('fs');\\nvar _0777 = parseInt('0777', 8);\\n\\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\\n\\nfunction mkdirP (p, opts, f, made) {\\n    if (typeof opts === 'function') {\\n        f = opts;\\n        opts = {};\\n    }\\n    else if (!opts || typeof opts !== 'object') {\\n        opts = { mode: opts };\\n    }\\n    \\n    var mode = opts.mode;\\n    var xfs = opts.fs || fs;\\n    \\n    if (mode === undefined) {\\n        mode = _0777 & (~process.umask());\\n    }\\n    if (!made) made = null;\\n    \\n    var cb = f || function () {};\\n    p = path.resolve(p);\\n    \\n    xfs.mkdir(p, mode, function (er) {\\n        if (!er) {\\n            made = made || p;\\n            return cb(null, made);\\n        }\\n        switch (er.code) {\\n            case 'ENOENT':\\n                mkdirP(path.dirname(p), opts, function (er, made) {\\n                    if (er) cb(er, made);\\n                    else mkdirP(p, opts, cb, made);\\n                });\\n                break;\\n\\n            // In the case of any other error, just see if there's a dir\\n            // there already.  If so, then hooray!  If not, then something\\n            // is borked.\\n            default:\\n                xfs.stat(p, function (er2, stat) {\\n                    // if the stat fails, then that's super weird.\\n                    // let the original error be the failure reason.\\n                    if (er2 || !stat.isDirectory()) cb(er, made)\\n                    else cb(null, made);\\n                });\\n                break;\\n        }\\n    });\\n}\\n\\nmkdirP.sync = function sync (p, opts, made) {\\n    if (!opts || typeof opts !== 'object') {\\n        opts = { mode: opts };\\n    }\\n    \\n    var mode = opts.mode;\\n    var xfs = opts.fs || fs;\\n    \\n    if (mode === undefined) {\\n        mode = _0777 & (~process.umask());\\n    }\\n    if (!made) made = null;\\n\\n    p = path.resolve(p);\\n\\n    try {\\n        xfs.mkdirSync(p, mode);\\n        made = made || p;\\n    }\\n    catch (err0) {\\n        switch (err0.code) {\\n            case 'ENOENT' :\\n                made = sync(path.dirname(p), opts, made);\\n                sync(p, opts, made);\\n                break;\\n\\n            // In the case of any other error, just see if there's a dir\\n            // there already.  If so, then hooray!  If not, then something\\n            // is borked.\\n            default:\\n                var stat;\\n                try {\\n                    stat = xfs.statSync(p);\\n                }\\n                catch (err1) {\\n                    throw err0;\\n                }\\n                if (!stat.isDirectory()) throw err0;\\n                break;\\n        }\\n    }\\n\\n    return made;\\n};\\n\\n}).call(this,require('_process'))\\n},{\\\"_process\\\":58,\\\"fs\\\":43,\\\"path\\\":43}],56:[function(require,module,exports){\\nexports.endianness = function () { return 'LE' };\\n\\nexports.hostname = function () {\\n    if (typeof location !== 'undefined') {\\n        return location.hostname\\n    }\\n    else return '';\\n};\\n\\nexports.loadavg = function () { return [] };\\n\\nexports.uptime = function () { return 0 };\\n\\nexports.freemem = function () {\\n    return Number.MAX_VALUE;\\n};\\n\\nexports.totalmem = function () {\\n    return Number.MAX_VALUE;\\n};\\n\\nexports.cpus = function () { return [] };\\n\\nexports.type = function () { return 'Browser' };\\n\\nexports.release = function () {\\n    if (typeof navigator !== 'undefined') {\\n        return navigator.appVersion;\\n    }\\n    return '';\\n};\\n\\nexports.networkInterfaces\\n= exports.getNetworkInterfaces\\n= function () { return {} };\\n\\nexports.arch = function () { return 'javascript' };\\n\\nexports.platform = function () { return 'browser' };\\n\\nexports.tmpdir = exports.tmpDir = function () {\\n    return '/tmp';\\n};\\n\\nexports.EOL = '\\\\n';\\n\\n},{}],57:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nif (!process.version ||\\n    process.version.indexOf('v0.') === 0 ||\\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\\n  module.exports = nextTick;\\n} else {\\n  module.exports = process.nextTick;\\n}\\n\\nfunction nextTick(fn, arg1, arg2, arg3) {\\n  if (typeof fn !== 'function') {\\n    throw new TypeError('\\\"callback\\\" argument must be a function');\\n  }\\n  var len = arguments.length;\\n  var args, i;\\n  switch (len) {\\n  case 0:\\n  case 1:\\n    return process.nextTick(fn);\\n  case 2:\\n    return process.nextTick(function afterTickOne() {\\n      fn.call(null, arg1);\\n    });\\n  case 3:\\n    return process.nextTick(function afterTickTwo() {\\n      fn.call(null, arg1, arg2);\\n    });\\n  case 4:\\n    return process.nextTick(function afterTickThree() {\\n      fn.call(null, arg1, arg2, arg3);\\n    });\\n  default:\\n    args = new Array(len - 1);\\n    i = 0;\\n    while (i < args.length) {\\n      args[i++] = arguments[i];\\n    }\\n    return process.nextTick(function afterTick() {\\n      fn.apply(null, args);\\n    });\\n  }\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"_process\\\":58}],58:[function(require,module,exports){\\n// shim for using process in browser\\n\\nvar process = module.exports = {};\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = setTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    clearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        setTimeout(drainQueue, 0);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n},{}],59:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nmodule.exports = Stream;\\n\\nvar EE = require('events').EventEmitter;\\nvar inherits = require('inherits');\\n\\ninherits(Stream, EE);\\nStream.Readable = require('readable-stream/readable.js');\\nStream.Writable = require('readable-stream/writable.js');\\nStream.Duplex = require('readable-stream/duplex.js');\\nStream.Transform = require('readable-stream/transform.js');\\nStream.PassThrough = require('readable-stream/passthrough.js');\\n\\n// Backwards-compat with node 0.4.x\\nStream.Stream = Stream;\\n\\n\\n\\n// old-style streams.  Note that the pipe method (the only relevant\\n// part of this class) is overridden in the Readable class.\\n\\nfunction Stream() {\\n  EE.call(this);\\n}\\n\\nStream.prototype.pipe = function(dest, options) {\\n  var source = this;\\n\\n  function ondata(chunk) {\\n    if (dest.writable) {\\n      if (false === dest.write(chunk) && source.pause) {\\n        source.pause();\\n      }\\n    }\\n  }\\n\\n  source.on('data', ondata);\\n\\n  function ondrain() {\\n    if (source.readable && source.resume) {\\n      source.resume();\\n    }\\n  }\\n\\n  dest.on('drain', ondrain);\\n\\n  // If the 'end' option is not supplied, dest.end() will be called when\\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\\n  if (!dest._isStdio && (!options || options.end !== false)) {\\n    source.on('end', onend);\\n    source.on('close', onclose);\\n  }\\n\\n  var didOnEnd = false;\\n  function onend() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    dest.end();\\n  }\\n\\n\\n  function onclose() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    if (typeof dest.destroy === 'function') dest.destroy();\\n  }\\n\\n  // don't leave dangling pipes when there are errors.\\n  function onerror(er) {\\n    cleanup();\\n    if (EE.listenerCount(this, 'error') === 0) {\\n      throw er; // Unhandled stream error in pipe.\\n    }\\n  }\\n\\n  source.on('error', onerror);\\n  dest.on('error', onerror);\\n\\n  // remove all the event listeners that were added.\\n  function cleanup() {\\n    source.removeListener('data', ondata);\\n    dest.removeListener('drain', ondrain);\\n\\n    source.removeListener('end', onend);\\n    source.removeListener('close', onclose);\\n\\n    source.removeListener('error', onerror);\\n    dest.removeListener('error', onerror);\\n\\n    source.removeListener('end', cleanup);\\n    source.removeListener('close', cleanup);\\n\\n    dest.removeListener('close', cleanup);\\n  }\\n\\n  source.on('end', cleanup);\\n  source.on('close', cleanup);\\n\\n  dest.on('close', cleanup);\\n\\n  dest.emit('pipe', source);\\n\\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\\n  return dest;\\n};\\n\\n},{\\\"events\\\":50,\\\"inherits\\\":53,\\\"readable-stream/duplex.js\\\":61,\\\"readable-stream/passthrough.js\\\":67,\\\"readable-stream/readable.js\\\":68,\\\"readable-stream/transform.js\\\":69,\\\"readable-stream/writable.js\\\":70}],60:[function(require,module,exports){\\narguments[4][46][0].apply(exports,arguments)\\n},{\\\"dup\\\":46}],61:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_duplex.js\\\")\\n\\n},{\\\"./lib/_stream_duplex.js\\\":62}],62:[function(require,module,exports){\\n// a duplex stream is just a stream that is both readable and writable.\\n// Since JS doesn't have multiple prototypal inheritance, this class\\n// prototypally inherits from Readable, and then parasitically from\\n// Writable.\\n\\n'use strict';\\n\\n/*<replacement>*/\\n\\nvar objectKeys = Object.keys || function (obj) {\\n  var keys = [];\\n  for (var key in obj) {\\n    keys.push(key);\\n  }return keys;\\n};\\n/*</replacement>*/\\n\\nmodule.exports = Duplex;\\n\\n/*<replacement>*/\\nvar processNextTick = require('process-nextick-args');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nvar Readable = require('./_stream_readable');\\nvar Writable = require('./_stream_writable');\\n\\nutil.inherits(Duplex, Readable);\\n\\nvar keys = objectKeys(Writable.prototype);\\nfor (var v = 0; v < keys.length; v++) {\\n  var method = keys[v];\\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\\n}\\n\\nfunction Duplex(options) {\\n  if (!(this instanceof Duplex)) return new Duplex(options);\\n\\n  Readable.call(this, options);\\n  Writable.call(this, options);\\n\\n  if (options && options.readable === false) this.readable = false;\\n\\n  if (options && options.writable === false) this.writable = false;\\n\\n  this.allowHalfOpen = true;\\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\\n\\n  this.once('end', onend);\\n}\\n\\n// the no-half-open enforcer\\nfunction onend() {\\n  // if we allow half-open state, or if the writable side ended,\\n  // then we're ok.\\n  if (this.allowHalfOpen || this._writableState.ended) return;\\n\\n  // no more data can be written.\\n  // But allow more writes to happen in this tick.\\n  processNextTick(onEndNT, this);\\n}\\n\\nfunction onEndNT(self) {\\n  self.end();\\n}\\n\\nfunction forEach(xs, f) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    f(xs[i], i);\\n  }\\n}\\n},{\\\"./_stream_readable\\\":64,\\\"./_stream_writable\\\":66,\\\"core-util-is\\\":47,\\\"inherits\\\":53,\\\"process-nextick-args\\\":57}],63:[function(require,module,exports){\\n// a passthrough stream.\\n// basically just the most minimal sort of Transform stream.\\n// Every written chunk gets output as-is.\\n\\n'use strict';\\n\\nmodule.exports = PassThrough;\\n\\nvar Transform = require('./_stream_transform');\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nutil.inherits(PassThrough, Transform);\\n\\nfunction PassThrough(options) {\\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\\n\\n  Transform.call(this, options);\\n}\\n\\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\\n  cb(null, chunk);\\n};\\n},{\\\"./_stream_transform\\\":65,\\\"core-util-is\\\":47,\\\"inherits\\\":53}],64:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nmodule.exports = Readable;\\n\\n/*<replacement>*/\\nvar processNextTick = require('process-nextick-args');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar isArray = require('isarray');\\n/*</replacement>*/\\n\\nReadable.ReadableState = ReadableState;\\n\\n/*<replacement>*/\\nvar EE = require('events').EventEmitter;\\n\\nvar EElistenerCount = function (emitter, type) {\\n  return emitter.listeners(type).length;\\n};\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar Stream;\\n(function () {\\n  try {\\n    Stream = require('st' + 'ream');\\n  } catch (_) {} finally {\\n    if (!Stream) Stream = require('events').EventEmitter;\\n  }\\n})();\\n/*</replacement>*/\\n\\nvar Buffer = require('buffer').Buffer;\\n/*<replacement>*/\\nvar bufferShim = require('buffer-shims');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar debugUtil = require('util');\\nvar debug = void 0;\\nif (debugUtil && debugUtil.debuglog) {\\n  debug = debugUtil.debuglog('stream');\\n} else {\\n  debug = function () {};\\n}\\n/*</replacement>*/\\n\\nvar StringDecoder;\\n\\nutil.inherits(Readable, Stream);\\n\\nvar hasPrependListener = typeof EE.prototype.prependListener === 'function';\\n\\nfunction prependListener(emitter, event, fn) {\\n  if (hasPrependListener) return emitter.prependListener(event, fn);\\n\\n  // This is a brutally ugly hack to make sure that our error handler\\n  // is attached before any userland ones.  NEVER DO THIS. This is here\\n  // only because this code needs to continue to work with older versions\\n  // of Node.js that do not include the prependListener() method. The goal\\n  // is to eventually remove this hack.\\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\\n}\\n\\nvar Duplex;\\nfunction ReadableState(options, stream) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  options = options || {};\\n\\n  // object stream flag. Used to make read(n) ignore n and to\\n  // make all the buffer merging and length checks go away\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\\n\\n  // the point at which it stops calling _read() to fill the buffer\\n  // Note: 0 is a valid value, means \\\"don't call _read preemptively ever\\\"\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~ ~this.highWaterMark;\\n\\n  this.buffer = [];\\n  this.length = 0;\\n  this.pipes = null;\\n  this.pipesCount = 0;\\n  this.flowing = null;\\n  this.ended = false;\\n  this.endEmitted = false;\\n  this.reading = false;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // whenever we return null, then we set a flag to say\\n  // that we're awaiting a 'readable' event emission.\\n  this.needReadable = false;\\n  this.emittedReadable = false;\\n  this.readableListening = false;\\n  this.resumeScheduled = false;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // when piping, we only care about 'readable' events that happen\\n  // after read()ing all the bytes and not getting any pushback.\\n  this.ranOut = false;\\n\\n  // the number of writers that are awaiting a drain event in .pipe()s\\n  this.awaitDrain = 0;\\n\\n  // if true, a maybeReadMore has been scheduled\\n  this.readingMore = false;\\n\\n  this.decoder = null;\\n  this.encoding = null;\\n  if (options.encoding) {\\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\\n    this.decoder = new StringDecoder(options.encoding);\\n    this.encoding = options.encoding;\\n  }\\n}\\n\\nvar Duplex;\\nfunction Readable(options) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  if (!(this instanceof Readable)) return new Readable(options);\\n\\n  this._readableState = new ReadableState(options, this);\\n\\n  // legacy\\n  this.readable = true;\\n\\n  if (options && typeof options.read === 'function') this._read = options.read;\\n\\n  Stream.call(this);\\n}\\n\\n// Manually shove something into the read() buffer.\\n// This returns true if the highWaterMark has not been hit yet,\\n// similar to how Writable.write() returns true if you should\\n// write() some more.\\nReadable.prototype.push = function (chunk, encoding) {\\n  var state = this._readableState;\\n\\n  if (!state.objectMode && typeof chunk === 'string') {\\n    encoding = encoding || state.defaultEncoding;\\n    if (encoding !== state.encoding) {\\n      chunk = bufferShim.from(chunk, encoding);\\n      encoding = '';\\n    }\\n  }\\n\\n  return readableAddChunk(this, state, chunk, encoding, false);\\n};\\n\\n// Unshift should *always* be something directly out of read()\\nReadable.prototype.unshift = function (chunk) {\\n  var state = this._readableState;\\n  return readableAddChunk(this, state, chunk, '', true);\\n};\\n\\nReadable.prototype.isPaused = function () {\\n  return this._readableState.flowing === false;\\n};\\n\\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\\n  var er = chunkInvalid(state, chunk);\\n  if (er) {\\n    stream.emit('error', er);\\n  } else if (chunk === null) {\\n    state.reading = false;\\n    onEofChunk(stream, state);\\n  } else if (state.objectMode || chunk && chunk.length > 0) {\\n    if (state.ended && !addToFront) {\\n      var e = new Error('stream.push() after EOF');\\n      stream.emit('error', e);\\n    } else if (state.endEmitted && addToFront) {\\n      var _e = new Error('stream.unshift() after end event');\\n      stream.emit('error', _e);\\n    } else {\\n      var skipAdd;\\n      if (state.decoder && !addToFront && !encoding) {\\n        chunk = state.decoder.write(chunk);\\n        skipAdd = !state.objectMode && chunk.length === 0;\\n      }\\n\\n      if (!addToFront) state.reading = false;\\n\\n      // Don't add to the buffer if we've decoded to an empty string chunk and\\n      // we're not in object mode\\n      if (!skipAdd) {\\n        // if we want the data now, just emit it.\\n        if (state.flowing && state.length === 0 && !state.sync) {\\n          stream.emit('data', chunk);\\n          stream.read(0);\\n        } else {\\n          // update the buffer info.\\n          state.length += state.objectMode ? 1 : chunk.length;\\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\\n\\n          if (state.needReadable) emitReadable(stream);\\n        }\\n      }\\n\\n      maybeReadMore(stream, state);\\n    }\\n  } else if (!addToFront) {\\n    state.reading = false;\\n  }\\n\\n  return needMoreData(state);\\n}\\n\\n// if it's past the high water mark, we can push in some more.\\n// Also, if we have no data yet, we can stand some\\n// more bytes.  This is to work around cases where hwm=0,\\n// such as the repl.  Also, if the push() triggered a\\n// readable event, and the user called read(largeNumber) such that\\n// needReadable was set, then we ought to push more, so that another\\n// 'readable' event will be triggered.\\nfunction needMoreData(state) {\\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\\n}\\n\\n// backwards compatibility.\\nReadable.prototype.setEncoding = function (enc) {\\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\\n  this._readableState.decoder = new StringDecoder(enc);\\n  this._readableState.encoding = enc;\\n  return this;\\n};\\n\\n// Don't raise the hwm > 8MB\\nvar MAX_HWM = 0x800000;\\nfunction computeNewHighWaterMark(n) {\\n  if (n >= MAX_HWM) {\\n    n = MAX_HWM;\\n  } else {\\n    // Get the next highest power of 2\\n    n--;\\n    n |= n >>> 1;\\n    n |= n >>> 2;\\n    n |= n >>> 4;\\n    n |= n >>> 8;\\n    n |= n >>> 16;\\n    n++;\\n  }\\n  return n;\\n}\\n\\nfunction howMuchToRead(n, state) {\\n  if (state.length === 0 && state.ended) return 0;\\n\\n  if (state.objectMode) return n === 0 ? 0 : 1;\\n\\n  if (n === null || isNaN(n)) {\\n    // only flow one buffer at a time\\n    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;\\n  }\\n\\n  if (n <= 0) return 0;\\n\\n  // If we're asking for more than the target buffer level,\\n  // then raise the water mark.  Bump up to the next highest\\n  // power of 2, to prevent increasing it excessively in tiny\\n  // amounts.\\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\\n\\n  // don't have that much.  return null, unless we've ended.\\n  if (n > state.length) {\\n    if (!state.ended) {\\n      state.needReadable = true;\\n      return 0;\\n    } else {\\n      return state.length;\\n    }\\n  }\\n\\n  return n;\\n}\\n\\n// you can override either this method, or the async _read(n) below.\\nReadable.prototype.read = function (n) {\\n  debug('read', n);\\n  var state = this._readableState;\\n  var nOrig = n;\\n\\n  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;\\n\\n  // if we're doing read(0) to trigger a readable event, but we\\n  // already have a bunch of data in the buffer, then just trigger\\n  // the 'readable' event and move on.\\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\\n    debug('read: emitReadable', state.length, state.ended);\\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\\n    return null;\\n  }\\n\\n  n = howMuchToRead(n, state);\\n\\n  // if we've ended, and we're now clear, then finish it up.\\n  if (n === 0 && state.ended) {\\n    if (state.length === 0) endReadable(this);\\n    return null;\\n  }\\n\\n  // All the actual chunk generation logic needs to be\\n  // *below* the call to _read.  The reason is that in certain\\n  // synthetic stream cases, such as passthrough streams, _read\\n  // may be a completely synchronous operation which may change\\n  // the state of the read buffer, providing enough data when\\n  // before there was *not* enough.\\n  //\\n  // So, the steps are:\\n  // 1. Figure out what the state of things will be after we do\\n  // a read from the buffer.\\n  //\\n  // 2. If that resulting state will trigger a _read, then call _read.\\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\\n  // deeply ugly to write APIs this way, but that still doesn't mean\\n  // that the Readable class should behave improperly, as streams are\\n  // designed to be sync/async agnostic.\\n  // Take note if the _read call is sync or async (ie, if the read call\\n  // has returned yet), so that we know whether or not it's safe to emit\\n  // 'readable' etc.\\n  //\\n  // 3. Actually pull the requested chunks out of the buffer and return.\\n\\n  // if we need a readable event, then we need to do some reading.\\n  var doRead = state.needReadable;\\n  debug('need readable', doRead);\\n\\n  // if we currently have less than the highWaterMark, then also read some\\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\\n    doRead = true;\\n    debug('length less than watermark', doRead);\\n  }\\n\\n  // however, if we've ended, then there's no point, and if we're already\\n  // reading, then it's unnecessary.\\n  if (state.ended || state.reading) {\\n    doRead = false;\\n    debug('reading or ended', doRead);\\n  }\\n\\n  if (doRead) {\\n    debug('do read');\\n    state.reading = true;\\n    state.sync = true;\\n    // if the length is currently zero, then we *need* a readable event.\\n    if (state.length === 0) state.needReadable = true;\\n    // call internal read method\\n    this._read(state.highWaterMark);\\n    state.sync = false;\\n  }\\n\\n  // If _read pushed data synchronously, then `reading` will be false,\\n  // and we need to re-evaluate how much data we can return to the user.\\n  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\\n\\n  var ret;\\n  if (n > 0) ret = fromList(n, state);else ret = null;\\n\\n  if (ret === null) {\\n    state.needReadable = true;\\n    n = 0;\\n  }\\n\\n  state.length -= n;\\n\\n  // If we have nothing in the buffer, then we want to know\\n  // as soon as we *do* get something into the buffer.\\n  if (state.length === 0 && !state.ended) state.needReadable = true;\\n\\n  // If we tried to read() past the EOF, then emit end on the next tick.\\n  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\\n\\n  if (ret !== null) this.emit('data', ret);\\n\\n  return ret;\\n};\\n\\nfunction chunkInvalid(state, chunk) {\\n  var er = null;\\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  return er;\\n}\\n\\nfunction onEofChunk(stream, state) {\\n  if (state.ended) return;\\n  if (state.decoder) {\\n    var chunk = state.decoder.end();\\n    if (chunk && chunk.length) {\\n      state.buffer.push(chunk);\\n      state.length += state.objectMode ? 1 : chunk.length;\\n    }\\n  }\\n  state.ended = true;\\n\\n  // emit 'readable' now to make sure it gets picked up.\\n  emitReadable(stream);\\n}\\n\\n// Don't emit readable right away in sync mode, because this can trigger\\n// another read() call => stack overflow.  This way, it might trigger\\n// a nextTick recursion warning, but that's not so bad.\\nfunction emitReadable(stream) {\\n  var state = stream._readableState;\\n  state.needReadable = false;\\n  if (!state.emittedReadable) {\\n    debug('emitReadable', state.flowing);\\n    state.emittedReadable = true;\\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\\n  }\\n}\\n\\nfunction emitReadable_(stream) {\\n  debug('emit readable');\\n  stream.emit('readable');\\n  flow(stream);\\n}\\n\\n// at this point, the user has presumably seen the 'readable' event,\\n// and called read() to consume some data.  that may have triggered\\n// in turn another _read(n) call, in which case reading = true if\\n// it's in progress.\\n// However, if we're not ended, or reading, and the length < hwm,\\n// then go ahead and try to read some more preemptively.\\nfunction maybeReadMore(stream, state) {\\n  if (!state.readingMore) {\\n    state.readingMore = true;\\n    processNextTick(maybeReadMore_, stream, state);\\n  }\\n}\\n\\nfunction maybeReadMore_(stream, state) {\\n  var len = state.length;\\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\\n    debug('maybeReadMore read 0');\\n    stream.read(0);\\n    if (len === state.length)\\n      // didn't get any data, stop spinning.\\n      break;else len = state.length;\\n  }\\n  state.readingMore = false;\\n}\\n\\n// abstract method.  to be overridden in specific implementation classes.\\n// call cb(er, data) where data is <= n in length.\\n// for virtual (non-string, non-buffer) streams, \\\"length\\\" is somewhat\\n// arbitrary, and perhaps not very meaningful.\\nReadable.prototype._read = function (n) {\\n  this.emit('error', new Error('not implemented'));\\n};\\n\\nReadable.prototype.pipe = function (dest, pipeOpts) {\\n  var src = this;\\n  var state = this._readableState;\\n\\n  switch (state.pipesCount) {\\n    case 0:\\n      state.pipes = dest;\\n      break;\\n    case 1:\\n      state.pipes = [state.pipes, dest];\\n      break;\\n    default:\\n      state.pipes.push(dest);\\n      break;\\n  }\\n  state.pipesCount += 1;\\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\\n\\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\\n\\n  var endFn = doEnd ? onend : cleanup;\\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\\n\\n  dest.on('unpipe', onunpipe);\\n  function onunpipe(readable) {\\n    debug('onunpipe');\\n    if (readable === src) {\\n      cleanup();\\n    }\\n  }\\n\\n  function onend() {\\n    debug('onend');\\n    dest.end();\\n  }\\n\\n  // when the dest drains, it reduces the awaitDrain counter\\n  // on the source.  This would be more elegant with a .once()\\n  // handler in flow(), but adding and removing repeatedly is\\n  // too slow.\\n  var ondrain = pipeOnDrain(src);\\n  dest.on('drain', ondrain);\\n\\n  var cleanedUp = false;\\n  function cleanup() {\\n    debug('cleanup');\\n    // cleanup event handlers once the pipe is broken\\n    dest.removeListener('close', onclose);\\n    dest.removeListener('finish', onfinish);\\n    dest.removeListener('drain', ondrain);\\n    dest.removeListener('error', onerror);\\n    dest.removeListener('unpipe', onunpipe);\\n    src.removeListener('end', onend);\\n    src.removeListener('end', cleanup);\\n    src.removeListener('data', ondata);\\n\\n    cleanedUp = true;\\n\\n    // if the reader is waiting for a drain event from this\\n    // specific writer, then it would cause it to never start\\n    // flowing again.\\n    // So, if this is awaiting a drain, then we just call it now.\\n    // If we don't know, then assume that we are waiting for one.\\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\\n  }\\n\\n  src.on('data', ondata);\\n  function ondata(chunk) {\\n    debug('ondata');\\n    var ret = dest.write(chunk);\\n    if (false === ret) {\\n      // If the user unpiped during `dest.write()`, it is possible\\n      // to get stuck in a permanently paused state if that write\\n      // also returned false.\\n      // => Check whether `dest` is still a piping destination.\\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\\n        debug('false write response, pause', src._readableState.awaitDrain);\\n        src._readableState.awaitDrain++;\\n      }\\n      src.pause();\\n    }\\n  }\\n\\n  // if the dest has an error, then stop piping into it.\\n  // however, don't suppress the throwing behavior for this.\\n  function onerror(er) {\\n    debug('onerror', er);\\n    unpipe();\\n    dest.removeListener('error', onerror);\\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\\n  }\\n\\n  // Make sure our error handler is attached before userland ones.\\n  prependListener(dest, 'error', onerror);\\n\\n  // Both close and finish should trigger unpipe, but only once.\\n  function onclose() {\\n    dest.removeListener('finish', onfinish);\\n    unpipe();\\n  }\\n  dest.once('close', onclose);\\n  function onfinish() {\\n    debug('onfinish');\\n    dest.removeListener('close', onclose);\\n    unpipe();\\n  }\\n  dest.once('finish', onfinish);\\n\\n  function unpipe() {\\n    debug('unpipe');\\n    src.unpipe(dest);\\n  }\\n\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', src);\\n\\n  // start the flow if it hasn't been started already.\\n  if (!state.flowing) {\\n    debug('pipe resume');\\n    src.resume();\\n  }\\n\\n  return dest;\\n};\\n\\nfunction pipeOnDrain(src) {\\n  return function () {\\n    var state = src._readableState;\\n    debug('pipeOnDrain', state.awaitDrain);\\n    if (state.awaitDrain) state.awaitDrain--;\\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\\n      state.flowing = true;\\n      flow(src);\\n    }\\n  };\\n}\\n\\nReadable.prototype.unpipe = function (dest) {\\n  var state = this._readableState;\\n\\n  // if we're not piping anywhere, then do nothing.\\n  if (state.pipesCount === 0) return this;\\n\\n  // just one destination.  most common case.\\n  if (state.pipesCount === 1) {\\n    // passed in one, but it's not the right one.\\n    if (dest && dest !== state.pipes) return this;\\n\\n    if (!dest) dest = state.pipes;\\n\\n    // got a match.\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n    if (dest) dest.emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // slow case. multiple pipe destinations.\\n\\n  if (!dest) {\\n    // remove all.\\n    var dests = state.pipes;\\n    var len = state.pipesCount;\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n\\n    for (var _i = 0; _i < len; _i++) {\\n      dests[_i].emit('unpipe', this);\\n    }return this;\\n  }\\n\\n  // try to find the right one.\\n  var i = indexOf(state.pipes, dest);\\n  if (i === -1) return this;\\n\\n  state.pipes.splice(i, 1);\\n  state.pipesCount -= 1;\\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\\n\\n  dest.emit('unpipe', this);\\n\\n  return this;\\n};\\n\\n// set up data events if they are asked for\\n// Ensure readable listeners eventually get something\\nReadable.prototype.on = function (ev, fn) {\\n  var res = Stream.prototype.on.call(this, ev, fn);\\n\\n  // If listening to data, and it has not explicitly been paused,\\n  // then call resume to start the flow of data on the next tick.\\n  if (ev === 'data' && false !== this._readableState.flowing) {\\n    this.resume();\\n  }\\n\\n  if (ev === 'readable' && !this._readableState.endEmitted) {\\n    var state = this._readableState;\\n    if (!state.readableListening) {\\n      state.readableListening = true;\\n      state.emittedReadable = false;\\n      state.needReadable = true;\\n      if (!state.reading) {\\n        processNextTick(nReadingNextTick, this);\\n      } else if (state.length) {\\n        emitReadable(this, state);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\nReadable.prototype.addListener = Readable.prototype.on;\\n\\nfunction nReadingNextTick(self) {\\n  debug('readable nexttick read 0');\\n  self.read(0);\\n}\\n\\n// pause() and resume() are remnants of the legacy readable stream API\\n// If the user uses them, then switch into old mode.\\nReadable.prototype.resume = function () {\\n  var state = this._readableState;\\n  if (!state.flowing) {\\n    debug('resume');\\n    state.flowing = true;\\n    resume(this, state);\\n  }\\n  return this;\\n};\\n\\nfunction resume(stream, state) {\\n  if (!state.resumeScheduled) {\\n    state.resumeScheduled = true;\\n    processNextTick(resume_, stream, state);\\n  }\\n}\\n\\nfunction resume_(stream, state) {\\n  if (!state.reading) {\\n    debug('resume read 0');\\n    stream.read(0);\\n  }\\n\\n  state.resumeScheduled = false;\\n  stream.emit('resume');\\n  flow(stream);\\n  if (state.flowing && !state.reading) stream.read(0);\\n}\\n\\nReadable.prototype.pause = function () {\\n  debug('call pause flowing=%j', this._readableState.flowing);\\n  if (false !== this._readableState.flowing) {\\n    debug('pause');\\n    this._readableState.flowing = false;\\n    this.emit('pause');\\n  }\\n  return this;\\n};\\n\\nfunction flow(stream) {\\n  var state = stream._readableState;\\n  debug('flow', state.flowing);\\n  if (state.flowing) {\\n    do {\\n      var chunk = stream.read();\\n    } while (null !== chunk && state.flowing);\\n  }\\n}\\n\\n// wrap an old-style stream as the async data source.\\n// This is *not* part of the readable stream interface.\\n// It is an ugly unfortunate mess of history.\\nReadable.prototype.wrap = function (stream) {\\n  var state = this._readableState;\\n  var paused = false;\\n\\n  var self = this;\\n  stream.on('end', function () {\\n    debug('wrapped end');\\n    if (state.decoder && !state.ended) {\\n      var chunk = state.decoder.end();\\n      if (chunk && chunk.length) self.push(chunk);\\n    }\\n\\n    self.push(null);\\n  });\\n\\n  stream.on('data', function (chunk) {\\n    debug('wrapped data');\\n    if (state.decoder) chunk = state.decoder.write(chunk);\\n\\n    // don't skip over falsy values in objectMode\\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\\n\\n    var ret = self.push(chunk);\\n    if (!ret) {\\n      paused = true;\\n      stream.pause();\\n    }\\n  });\\n\\n  // proxy all the other methods.\\n  // important when wrapping filters and duplexes.\\n  for (var i in stream) {\\n    if (this[i] === undefined && typeof stream[i] === 'function') {\\n      this[i] = function (method) {\\n        return function () {\\n          return stream[method].apply(stream, arguments);\\n        };\\n      }(i);\\n    }\\n  }\\n\\n  // proxy certain important events.\\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\\n  forEach(events, function (ev) {\\n    stream.on(ev, self.emit.bind(self, ev));\\n  });\\n\\n  // when we try to consume some more bytes, simply unpause the\\n  // underlying stream.\\n  self._read = function (n) {\\n    debug('wrapped _read', n);\\n    if (paused) {\\n      paused = false;\\n      stream.resume();\\n    }\\n  };\\n\\n  return self;\\n};\\n\\n// exposed for testing purposes only.\\nReadable._fromList = fromList;\\n\\n// Pluck off n bytes from an array of buffers.\\n// Length is the combined lengths of all the buffers in the list.\\nfunction fromList(n, state) {\\n  var list = state.buffer;\\n  var length = state.length;\\n  var stringMode = !!state.decoder;\\n  var objectMode = !!state.objectMode;\\n  var ret;\\n\\n  // nothing in the list, definitely empty.\\n  if (list.length === 0) return null;\\n\\n  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {\\n    // read it all, truncate the array.\\n    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\\n    list.length = 0;\\n  } else {\\n    // read just some of it.\\n    if (n < list[0].length) {\\n      // just take a part of the first list item.\\n      // slice is the same for buffers and strings.\\n      var buf = list[0];\\n      ret = buf.slice(0, n);\\n      list[0] = buf.slice(n);\\n    } else if (n === list[0].length) {\\n      // first list is a perfect match\\n      ret = list.shift();\\n    } else {\\n      // complex case.\\n      // we have enough to cover it, but it spans past the first buffer.\\n      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);\\n\\n      var c = 0;\\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\\n        var _buf = list[0];\\n        var cpy = Math.min(n - c, _buf.length);\\n\\n        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);\\n\\n        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();\\n\\n        c += cpy;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n}\\n\\nfunction endReadable(stream) {\\n  var state = stream._readableState;\\n\\n  // If we get here before consuming all the bytes, then that is a\\n  // bug in node.  Should never happen.\\n  if (state.length > 0) throw new Error('\\\"endReadable()\\\" called on non-empty stream');\\n\\n  if (!state.endEmitted) {\\n    state.ended = true;\\n    processNextTick(endReadableNT, state, stream);\\n  }\\n}\\n\\nfunction endReadableNT(state, stream) {\\n  // Check that we didn't get one last unshift.\\n  if (!state.endEmitted && state.length === 0) {\\n    state.endEmitted = true;\\n    stream.readable = false;\\n    stream.emit('end');\\n  }\\n}\\n\\nfunction forEach(xs, f) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    f(xs[i], i);\\n  }\\n}\\n\\nfunction indexOf(xs, x) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    if (xs[i] === x) return i;\\n  }\\n  return -1;\\n}\\n}).call(this,require('_process'))\\n},{\\\"./_stream_duplex\\\":62,\\\"_process\\\":58,\\\"buffer\\\":45,\\\"buffer-shims\\\":44,\\\"core-util-is\\\":47,\\\"events\\\":50,\\\"inherits\\\":53,\\\"isarray\\\":60,\\\"process-nextick-args\\\":57,\\\"string_decoder/\\\":71,\\\"util\\\":41}],65:[function(require,module,exports){\\n// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\n'use strict';\\n\\nmodule.exports = Transform;\\n\\nvar Duplex = require('./_stream_duplex');\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nutil.inherits(Transform, Duplex);\\n\\nfunction TransformState(stream) {\\n  this.afterTransform = function (er, data) {\\n    return afterTransform(stream, er, data);\\n  };\\n\\n  this.needTransform = false;\\n  this.transforming = false;\\n  this.writecb = null;\\n  this.writechunk = null;\\n  this.writeencoding = null;\\n}\\n\\nfunction afterTransform(stream, er, data) {\\n  var ts = stream._transformState;\\n  ts.transforming = false;\\n\\n  var cb = ts.writecb;\\n\\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\\n\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n\\n  if (data !== null && data !== undefined) stream.push(data);\\n\\n  cb(er);\\n\\n  var rs = stream._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    stream._read(rs.highWaterMark);\\n  }\\n}\\n\\nfunction Transform(options) {\\n  if (!(this instanceof Transform)) return new Transform(options);\\n\\n  Duplex.call(this, options);\\n\\n  this._transformState = new TransformState(this);\\n\\n  // when the writable side finishes, then flush out anything remaining.\\n  var stream = this;\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n\\n  if (options) {\\n    if (typeof options.transform === 'function') this._transform = options.transform;\\n\\n    if (typeof options.flush === 'function') this._flush = options.flush;\\n  }\\n\\n  this.once('prefinish', function () {\\n    if (typeof this._flush === 'function') this._flush(function (er) {\\n      done(stream, er);\\n    });else done(stream);\\n  });\\n}\\n\\nTransform.prototype.push = function (chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function (chunk, encoding, cb) {\\n  throw new Error('Not implemented');\\n};\\n\\nTransform.prototype._write = function (chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function (n) {\\n  var ts = this._transformState;\\n\\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\n\\nfunction done(stream, er) {\\n  if (er) return stream.emit('error', er);\\n\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  var ws = stream._writableState;\\n  var ts = stream._transformState;\\n\\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\\n\\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\\n\\n  return stream.push(null);\\n}\\n},{\\\"./_stream_duplex\\\":62,\\\"core-util-is\\\":47,\\\"inherits\\\":53}],66:[function(require,module,exports){\\n(function (process){\\n// A bit simpler than readable streams.\\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\\n// the drain event emission and buffering.\\n\\n'use strict';\\n\\nmodule.exports = Writable;\\n\\n/*<replacement>*/\\nvar processNextTick = require('process-nextick-args');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\\n/*</replacement>*/\\n\\nWritable.WritableState = WritableState;\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar internalUtil = {\\n  deprecate: require('util-deprecate')\\n};\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar Stream;\\n(function () {\\n  try {\\n    Stream = require('st' + 'ream');\\n  } catch (_) {} finally {\\n    if (!Stream) Stream = require('events').EventEmitter;\\n  }\\n})();\\n/*</replacement>*/\\n\\nvar Buffer = require('buffer').Buffer;\\n/*<replacement>*/\\nvar bufferShim = require('buffer-shims');\\n/*</replacement>*/\\n\\nutil.inherits(Writable, Stream);\\n\\nfunction nop() {}\\n\\nfunction WriteReq(chunk, encoding, cb) {\\n  this.chunk = chunk;\\n  this.encoding = encoding;\\n  this.callback = cb;\\n  this.next = null;\\n}\\n\\nvar Duplex;\\nfunction WritableState(options, stream) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  options = options || {};\\n\\n  // object stream flag to indicate whether or not this stream\\n  // contains buffers or objects.\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\\n\\n  // the point at which write() starts returning false\\n  // Note: 0 is a valid value, means that we always return false if\\n  // the entire buffer is not flushed immediately on write()\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~ ~this.highWaterMark;\\n\\n  this.needDrain = false;\\n  // at the start of calling end()\\n  this.ending = false;\\n  // when end() has been called, and returned\\n  this.ended = false;\\n  // when 'finish' is emitted\\n  this.finished = false;\\n\\n  // should we decode strings into buffers before passing to _write?\\n  // this is here so that some node-core streams can optimize string\\n  // handling at a lower level.\\n  var noDecode = options.decodeStrings === false;\\n  this.decodeStrings = !noDecode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // not an actual buffer we keep track of, but a measurement\\n  // of how much we're waiting to get pushed to some underlying\\n  // socket or file.\\n  this.length = 0;\\n\\n  // a flag to see when we're in the middle of a write.\\n  this.writing = false;\\n\\n  // when true all writes will be buffered until .uncork() call\\n  this.corked = 0;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // a flag to know if we're processing previously buffered items, which\\n  // may call the _write() callback in the same tick, so that we don't\\n  // end up in an overlapped onwrite situation.\\n  this.bufferProcessing = false;\\n\\n  // the callback that's passed to _write(chunk,cb)\\n  this.onwrite = function (er) {\\n    onwrite(stream, er);\\n  };\\n\\n  // the callback that the user supplies to write(chunk,encoding,cb)\\n  this.writecb = null;\\n\\n  // the amount that is being written when _write is called.\\n  this.writelen = 0;\\n\\n  this.bufferedRequest = null;\\n  this.lastBufferedRequest = null;\\n\\n  // number of pending user-supplied write callbacks\\n  // this must be 0 before 'finish' can be emitted\\n  this.pendingcb = 0;\\n\\n  // emit prefinish if the only thing we're waiting for is _write cbs\\n  // This is relevant for synchronous Transform streams\\n  this.prefinished = false;\\n\\n  // True if the error was already emitted and should not be thrown again\\n  this.errorEmitted = false;\\n\\n  // count buffered requests\\n  this.bufferedRequestCount = 0;\\n\\n  // allocate the first CorkedRequest, there is always\\n  // one allocated and free to use, and we maintain at most two\\n  this.corkedRequestsFree = new CorkedRequest(this);\\n}\\n\\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\\n  var current = this.bufferedRequest;\\n  var out = [];\\n  while (current) {\\n    out.push(current);\\n    current = current.next;\\n  }\\n  return out;\\n};\\n\\n(function () {\\n  try {\\n    Object.defineProperty(WritableState.prototype, 'buffer', {\\n      get: internalUtil.deprecate(function () {\\n        return this.getBuffer();\\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\\n    });\\n  } catch (_) {}\\n})();\\n\\nvar Duplex;\\nfunction Writable(options) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  // Writable ctor is applied to Duplexes, though they're not\\n  // instanceof Writable, they're instanceof Readable.\\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\\n\\n  this._writableState = new WritableState(options, this);\\n\\n  // legacy.\\n  this.writable = true;\\n\\n  if (options) {\\n    if (typeof options.write === 'function') this._write = options.write;\\n\\n    if (typeof options.writev === 'function') this._writev = options.writev;\\n  }\\n\\n  Stream.call(this);\\n}\\n\\n// Otherwise people can pipe Writable streams, which is just wrong.\\nWritable.prototype.pipe = function () {\\n  this.emit('error', new Error('Cannot pipe, not readable'));\\n};\\n\\nfunction writeAfterEnd(stream, cb) {\\n  var er = new Error('write after end');\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  stream.emit('error', er);\\n  processNextTick(cb, er);\\n}\\n\\n// If we get something that is not a buffer, string, null, or undefined,\\n// and we're not in objectMode, then that's an error.\\n// Otherwise stream chunks are all considered to be of length=1, and the\\n// watermarks determine how many objects to keep in the buffer, rather than\\n// how many bytes or characters.\\nfunction validChunk(stream, state, chunk, cb) {\\n  var valid = true;\\n  var er = false;\\n  // Always throw error if a null is written\\n  // if we are not in object mode then throw\\n  // if it is not a buffer, string, or undefined.\\n  if (chunk === null) {\\n    er = new TypeError('May not write null values to stream');\\n  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  if (er) {\\n    stream.emit('error', er);\\n    processNextTick(cb, er);\\n    valid = false;\\n  }\\n  return valid;\\n}\\n\\nWritable.prototype.write = function (chunk, encoding, cb) {\\n  var state = this._writableState;\\n  var ret = false;\\n\\n  if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\\n\\n  if (typeof cb !== 'function') cb = nop;\\n\\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\\n    state.pendingcb++;\\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n};\\n\\nWritable.prototype.cork = function () {\\n  var state = this._writableState;\\n\\n  state.corked++;\\n};\\n\\nWritable.prototype.uncork = function () {\\n  var state = this._writableState;\\n\\n  if (state.corked) {\\n    state.corked--;\\n\\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\\n  }\\n};\\n\\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\\n  // node::ParseEncoding() requires lower case.\\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\\n  this._writableState.defaultEncoding = encoding;\\n  return this;\\n};\\n\\nfunction decodeChunk(state, chunk, encoding) {\\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\\n    chunk = bufferShim.from(chunk, encoding);\\n  }\\n  return chunk;\\n}\\n\\n// if we're already writing something, then just put this\\n// in the queue, and wait our turn.  Otherwise, call _write\\n// If we return false, then we need a drain event, so set that flag.\\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\\n  chunk = decodeChunk(state, chunk, encoding);\\n\\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\\n  var len = state.objectMode ? 1 : chunk.length;\\n\\n  state.length += len;\\n\\n  var ret = state.length < state.highWaterMark;\\n  // we must ensure that previous needDrain will not be reset to false.\\n  if (!ret) state.needDrain = true;\\n\\n  if (state.writing || state.corked) {\\n    var last = state.lastBufferedRequest;\\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\\n    if (last) {\\n      last.next = state.lastBufferedRequest;\\n    } else {\\n      state.bufferedRequest = state.lastBufferedRequest;\\n    }\\n    state.bufferedRequestCount += 1;\\n  } else {\\n    doWrite(stream, state, false, len, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n}\\n\\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\\n  state.writelen = len;\\n  state.writecb = cb;\\n  state.writing = true;\\n  state.sync = true;\\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\\n  state.sync = false;\\n}\\n\\nfunction onwriteError(stream, state, sync, er, cb) {\\n  --state.pendingcb;\\n  if (sync) processNextTick(cb, er);else cb(er);\\n\\n  stream._writableState.errorEmitted = true;\\n  stream.emit('error', er);\\n}\\n\\nfunction onwriteStateUpdate(state) {\\n  state.writing = false;\\n  state.writecb = null;\\n  state.length -= state.writelen;\\n  state.writelen = 0;\\n}\\n\\nfunction onwrite(stream, er) {\\n  var state = stream._writableState;\\n  var sync = state.sync;\\n  var cb = state.writecb;\\n\\n  onwriteStateUpdate(state);\\n\\n  if (er) onwriteError(stream, state, sync, er, cb);else {\\n    // Check if we're actually ready to finish, but don't emit yet\\n    var finished = needFinish(state);\\n\\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\\n      clearBuffer(stream, state);\\n    }\\n\\n    if (sync) {\\n      /*<replacement>*/\\n      asyncWrite(afterWrite, stream, state, finished, cb);\\n      /*</replacement>*/\\n    } else {\\n        afterWrite(stream, state, finished, cb);\\n      }\\n  }\\n}\\n\\nfunction afterWrite(stream, state, finished, cb) {\\n  if (!finished) onwriteDrain(stream, state);\\n  state.pendingcb--;\\n  cb();\\n  finishMaybe(stream, state);\\n}\\n\\n// Must force callback to be called on nextTick, so that we don't\\n// emit 'drain' before the write() consumer gets the 'false' return\\n// value, and has a chance to attach a 'drain' listener.\\nfunction onwriteDrain(stream, state) {\\n  if (state.length === 0 && state.needDrain) {\\n    state.needDrain = false;\\n    stream.emit('drain');\\n  }\\n}\\n\\n// if there's something in the buffer waiting, then process it\\nfunction clearBuffer(stream, state) {\\n  state.bufferProcessing = true;\\n  var entry = state.bufferedRequest;\\n\\n  if (stream._writev && entry && entry.next) {\\n    // Fast case, write everything using _writev()\\n    var l = state.bufferedRequestCount;\\n    var buffer = new Array(l);\\n    var holder = state.corkedRequestsFree;\\n    holder.entry = entry;\\n\\n    var count = 0;\\n    while (entry) {\\n      buffer[count] = entry;\\n      entry = entry.next;\\n      count += 1;\\n    }\\n\\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\\n\\n    // doWrite is almost always async, defer these to save a bit of time\\n    // as the hot path ends with doWrite\\n    state.pendingcb++;\\n    state.lastBufferedRequest = null;\\n    if (holder.next) {\\n      state.corkedRequestsFree = holder.next;\\n      holder.next = null;\\n    } else {\\n      state.corkedRequestsFree = new CorkedRequest(state);\\n    }\\n  } else {\\n    // Slow case, write chunks one-by-one\\n    while (entry) {\\n      var chunk = entry.chunk;\\n      var encoding = entry.encoding;\\n      var cb = entry.callback;\\n      var len = state.objectMode ? 1 : chunk.length;\\n\\n      doWrite(stream, state, false, len, chunk, encoding, cb);\\n      entry = entry.next;\\n      // if we didn't call the onwrite immediately, then\\n      // it means that we need to wait until it does.\\n      // also, that means that the chunk and cb are currently\\n      // being processed, so move the buffer counter past them.\\n      if (state.writing) {\\n        break;\\n      }\\n    }\\n\\n    if (entry === null) state.lastBufferedRequest = null;\\n  }\\n\\n  state.bufferedRequestCount = 0;\\n  state.bufferedRequest = entry;\\n  state.bufferProcessing = false;\\n}\\n\\nWritable.prototype._write = function (chunk, encoding, cb) {\\n  cb(new Error('not implemented'));\\n};\\n\\nWritable.prototype._writev = null;\\n\\nWritable.prototype.end = function (chunk, encoding, cb) {\\n  var state = this._writableState;\\n\\n  if (typeof chunk === 'function') {\\n    cb = chunk;\\n    chunk = null;\\n    encoding = null;\\n  } else if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\\n\\n  // .end() fully uncorks\\n  if (state.corked) {\\n    state.corked = 1;\\n    this.uncork();\\n  }\\n\\n  // ignore unnecessary end() calls.\\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\\n};\\n\\nfunction needFinish(state) {\\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\\n}\\n\\nfunction prefinish(stream, state) {\\n  if (!state.prefinished) {\\n    state.prefinished = true;\\n    stream.emit('prefinish');\\n  }\\n}\\n\\nfunction finishMaybe(stream, state) {\\n  var need = needFinish(state);\\n  if (need) {\\n    if (state.pendingcb === 0) {\\n      prefinish(stream, state);\\n      state.finished = true;\\n      stream.emit('finish');\\n    } else {\\n      prefinish(stream, state);\\n    }\\n  }\\n  return need;\\n}\\n\\nfunction endWritable(stream, state, cb) {\\n  state.ending = true;\\n  finishMaybe(stream, state);\\n  if (cb) {\\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\\n  }\\n  state.ended = true;\\n  stream.writable = false;\\n}\\n\\n// It seems a linked list but it is not\\n// there will be only 2 of these for each stream\\nfunction CorkedRequest(state) {\\n  var _this = this;\\n\\n  this.next = null;\\n  this.entry = null;\\n\\n  this.finish = function (err) {\\n    var entry = _this.entry;\\n    _this.entry = null;\\n    while (entry) {\\n      var cb = entry.callback;\\n      state.pendingcb--;\\n      cb(err);\\n      entry = entry.next;\\n    }\\n    if (state.corkedRequestsFree) {\\n      state.corkedRequestsFree.next = _this;\\n    } else {\\n      state.corkedRequestsFree = _this;\\n    }\\n  };\\n}\\n}).call(this,require('_process'))\\n},{\\\"./_stream_duplex\\\":62,\\\"_process\\\":58,\\\"buffer\\\":45,\\\"buffer-shims\\\":44,\\\"core-util-is\\\":47,\\\"events\\\":50,\\\"inherits\\\":53,\\\"process-nextick-args\\\":57,\\\"util-deprecate\\\":73}],67:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_passthrough.js\\\")\\n\\n},{\\\"./lib/_stream_passthrough.js\\\":63}],68:[function(require,module,exports){\\n(function (process){\\nvar Stream = (function (){\\n  try {\\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\\n  } catch(_){}\\n}());\\nexports = module.exports = require('./lib/_stream_readable.js');\\nexports.Stream = Stream || exports;\\nexports.Readable = exports;\\nexports.Writable = require('./lib/_stream_writable.js');\\nexports.Duplex = require('./lib/_stream_duplex.js');\\nexports.Transform = require('./lib/_stream_transform.js');\\nexports.PassThrough = require('./lib/_stream_passthrough.js');\\n\\nif (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {\\n  module.exports = Stream;\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./lib/_stream_duplex.js\\\":62,\\\"./lib/_stream_passthrough.js\\\":63,\\\"./lib/_stream_readable.js\\\":64,\\\"./lib/_stream_transform.js\\\":65,\\\"./lib/_stream_writable.js\\\":66,\\\"_process\\\":58}],69:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_transform.js\\\")\\n\\n},{\\\"./lib/_stream_transform.js\\\":65}],70:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_writable.js\\\")\\n\\n},{\\\"./lib/_stream_writable.js\\\":66}],71:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar Buffer = require('buffer').Buffer;\\n\\nvar isBufferEncoding = Buffer.isEncoding\\n  || function(encoding) {\\n       switch (encoding && encoding.toLowerCase()) {\\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\\n         default: return false;\\n       }\\n     }\\n\\n\\nfunction assertEncoding(encoding) {\\n  if (encoding && !isBufferEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\n// StringDecoder provides an interface for efficiently splitting a series of\\n// buffers into a series of JS strings without breaking apart multi-byte\\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\\n//\\n// @TODO Handling all encodings inside a single object makes it very difficult\\n// to reason about this code, so it should be split up in the future.\\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\\n// points as used by CESU-8.\\nvar StringDecoder = exports.StringDecoder = function(encoding) {\\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\\n  assertEncoding(encoding);\\n  switch (this.encoding) {\\n    case 'utf8':\\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\\n      this.surrogateSize = 3;\\n      break;\\n    case 'ucs2':\\n    case 'utf16le':\\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\\n      this.surrogateSize = 2;\\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\\n      break;\\n    case 'base64':\\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\\n      this.surrogateSize = 3;\\n      this.detectIncompleteChar = base64DetectIncompleteChar;\\n      break;\\n    default:\\n      this.write = passThroughWrite;\\n      return;\\n  }\\n\\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\\n  this.charBuffer = new Buffer(6);\\n  // Number of bytes received for the current incomplete multi-byte character.\\n  this.charReceived = 0;\\n  // Number of bytes expected for the current incomplete multi-byte character.\\n  this.charLength = 0;\\n};\\n\\n\\n// write decodes the given buffer and returns it as JS string that is\\n// guaranteed to not contain any partial multi-byte characters. Any partial\\n// character found at the end of the buffer is buffered up, and will be\\n// returned when calling write again with the remaining bytes.\\n//\\n// Note: Converting a Buffer containing an orphan surrogate to a String\\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\\n// Buffer#write) will replace incomplete surrogates with the unicode\\n// replacement character. See https://codereview.chromium.org/121173009/ .\\nStringDecoder.prototype.write = function(buffer) {\\n  var charStr = '';\\n  // if our last write ended with an incomplete multibyte character\\n  while (this.charLength) {\\n    // determine how many remaining bytes this buffer has to offer for this char\\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\\n        this.charLength - this.charReceived :\\n        buffer.length;\\n\\n    // add the new bytes to the char buffer\\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\\n    this.charReceived += available;\\n\\n    if (this.charReceived < this.charLength) {\\n      // still not enough chars in this buffer? wait for more ...\\n      return '';\\n    }\\n\\n    // remove bytes belonging to the current character from the buffer\\n    buffer = buffer.slice(available, buffer.length);\\n\\n    // get the character that was split\\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\\n\\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\n    var charCode = charStr.charCodeAt(charStr.length - 1);\\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\n      this.charLength += this.surrogateSize;\\n      charStr = '';\\n      continue;\\n    }\\n    this.charReceived = this.charLength = 0;\\n\\n    // if there are no more bytes in this buffer, just emit our char\\n    if (buffer.length === 0) {\\n      return charStr;\\n    }\\n    break;\\n  }\\n\\n  // determine and set charLength / charReceived\\n  this.detectIncompleteChar(buffer);\\n\\n  var end = buffer.length;\\n  if (this.charLength) {\\n    // buffer the incomplete character bytes we got\\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\\n    end -= this.charReceived;\\n  }\\n\\n  charStr += buffer.toString(this.encoding, 0, end);\\n\\n  var end = charStr.length - 1;\\n  var charCode = charStr.charCodeAt(end);\\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\n    var size = this.surrogateSize;\\n    this.charLength += size;\\n    this.charReceived += size;\\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\\n    buffer.copy(this.charBuffer, 0, 0, size);\\n    return charStr.substring(0, end);\\n  }\\n\\n  // or just emit the charStr\\n  return charStr;\\n};\\n\\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\\n// the end of the given buffer. If so, it sets this.charLength to the byte\\n// length that character, and sets this.charReceived to the number of bytes\\n// that are available for this character.\\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\\n  // determine how many bytes we have to check at the end of this buffer\\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\\n\\n  // Figure out if one of the last i bytes of our buffer announces an\\n  // incomplete char.\\n  for (; i > 0; i--) {\\n    var c = buffer[buffer.length - i];\\n\\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\\n\\n    // 110XXXXX\\n    if (i == 1 && c >> 5 == 0x06) {\\n      this.charLength = 2;\\n      break;\\n    }\\n\\n    // 1110XXXX\\n    if (i <= 2 && c >> 4 == 0x0E) {\\n      this.charLength = 3;\\n      break;\\n    }\\n\\n    // 11110XXX\\n    if (i <= 3 && c >> 3 == 0x1E) {\\n      this.charLength = 4;\\n      break;\\n    }\\n  }\\n  this.charReceived = i;\\n};\\n\\nStringDecoder.prototype.end = function(buffer) {\\n  var res = '';\\n  if (buffer && buffer.length)\\n    res = this.write(buffer);\\n\\n  if (this.charReceived) {\\n    var cr = this.charReceived;\\n    var buf = this.charBuffer;\\n    var enc = this.encoding;\\n    res += buf.slice(0, cr).toString(enc);\\n  }\\n\\n  return res;\\n};\\n\\nfunction passThroughWrite(buffer) {\\n  return buffer.toString(this.encoding);\\n}\\n\\nfunction utf16DetectIncompleteChar(buffer) {\\n  this.charReceived = buffer.length % 2;\\n  this.charLength = this.charReceived ? 2 : 0;\\n}\\n\\nfunction base64DetectIncompleteChar(buffer) {\\n  this.charReceived = buffer.length % 3;\\n  this.charLength = this.charReceived ? 3 : 0;\\n}\\n\\n},{\\\"buffer\\\":45}],72:[function(require,module,exports){\\n\\n/**\\n * Expose `toIsoString`.\\n */\\n\\nmodule.exports = toIsoString;\\n\\n\\n/**\\n * Turn a `date` into an ISO string.\\n *\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\\n *\\n * @param {Date} date\\n * @return {String}\\n */\\n\\nfunction toIsoString (date) {\\n  return date.getUTCFullYear()\\n    + '-' + pad(date.getUTCMonth() + 1)\\n    + '-' + pad(date.getUTCDate())\\n    + 'T' + pad(date.getUTCHours())\\n    + ':' + pad(date.getUTCMinutes())\\n    + ':' + pad(date.getUTCSeconds())\\n    + '.' + String((date.getUTCMilliseconds()/1000).toFixed(3)).slice(2, 5)\\n    + 'Z';\\n}\\n\\n\\n/**\\n * Pad a `number` with a ten's place zero.\\n *\\n * @param {Number} number\\n * @return {String}\\n */\\n\\nfunction pad (number) {\\n  var n = number.toString();\\n  return n.length === 1 ? '0' + n : n;\\n}\\n},{}],73:[function(require,module,exports){\\n(function (global){\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = deprecate;\\n\\n/**\\n * Mark that a method should not be used.\\n * Returns a modified function which warns once by default.\\n *\\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\\n *\\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\\n * will throw an Error when invoked.\\n *\\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\\n * will invoke `console.trace()` instead of `console.error()`.\\n *\\n * @param {Function} fn - the function to deprecate\\n * @param {String} msg - the string to print to the console when `fn` is invoked\\n * @returns {Function} a new \\\"deprecated\\\" version of `fn`\\n * @api public\\n */\\n\\nfunction deprecate (fn, msg) {\\n  if (config('noDeprecation')) {\\n    return fn;\\n  }\\n\\n  var warned = false;\\n  function deprecated() {\\n    if (!warned) {\\n      if (config('throwDeprecation')) {\\n        throw new Error(msg);\\n      } else if (config('traceDeprecation')) {\\n        console.trace(msg);\\n      } else {\\n        console.warn(msg);\\n      }\\n      warned = true;\\n    }\\n    return fn.apply(this, arguments);\\n  }\\n\\n  return deprecated;\\n}\\n\\n/**\\n * Checks `localStorage` for boolean values for the given `name`.\\n *\\n * @param {String} name\\n * @returns {Boolean}\\n * @api private\\n */\\n\\nfunction config (name) {\\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\\n  try {\\n    if (!global.localStorage) return false;\\n  } catch (_) {\\n    return false;\\n  }\\n  var val = global.localStorage[name];\\n  if (null == val) return false;\\n  return String(val).toLowerCase() === 'true';\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],74:[function(require,module,exports){\\nmodule.exports = function isBuffer(arg) {\\n  return arg && typeof arg === 'object'\\n    && typeof arg.copy === 'function'\\n    && typeof arg.fill === 'function'\\n    && typeof arg.readUInt8 === 'function';\\n}\\n},{}],75:[function(require,module,exports){\\n(function (process,global){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar formatRegExp = /%[sdj%]/g;\\nexports.format = function(f) {\\n  if (!isString(f)) {\\n    var objects = [];\\n    for (var i = 0; i < arguments.length; i++) {\\n      objects.push(inspect(arguments[i]));\\n    }\\n    return objects.join(' ');\\n  }\\n\\n  var i = 1;\\n  var args = arguments;\\n  var len = args.length;\\n  var str = String(f).replace(formatRegExp, function(x) {\\n    if (x === '%%') return '%';\\n    if (i >= len) return x;\\n    switch (x) {\\n      case '%s': return String(args[i++]);\\n      case '%d': return Number(args[i++]);\\n      case '%j':\\n        try {\\n          return JSON.stringify(args[i++]);\\n        } catch (_) {\\n          return '[Circular]';\\n        }\\n      default:\\n        return x;\\n    }\\n  });\\n  for (var x = args[i]; i < len; x = args[++i]) {\\n    if (isNull(x) || !isObject(x)) {\\n      str += ' ' + x;\\n    } else {\\n      str += ' ' + inspect(x);\\n    }\\n  }\\n  return str;\\n};\\n\\n\\n// Mark that a method should not be used.\\n// Returns a modified function which warns once by default.\\n// If --no-deprecation is set, then it is a no-op.\\nexports.deprecate = function(fn, msg) {\\n  // Allow for deprecating things in the process of starting up.\\n  if (isUndefined(global.process)) {\\n    return function() {\\n      return exports.deprecate(fn, msg).apply(this, arguments);\\n    };\\n  }\\n\\n  if (process.noDeprecation === true) {\\n    return fn;\\n  }\\n\\n  var warned = false;\\n  function deprecated() {\\n    if (!warned) {\\n      if (process.throwDeprecation) {\\n        throw new Error(msg);\\n      } else if (process.traceDeprecation) {\\n        console.trace(msg);\\n      } else {\\n        console.error(msg);\\n      }\\n      warned = true;\\n    }\\n    return fn.apply(this, arguments);\\n  }\\n\\n  return deprecated;\\n};\\n\\n\\nvar debugs = {};\\nvar debugEnviron;\\nexports.debuglog = function(set) {\\n  if (isUndefined(debugEnviron))\\n    debugEnviron = process.env.NODE_DEBUG || '';\\n  set = set.toUpperCase();\\n  if (!debugs[set]) {\\n    if (new RegExp('\\\\\\\\b' + set + '\\\\\\\\b', 'i').test(debugEnviron)) {\\n      var pid = process.pid;\\n      debugs[set] = function() {\\n        var msg = exports.format.apply(exports, arguments);\\n        console.error('%s %d: %s', set, pid, msg);\\n      };\\n    } else {\\n      debugs[set] = function() {};\\n    }\\n  }\\n  return debugs[set];\\n};\\n\\n\\n/**\\n * Echos the value of a value. Trys to print the value out\\n * in the best way possible given the different types.\\n *\\n * @param {Object} obj The object to print out.\\n * @param {Object} opts Optional options object that alters the output.\\n */\\n/* legacy: obj, showHidden, depth, colors*/\\nfunction inspect(obj, opts) {\\n  // default options\\n  var ctx = {\\n    seen: [],\\n    stylize: stylizeNoColor\\n  };\\n  // legacy...\\n  if (arguments.length >= 3) ctx.depth = arguments[2];\\n  if (arguments.length >= 4) ctx.colors = arguments[3];\\n  if (isBoolean(opts)) {\\n    // legacy...\\n    ctx.showHidden = opts;\\n  } else if (opts) {\\n    // got an \\\"options\\\" object\\n    exports._extend(ctx, opts);\\n  }\\n  // set default options\\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\\n  if (isUndefined(ctx.colors)) ctx.colors = false;\\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\n  return formatValue(ctx, obj, ctx.depth);\\n}\\nexports.inspect = inspect;\\n\\n\\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\ninspect.colors = {\\n  'bold' : [1, 22],\\n  'italic' : [3, 23],\\n  'underline' : [4, 24],\\n  'inverse' : [7, 27],\\n  'white' : [37, 39],\\n  'grey' : [90, 39],\\n  'black' : [30, 39],\\n  'blue' : [34, 39],\\n  'cyan' : [36, 39],\\n  'green' : [32, 39],\\n  'magenta' : [35, 39],\\n  'red' : [31, 39],\\n  'yellow' : [33, 39]\\n};\\n\\n// Don't use 'blue' not visible on cmd.exe\\ninspect.styles = {\\n  'special': 'cyan',\\n  'number': 'yellow',\\n  'boolean': 'yellow',\\n  'undefined': 'grey',\\n  'null': 'bold',\\n  'string': 'green',\\n  'date': 'magenta',\\n  // \\\"name\\\": intentionally not styling\\n  'regexp': 'red'\\n};\\n\\n\\nfunction stylizeWithColor(str, styleType) {\\n  var style = inspect.styles[styleType];\\n\\n  if (style) {\\n    return '\\\\u001b[' + inspect.colors[style][0] + 'm' + str +\\n           '\\\\u001b[' + inspect.colors[style][1] + 'm';\\n  } else {\\n    return str;\\n  }\\n}\\n\\n\\nfunction stylizeNoColor(str, styleType) {\\n  return str;\\n}\\n\\n\\nfunction arrayToHash(array) {\\n  var hash = {};\\n\\n  array.forEach(function(val, idx) {\\n    hash[val] = true;\\n  });\\n\\n  return hash;\\n}\\n\\n\\nfunction formatValue(ctx, value, recurseTimes) {\\n  // Provide a hook for user-specified inspect functions.\\n  // Check that value is an object with an inspect function on it\\n  if (ctx.customInspect &&\\n      value &&\\n      isFunction(value.inspect) &&\\n      // Filter out the util module, it's inspect function is special\\n      value.inspect !== exports.inspect &&\\n      // Also filter out any prototype objects using the circular check.\\n      !(value.constructor && value.constructor.prototype === value)) {\\n    var ret = value.inspect(recurseTimes, ctx);\\n    if (!isString(ret)) {\\n      ret = formatValue(ctx, ret, recurseTimes);\\n    }\\n    return ret;\\n  }\\n\\n  // Primitive types cannot have properties\\n  var primitive = formatPrimitive(ctx, value);\\n  if (primitive) {\\n    return primitive;\\n  }\\n\\n  // Look up the keys of the object.\\n  var keys = Object.keys(value);\\n  var visibleKeys = arrayToHash(keys);\\n\\n  if (ctx.showHidden) {\\n    keys = Object.getOwnPropertyNames(value);\\n  }\\n\\n  // IE doesn't make error fields non-enumerable\\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\\n  if (isError(value)\\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\\n    return formatError(value);\\n  }\\n\\n  // Some type of object without properties can be shortcutted.\\n  if (keys.length === 0) {\\n    if (isFunction(value)) {\\n      var name = value.name ? ': ' + value.name : '';\\n      return ctx.stylize('[Function' + name + ']', 'special');\\n    }\\n    if (isRegExp(value)) {\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\n    }\\n    if (isDate(value)) {\\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\\n    }\\n    if (isError(value)) {\\n      return formatError(value);\\n    }\\n  }\\n\\n  var base = '', array = false, braces = ['{', '}'];\\n\\n  // Make Array say that they are Array\\n  if (isArray(value)) {\\n    array = true;\\n    braces = ['[', ']'];\\n  }\\n\\n  // Make functions say that they are functions\\n  if (isFunction(value)) {\\n    var n = value.name ? ': ' + value.name : '';\\n    base = ' [Function' + n + ']';\\n  }\\n\\n  // Make RegExps say that they are RegExps\\n  if (isRegExp(value)) {\\n    base = ' ' + RegExp.prototype.toString.call(value);\\n  }\\n\\n  // Make dates with properties first say the date\\n  if (isDate(value)) {\\n    base = ' ' + Date.prototype.toUTCString.call(value);\\n  }\\n\\n  // Make error with message first say the error\\n  if (isError(value)) {\\n    base = ' ' + formatError(value);\\n  }\\n\\n  if (keys.length === 0 && (!array || value.length == 0)) {\\n    return braces[0] + base + braces[1];\\n  }\\n\\n  if (recurseTimes < 0) {\\n    if (isRegExp(value)) {\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\n    } else {\\n      return ctx.stylize('[Object]', 'special');\\n    }\\n  }\\n\\n  ctx.seen.push(value);\\n\\n  var output;\\n  if (array) {\\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\\n  } else {\\n    output = keys.map(function(key) {\\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\\n    });\\n  }\\n\\n  ctx.seen.pop();\\n\\n  return reduceToSingleString(output, base, braces);\\n}\\n\\n\\nfunction formatPrimitive(ctx, value) {\\n  if (isUndefined(value))\\n    return ctx.stylize('undefined', 'undefined');\\n  if (isString(value)) {\\n    var simple = '\\\\'' + JSON.stringify(value).replace(/^\\\"|\\\"$/g, '')\\n                                             .replace(/'/g, \\\"\\\\\\\\'\\\")\\n                                             .replace(/\\\\\\\\\\\"/g, '\\\"') + '\\\\'';\\n    return ctx.stylize(simple, 'string');\\n  }\\n  if (isNumber(value))\\n    return ctx.stylize('' + value, 'number');\\n  if (isBoolean(value))\\n    return ctx.stylize('' + value, 'boolean');\\n  // For some reason typeof null is \\\"object\\\", so special case here.\\n  if (isNull(value))\\n    return ctx.stylize('null', 'null');\\n}\\n\\n\\nfunction formatError(value) {\\n  return '[' + Error.prototype.toString.call(value) + ']';\\n}\\n\\n\\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\\n  var output = [];\\n  for (var i = 0, l = value.length; i < l; ++i) {\\n    if (hasOwnProperty(value, String(i))) {\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\n          String(i), true));\\n    } else {\\n      output.push('');\\n    }\\n  }\\n  keys.forEach(function(key) {\\n    if (!key.match(/^\\\\d+$/)) {\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\n          key, true));\\n    }\\n  });\\n  return output;\\n}\\n\\n\\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\\n  var name, str, desc;\\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\\n  if (desc.get) {\\n    if (desc.set) {\\n      str = ctx.stylize('[Getter/Setter]', 'special');\\n    } else {\\n      str = ctx.stylize('[Getter]', 'special');\\n    }\\n  } else {\\n    if (desc.set) {\\n      str = ctx.stylize('[Setter]', 'special');\\n    }\\n  }\\n  if (!hasOwnProperty(visibleKeys, key)) {\\n    name = '[' + key + ']';\\n  }\\n  if (!str) {\\n    if (ctx.seen.indexOf(desc.value) < 0) {\\n      if (isNull(recurseTimes)) {\\n        str = formatValue(ctx, desc.value, null);\\n      } else {\\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\\n      }\\n      if (str.indexOf('\\\\n') > -1) {\\n        if (array) {\\n          str = str.split('\\\\n').map(function(line) {\\n            return '  ' + line;\\n          }).join('\\\\n').substr(2);\\n        } else {\\n          str = '\\\\n' + str.split('\\\\n').map(function(line) {\\n            return '   ' + line;\\n          }).join('\\\\n');\\n        }\\n      }\\n    } else {\\n      str = ctx.stylize('[Circular]', 'special');\\n    }\\n  }\\n  if (isUndefined(name)) {\\n    if (array && key.match(/^\\\\d+$/)) {\\n      return str;\\n    }\\n    name = JSON.stringify('' + key);\\n    if (name.match(/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)) {\\n      name = name.substr(1, name.length - 2);\\n      name = ctx.stylize(name, 'name');\\n    } else {\\n      name = name.replace(/'/g, \\\"\\\\\\\\'\\\")\\n                 .replace(/\\\\\\\\\\\"/g, '\\\"')\\n                 .replace(/(^\\\"|\\\"$)/g, \\\"'\\\");\\n      name = ctx.stylize(name, 'string');\\n    }\\n  }\\n\\n  return name + ': ' + str;\\n}\\n\\n\\nfunction reduceToSingleString(output, base, braces) {\\n  var numLinesEst = 0;\\n  var length = output.reduce(function(prev, cur) {\\n    numLinesEst++;\\n    if (cur.indexOf('\\\\n') >= 0) numLinesEst++;\\n    return prev + cur.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, '').length + 1;\\n  }, 0);\\n\\n  if (length > 60) {\\n    return braces[0] +\\n           (base === '' ? '' : base + '\\\\n ') +\\n           ' ' +\\n           output.join(',\\\\n  ') +\\n           ' ' +\\n           braces[1];\\n  }\\n\\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\\n}\\n\\n\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\n// because it is fragile and can be easily faked with `Object.create()`.\\nfunction isArray(ar) {\\n  return Array.isArray(ar);\\n}\\nexports.isArray = isArray;\\n\\nfunction isBoolean(arg) {\\n  return typeof arg === 'boolean';\\n}\\nexports.isBoolean = isBoolean;\\n\\nfunction isNull(arg) {\\n  return arg === null;\\n}\\nexports.isNull = isNull;\\n\\nfunction isNullOrUndefined(arg) {\\n  return arg == null;\\n}\\nexports.isNullOrUndefined = isNullOrUndefined;\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\nexports.isNumber = isNumber;\\n\\nfunction isString(arg) {\\n  return typeof arg === 'string';\\n}\\nexports.isString = isString;\\n\\nfunction isSymbol(arg) {\\n  return typeof arg === 'symbol';\\n}\\nexports.isSymbol = isSymbol;\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\nexports.isUndefined = isUndefined;\\n\\nfunction isRegExp(re) {\\n  return isObject(re) && objectToString(re) === '[object RegExp]';\\n}\\nexports.isRegExp = isRegExp;\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\nexports.isObject = isObject;\\n\\nfunction isDate(d) {\\n  return isObject(d) && objectToString(d) === '[object Date]';\\n}\\nexports.isDate = isDate;\\n\\nfunction isError(e) {\\n  return isObject(e) &&\\n      (objectToString(e) === '[object Error]' || e instanceof Error);\\n}\\nexports.isError = isError;\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\nexports.isFunction = isFunction;\\n\\nfunction isPrimitive(arg) {\\n  return arg === null ||\\n         typeof arg === 'boolean' ||\\n         typeof arg === 'number' ||\\n         typeof arg === 'string' ||\\n         typeof arg === 'symbol' ||  // ES6 symbol\\n         typeof arg === 'undefined';\\n}\\nexports.isPrimitive = isPrimitive;\\n\\nexports.isBuffer = require('./support/isBuffer');\\n\\nfunction objectToString(o) {\\n  return Object.prototype.toString.call(o);\\n}\\n\\n\\nfunction pad(n) {\\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\\n}\\n\\n\\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\\n              'Oct', 'Nov', 'Dec'];\\n\\n// 26 Feb 16:19:34\\nfunction timestamp() {\\n  var d = new Date();\\n  var time = [pad(d.getHours()),\\n              pad(d.getMinutes()),\\n              pad(d.getSeconds())].join(':');\\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\\n}\\n\\n\\n// log is just a thin wrapper to console.log that prepends a timestamp\\nexports.log = function() {\\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\\n};\\n\\n\\n/**\\n * Inherit the prototype methods from one constructor into another.\\n *\\n * The Function.prototype.inherits from lang.js rewritten as a standalone\\n * function (not on Function.prototype). NOTE: If this file is to be loaded\\n * during bootstrapping this function needs to be rewritten using some native\\n * functions as prototype setup using normal JavaScript does not work as\\n * expected during bootstrapping (see mirror.js in r114903).\\n *\\n * @param {function} ctor Constructor function which needs to inherit the\\n *     prototype.\\n * @param {function} superCtor Constructor function to inherit prototype from.\\n */\\nexports.inherits = require('inherits');\\n\\nexports._extend = function(origin, add) {\\n  // Don't do anything if add isn't an object\\n  if (!add || !isObject(add)) return origin;\\n\\n  var keys = Object.keys(add);\\n  var i = keys.length;\\n  while (i--) {\\n    origin[keys[i]] = add[keys[i]];\\n  }\\n  return origin;\\n};\\n\\nfunction hasOwnProperty(obj, prop) {\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./support/isBuffer\\\":74,\\\"_process\\\":58,\\\"inherits\\\":53}]},{},[1]);\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS9tb2NoYS5qcz9jYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVxcXCJmdW5jdGlvblxcXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIitvK1xcXCInXFxcIik7dGhyb3cgZi5jb2RlPVxcXCJNT0RVTEVfTk9UX0ZPVU5EXFxcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVxcXCJmdW5jdGlvblxcXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vKipcXG4gKiBTaGltIHByb2Nlc3Muc3Rkb3V0LlxcbiAqL1xcblxcbnByb2Nlc3Muc3Rkb3V0ID0gcmVxdWlyZSgnYnJvd3Nlci1zdGRvdXQnKSgpO1xcblxcbnZhciBNb2NoYSA9IHJlcXVpcmUoJy4vbGliL21vY2hhJyk7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgTW9jaGEgaW5zdGFuY2UuXFxuICpcXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XFxuICovXFxuXFxudmFyIG1vY2hhID0gbmV3IE1vY2hhKHsgcmVwb3J0ZXI6ICdodG1sJyB9KTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG5cXG52YXIgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycyA9IFtdO1xcblxcbnZhciBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyID0gZ2xvYmFsLm9uZXJyb3I7XFxuXFxuLyoqXFxuICogUmVtb3ZlIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxcbiAqIFJldmVydCB0byBvcmlnaW5hbCBvbmVycm9yIGhhbmRsZXIgaWYgcHJldmlvdXNseSBkZWZpbmVkLlxcbiAqL1xcblxcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihlLCBmbil7XFxuICBpZiAoJ3VuY2F1Z2h0RXhjZXB0aW9uJyA9PSBlKSB7XFxuICAgIGlmIChvcmlnaW5hbE9uZXJyb3JIYW5kbGVyKSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgfVxcbiAgICB2YXIgaSA9IE1vY2hhLnV0aWxzLmluZGV4T2YodW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycywgZm4pO1xcbiAgICBpZiAoaSAhPSAtMSkgeyB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLnNwbGljZShpLCAxKTsgfVxcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSW1wbGVtZW50cyB1bmNhdWdodEV4Y2VwdGlvbiBsaXN0ZW5lci5cXG4gKi9cXG5cXG5wcm9jZXNzLm9uID0gZnVuY3Rpb24oZSwgZm4pe1xcbiAgaWYgKCd1bmNhdWdodEV4Y2VwdGlvbicgPT0gZSkge1xcbiAgICBnbG9iYWwub25lcnJvciA9IGZ1bmN0aW9uKGVyciwgdXJsLCBsaW5lKXtcXG4gICAgICBmbihuZXcgRXJyb3IoZXJyICsgJyAoJyArIHVybCArICc6JyArIGxpbmUgKyAnKScpKTtcXG4gICAgICByZXR1cm4gIW1vY2hhLmFsbG93VW5jYXVnaHQ7XFxuICAgIH07XFxuICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMucHVzaChmbik7XFxuICB9XFxufTtcXG5cXG4vLyBUaGUgQkREIFVJIGlzIHJlZ2lzdGVyZWQgYnkgZGVmYXVsdCwgYnV0IG5vIFVJIHdpbGwgYmUgZnVuY3Rpb25hbCBpbiB0aGVcXG4vLyBicm93c2VyIHdpdGhvdXQgYW4gZXhwbGljaXQgY2FsbCB0byB0aGUgb3ZlcnJpZGRlbiBgbW9jaGEudWlgIChzZWUgYmVsb3cpLlxcbi8vIEVuc3VyZSB0aGF0IHRoaXMgZGVmYXVsdCBVSSBkb2VzIG5vdCBleHBvc2UgaXRzIG1ldGhvZHMgdG8gdGhlIGdsb2JhbCBzY29wZS5cXG5tb2NoYS5zdWl0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ByZS1yZXF1aXJlJyk7XFxuXFxudmFyIGltbWVkaWF0ZVF1ZXVlID0gW11cXG4gICwgaW1tZWRpYXRlVGltZW91dDtcXG5cXG5mdW5jdGlvbiB0aW1lc2xpY2UoKSB7XFxuICB2YXIgaW1tZWRpYXRlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gaW1tZWRpYXRlU3RhcnQpIDwgMTAwKSB7XFxuICAgIGltbWVkaWF0ZVF1ZXVlLnNoaWZ0KCkoKTtcXG4gIH1cXG4gIGlmIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGgpIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcXG4gIH0gZWxzZSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBudWxsO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBIaWdoLXBlcmZvcm1hbmNlIG92ZXJyaWRlIG9mIFJ1bm5lci5pbW1lZGlhdGVseS5cXG4gKi9cXG5cXG5Nb2NoYS5SdW5uZXIuaW1tZWRpYXRlbHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xcbiAgaW1tZWRpYXRlUXVldWUucHVzaChjYWxsYmFjayk7XFxuICBpZiAoIWltbWVkaWF0ZVRpbWVvdXQpIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZ1bmN0aW9uIHRvIGFsbG93IGFzc2VydGlvbiBsaWJyYXJpZXMgdG8gdGhyb3cgZXJyb3JzIGRpcmVjdGx5IGludG8gbW9jaGEuXFxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiBydW5uaW5nIHRlc3RzIGluIGEgYnJvd3NlciBiZWNhdXNlIHdpbmRvdy5vbmVycm9yIHdpbGxcXG4gKiBvbmx5IHJlY2VpdmUgdGhlICdtZXNzYWdlJyBhdHRyaWJ1dGUgb2YgdGhlIEVycm9yLlxcbiAqL1xcbm1vY2hhLnRocm93RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcXG4gIE1vY2hhLnV0aWxzLmZvckVhY2godW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycywgZnVuY3Rpb24gKGZuKSB7XFxuICAgIGZuKGVycik7XFxuICB9KTtcXG4gIHRocm93IGVycjtcXG59O1xcblxcbi8qKlxcbiAqIE92ZXJyaWRlIHVpIHRvIGVuc3VyZSB0aGF0IHRoZSB1aSBmdW5jdGlvbnMgYXJlIGluaXRpYWxpemVkLlxcbiAqIE5vcm1hbGx5IHRoaXMgd291bGQgaGFwcGVuIGluIE1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMuXFxuICovXFxuXFxubW9jaGEudWkgPSBmdW5jdGlvbih1aSl7XFxuICBNb2NoYS5wcm90b3R5cGUudWkuY2FsbCh0aGlzLCB1aSk7XFxuICB0aGlzLnN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBudWxsLCB0aGlzKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0dXAgbW9jaGEgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZyBvcHRpb25zLlxcbiAqL1xcblxcbm1vY2hhLnNldHVwID0gZnVuY3Rpb24ob3B0cyl7XFxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9wdHMpIG9wdHMgPSB7IHVpOiBvcHRzIH07XFxuICBmb3IgKHZhciBvcHQgaW4gb3B0cykgdGhpc1tvcHRdKG9wdHNbb3B0XSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBtb2NoYSwgcmV0dXJuaW5nIHRoZSBSdW5uZXIuXFxuICovXFxuXFxubW9jaGEucnVuID0gZnVuY3Rpb24oZm4pe1xcbiAgdmFyIG9wdGlvbnMgPSBtb2NoYS5vcHRpb25zO1xcbiAgbW9jaGEuZ2xvYmFscygnbG9jYXRpb24nKTtcXG5cXG4gIHZhciBxdWVyeSA9IE1vY2hhLnV0aWxzLnBhcnNlUXVlcnkoZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCB8fCAnJyk7XFxuICBpZiAocXVlcnkuZ3JlcCkgbW9jaGEuZ3JlcChuZXcgUmVnRXhwKHF1ZXJ5LmdyZXApKTtcXG4gIGlmIChxdWVyeS5mZ3JlcCkgbW9jaGEuZ3JlcChxdWVyeS5mZ3JlcCk7XFxuICBpZiAocXVlcnkuaW52ZXJ0KSBtb2NoYS5pbnZlcnQoKTtcXG5cXG4gIHJldHVybiBNb2NoYS5wcm90b3R5cGUucnVuLmNhbGwobW9jaGEsIGZ1bmN0aW9uKGVycil7XFxuICAgIC8vIFRoZSBET00gRG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZSBpbiBXZWIgV29ya2Vycy5cXG4gICAgdmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xcbiAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykgJiYgb3B0aW9ucy5ub0hpZ2hsaWdodGluZyAhPT0gdHJ1ZSkge1xcbiAgICAgIE1vY2hhLnV0aWxzLmhpZ2hsaWdodFRhZ3MoJ2NvZGUnKTtcXG4gICAgfVxcbiAgICBpZiAoZm4pIGZuKGVycik7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0aGUgcHJvY2VzcyBzaGltLlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvOTE2XFxuICovXFxuXFxuTW9jaGEucHJvY2VzcyA9IHByb2Nlc3M7XFxuXFxuLyoqXFxuICogRXhwb3NlIG1vY2hhLlxcbiAqL1xcblxcbmdsb2JhbC5Nb2NoYSA9IE1vY2hhO1xcbmdsb2JhbC5tb2NoYSA9IG1vY2hhO1xcblxcbi8vIHRoaXMgYWxsb3dzIHRlc3QvYWNjZXB0YW5jZS9yZXF1aXJlZC10b2tlbnMuanMgdG8gcGFzczsgdGh1cyxcXG4vLyB5b3UgY2FuIG5vdyBkbyBgY29uc3QgZGVzY3JpYmUgPSByZXF1aXJlKCdtb2NoYScpLmRlc2NyaWJlYCBpbiBhXFxuLy8gYnJvd3NlciBjb250ZXh0IChhc3N1bWluZyBicm93c2VyaWZpY2F0aW9uKS4gIHNob3VsZCBmaXggIzg4MFxcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbGliL21vY2hhXFxcIjoxNCxcXFwiX3Byb2Nlc3NcXFwiOjU4LFxcXCJicm93c2VyLXN0ZG91dFxcXCI6NDJ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHlwZSkge1xcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge307XFxufTtcXG5cXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBNb2R1bGUgZXhwb3J0cy5cXG4gKi9cXG5cXG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0LlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LCBvdGhlcndpc2UgZmFsc2UuXFxuICovXFxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcXG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufVxcblxcbi8qKlxcbiAqIEV2ZW50IGVtaXR0ZXIgY29uc3RydWN0b3IuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XFxuXFxuLyoqXFxuICogQWRkIGEgbGlzdGVuZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlci5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICBpZiAoIXRoaXMuJGV2ZW50cykge1xcbiAgICB0aGlzLiRldmVudHMgPSB7fTtcXG4gIH1cXG5cXG4gIGlmICghdGhpcy4kZXZlbnRzW25hbWVdKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IGZuO1xcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRoaXMuJGV2ZW50c1tuYW1lXSkpIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdLnB1c2goZm4pO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdID0gW3RoaXMuJGV2ZW50c1tuYW1lXSwgZm5dO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcXG5cXG4vKipcXG4gKiBBZGRzIGEgdm9sYXRpbGUgbGlzdGVuZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlci5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG9uKCkge1xcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKG5hbWUsIG9uKTtcXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIG9uLmxpc3RlbmVyID0gZm47XFxuICB0aGlzLm9uKG5hbWUsIG9uKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmVtb3ZlIGEgbGlzdGVuZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlci5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICBpZiAodGhpcy4kZXZlbnRzICYmIHRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB2YXIgbGlzdCA9IHRoaXMuJGV2ZW50c1tuYW1lXTtcXG5cXG4gICAgaWYgKGlzQXJyYXkobGlzdCkpIHtcXG4gICAgICB2YXIgcG9zID0gLTE7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGZuIHx8IChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGZuKSkge1xcbiAgICAgICAgICBwb3MgPSBpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBvcyA8IDApIHtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH1cXG5cXG4gICAgICBsaXN0LnNwbGljZShwb3MsIDEpO1xcblxcbiAgICAgIGlmICghbGlzdC5sZW5ndGgpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLiRldmVudHNbbmFtZV07XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGxpc3QgPT09IGZuIHx8IChsaXN0Lmxpc3RlbmVyICYmIGxpc3QubGlzdGVuZXIgPT09IGZuKSkge1xcbiAgICAgIGRlbGV0ZSB0aGlzLiRldmVudHNbbmFtZV07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGFuIGV2ZW50LlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKG5hbWUpIHtcXG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpcy4kZXZlbnRzID0ge307XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuJGV2ZW50cyAmJiB0aGlzLiRldmVudHNbbmFtZV0pIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdID0gbnVsbDtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGFsbCBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBFbWl0dGVyIGluc3RhbmNlLlxcbiAqL1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSkge1xcbiAgaWYgKCF0aGlzLiRldmVudHMpIHtcXG4gICAgdGhpcy4kZXZlbnRzID0ge307XFxuICB9XFxuXFxuICBpZiAoIXRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0gPSBbXTtcXG4gIH1cXG5cXG4gIGlmICghaXNBcnJheSh0aGlzLiRldmVudHNbbmFtZV0pKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IFt0aGlzLiRldmVudHNbbmFtZV1dO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuJGV2ZW50c1tuYW1lXTtcXG59O1xcblxcbi8qKlxcbiAqIEVtaXQgYW4gZXZlbnQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgaGFuZGxlciB3YXMgaW52b2tlZCwgZWxzZSBmYWxzZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihuYW1lKSB7XFxuICBpZiAoIXRoaXMuJGV2ZW50cykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgaGFuZGxlciA9IHRoaXMuJGV2ZW50c1tuYW1lXTtcXG5cXG4gIGlmICghaGFuZGxlcikge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuXFxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xcbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xcblxcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogRXhwb3NlIGBQcm9ncmVzc2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQcm9ncmVzc2AgaW5kaWNhdG9yLlxcbiAqL1xcbmZ1bmN0aW9uIFByb2dyZXNzKCkge1xcbiAgdGhpcy5wZXJjZW50ID0gMDtcXG4gIHRoaXMuc2l6ZSgwKTtcXG4gIHRoaXMuZm9udFNpemUoMTEpO1xcbiAgdGhpcy5mb250KCdoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmJyk7XFxufVxcblxcbi8qKlxcbiAqIFNldCBwcm9ncmVzcyBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihzaXplKSB7XFxuICB0aGlzLl9zaXplID0gc2l6ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRleHQgdG8gYHRleHRgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcXG4gIHRoaXMuX3RleHQgPSB0ZXh0O1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xcbiAgdGhpcy5fZm9udFNpemUgPSBzaXplO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCB0byBgZmFtaWx5YC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHlcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnQgPSBmdW5jdGlvbihmYW1pbHkpIHtcXG4gIHRoaXMuX2ZvbnQgPSBmYW1pbHk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVwZGF0ZSBwZXJjZW50YWdlIHRvIGBuYC5cXG4gKlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihuKSB7XFxuICB0aGlzLnBlcmNlbnQgPSBuO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG9uIGBjdHhgLlxcbiAqXFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCkge1xcbiAgdHJ5IHtcXG4gICAgdmFyIHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLnBlcmNlbnQsIDEwMCk7XFxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcXG4gICAgdmFyIGhhbGYgPSBzaXplIC8gMjtcXG4gICAgdmFyIHggPSBoYWxmO1xcbiAgICB2YXIgeSA9IGhhbGY7XFxuICAgIHZhciByYWQgPSBoYWxmIC0gMTtcXG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XFxuXFxuICAgIGN0eC5mb250ID0gZm9udFNpemUgKyAncHggJyArIHRoaXMuX2ZvbnQ7XFxuXFxuICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyICogKHBlcmNlbnQgLyAxMDApO1xcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xcblxcbiAgICAvLyBvdXRlciBjaXJjbGVcXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyM5ZjlmOWYnO1xcbiAgICBjdHguYmVnaW5QYXRoKCk7XFxuICAgIGN0eC5hcmMoeCwgeSwgcmFkLCAwLCBhbmdsZSwgZmFsc2UpO1xcbiAgICBjdHguc3Ryb2tlKCk7XFxuXFxuICAgIC8vIGlubmVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2VlZSc7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQgLSAxLCAwLCBhbmdsZSwgdHJ1ZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gdGV4dFxcbiAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQgfHwgKHBlcmNlbnQgfCAwKSArICclJztcXG4gICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XFxuXFxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4IC0gdyAvIDIgKyAxLCB5ICsgZm9udFNpemUgLyAyIC0gMSk7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgLy8gZG9uJ3QgZmFpbCBpZiB3ZSBjYW4ndCByZW5kZXIgcHJvZ3Jlc3NcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbmV4cG9ydHMuaXNhdHR5ID0gZnVuY3Rpb24gaXNhdHR5KCkge1xcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5leHBvcnRzLmdldFdpbmRvd1NpemUgPSBmdW5jdGlvbiBnZXRXaW5kb3dTaXplKCkge1xcbiAgaWYgKCdpbm5lckhlaWdodCcgaW4gZ2xvYmFsKSB7XFxuICAgIHJldHVybiBbZ2xvYmFsLmlubmVySGVpZ2h0LCBnbG9iYWwuaW5uZXJXaWR0aF07XFxuICB9XFxuICAvLyBJbiBhIFdlYiBXb3JrZXIsIHRoZSBET00gV2luZG93IGlzIG5vdCBhdmFpbGFibGUuXFxuICByZXR1cm4gWzY0MCwgNDgwXTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIEV4cG9zZSBgQ29udGV4dGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvbnRleHRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB0aGUgY29udGV4dCBgUnVubmFibGVgIHRvIGBydW5uYWJsZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1J1bm5hYmxlfSBydW5uYWJsZVxcbiAqIEByZXR1cm4ge0NvbnRleHR9XFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUucnVubmFibGUgPSBmdW5jdGlvbihydW5uYWJsZSkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9ydW5uYWJsZTtcXG4gIH1cXG4gIHRoaXMudGVzdCA9IHRoaXMuX3J1bm5hYmxlID0gcnVubmFibGU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IHRpbWVvdXQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24obXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQoKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS50aW1lb3V0KG1zKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgdGltZW91dCBgZW5hYmxlZGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbihlbmFibGVkKSB7XFxuICB0aGlzLnJ1bm5hYmxlKCkuZW5hYmxlVGltZW91dHMoZW5hYmxlZCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IHNsb3duZXNzIHRocmVzaG9sZCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbihtcykge1xcbiAgdGhpcy5ydW5uYWJsZSgpLnNsb3cobXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBNYXJrIGEgdGVzdCBhcyBza2lwcGVkLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbigpIHtcXG4gIHRoaXMucnVubmFibGUoKS5za2lwKCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFsbG93IGEgbnVtYmVyIG9mIHJldHJpZXMgb24gZmFpbGVkIHRlc3RzXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcygpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMobik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEluc3BlY3QgdGhlIGNvbnRleHQgdm9pZCBvZiBgLl9ydW5uYWJsZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMsIGZ1bmN0aW9uKGtleSwgdmFsKSB7XFxuICAgIHJldHVybiBrZXkgPT09ICdydW5uYWJsZScgfHwga2V5ID09PSAndGVzdCcgPyB1bmRlZmluZWQgOiB2YWw7XFxuICB9LCAyKTtcXG59O1xcblxcbn0se31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhvb2tgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gSG9vaztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIb29rYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBIb29rKHRpdGxlLCBmbikge1xcbiAgUnVubmFibGUuY2FsbCh0aGlzLCB0aXRsZSwgZm4pO1xcbiAgdGhpcy50eXBlID0gJ2hvb2snO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoSG9vaywgUnVubmFibGUpO1xcblxcbi8qKlxcbiAqIEdldCBvciBzZXQgdGhlIHRlc3QgYGVycmAuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbkhvb2sucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgZXJyID0gdGhpcy5fZXJyb3I7XFxuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcXG4gICAgcmV0dXJuIGVycjtcXG4gIH1cXG5cXG4gIHRoaXMuX2Vycm9yID0gZXJyO1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjM1LFxcXCIuL3V0aWxzXFxcIjozOX1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcblxcbi8qKlxcbiAqIEJERC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgIGRlc2NyaWJlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICBkZXNjcmliZSgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIC0xIHdoZW4gbm90IHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICAgIC8vIC4uLlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgICAgLy8gLi4uXFxuICogICAgICAgICAgfSk7XFxuICogICAgICAgIH0pO1xcbiAqICAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24oY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0KTtcXG5cXG4gICAgY29udGV4dC5iZWZvcmUgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC5hZnRlckVhY2ggPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYFxcbiAgICAgKiBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nIG5lc3RlZCBzdWl0ZXNcXG4gICAgICogYW5kL29yIHRlc3RzLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5kZXNjcmliZSA9IGNvbnRleHQuY29udGV4dCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIHRpdGxlKTtcXG4gICAgICBzdWl0ZS5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyBkZXNjcmliZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGRlc2NyaWJlID0gY29udGV4dC54Y29udGV4dCA9IGNvbnRleHQuZGVzY3JpYmUuc2tpcCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIHRpdGxlKTtcXG4gICAgICBzdWl0ZS5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgc3VpdGUuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBjb250ZXh0LmRlc2NyaWJlKHRpdGxlLCBmbik7XFxuICAgICAgbW9jaGEuZ3JlcChzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZVxcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG5cXG4gICAgdmFyIGl0ID0gY29udGV4dC5pdCA9IGNvbnRleHQuc3BlY2lmeSA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlc1swXTtcXG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIGZuID0gbnVsbDtcXG4gICAgICB9XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGUuYWRkVGVzdCh0ZXN0KTtcXG4gICAgICByZXR1cm4gdGVzdDtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0Lml0Lm9ubHkgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgdGVzdCA9IGl0KHRpdGxlLCBmbik7XFxuICAgICAgdmFyIHJlU3RyaW5nID0gJ14nICsgZXNjYXBlUmUodGVzdC5mdWxsVGl0bGUoKSkgKyAnJCc7XFxuICAgICAgbW9jaGEuZ3JlcChuZXcgUmVnRXhwKHJlU3RyaW5nKSk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGl0ID0gY29udGV4dC54c3BlY2lmeSA9IGNvbnRleHQuaXQuc2tpcCA9IGZ1bmN0aW9uKHRpdGxlKSB7XFxuICAgICAgY29udGV4dC5pdCh0aXRsZSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmV0cnkuXFxuICAgICAqL1xcbiAgICBjb250ZXh0Lml0LnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICAgICAgY29udGV4dC5yZXRyaWVzKG4pO1xcbiAgICB9O1xcbiAgfSk7XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM3LFxcXCIuLi90ZXN0XFxcIjozOCxcXFwiLi9jb21tb25cXFwiOjksXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo0OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBGdW5jdGlvbnMgY29tbW9uIHRvIG1vcmUgdGhhbiBvbmUgaW50ZXJmYWNlLlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZVtdfSBzdWl0ZXNcXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGNvbW1vbiBmdW5jdGlvbnMuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdWl0ZXMsIGNvbnRleHQpIHtcXG4gIHJldHVybiB7XFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIGlzIG9ubHkgcHJlc2VudCBpZiBmbGFnIC0tZGVsYXkgaXMgcGFzc2VkIGludG8gTW9jaGEuIEl0IHRyaWdnZXJzXFxuICAgICAqIHJvb3Qgc3VpdGUgZXhlY3V0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBUaGUgcm9vdCB3dWl0ZS5cXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gd2hpY2ggcnVucyB0aGUgcm9vdCBzdWl0ZVxcbiAgICAgKi9cXG4gICAgcnVuV2l0aFN1aXRlOiBmdW5jdGlvbiBydW5XaXRoU3VpdGUoc3VpdGUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcnVuKCkge1xcbiAgICAgICAgc3VpdGUucnVuKCk7XFxuICAgICAgfTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBiZWZvcmU6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmJlZm9yZUFsbChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGFmdGVyIHJ1bm5pbmcgdGVzdHMuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBhZnRlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJBbGwobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBiZWZvcmVFYWNoOiBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBhZnRlckVhY2g6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmFmdGVyRWFjaChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIHRlc3Q6IHtcXG4gICAgICAvKipcXG4gICAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAgICAgICAqL1xcbiAgICAgIHNraXA6IGZ1bmN0aW9uKHRpdGxlKSB7XFxuICAgICAgICBjb250ZXh0LnRlc3QodGl0bGUpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogTnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gblxcbiAgICAgICAqL1xcbiAgICAgIHJldHJpZXM6IGZ1bmN0aW9uKG4pIHtcXG4gICAgICAgIGNvbnRleHQucmV0cmllcyhuKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxufTtcXG5cXG59LHt9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIEV4cG9ydHMtc3R5bGUgKGFzIE5vZGUuanMgbW9kdWxlKSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgZXhwb3J0cy5BcnJheSA9IHtcXG4gKiAgICAgICAnI2luZGV4T2YoKSc6IHtcXG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIC0xIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50JzogZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgIH0sXFxuICpcXG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IGluZGV4IHdoZW4gdGhlIHZhbHVlIGlzIHByZXNlbnQnOiBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgfVxcbiAqICAgICAgIH1cXG4gKiAgICAgfTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncmVxdWlyZScsIHZpc2l0KTtcXG5cXG4gIGZ1bmN0aW9uIHZpc2l0KG9iaiwgZmlsZSkge1xcbiAgICB2YXIgc3VpdGU7XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB2YXIgZm4gPSBvYmpba2V5XTtcXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XFxuICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUFsbChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWZ0ZXJBbGwoZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdiZWZvcmVFYWNoJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYmVmb3JlRWFjaChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2FmdGVyRWFjaCc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyRWFjaChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdChrZXksIGZuKTtcXG4gICAgICAgICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIGtleSk7XFxuICAgICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgICB2aXNpdChvYmpba2V5XSwgZmlsZSk7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzcsXFxcIi4uL3Rlc3RcXFwiOjM4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMuYmRkID0gcmVxdWlyZSgnLi9iZGQnKTtcXG5leHBvcnRzLnRkZCA9IHJlcXVpcmUoJy4vdGRkJyk7XFxuZXhwb3J0cy5xdW5pdCA9IHJlcXVpcmUoJy4vcXVuaXQnKTtcXG5leHBvcnRzLmV4cG9ydHMgPSByZXF1aXJlKCcuL2V4cG9ydHMnKTtcXG5cXG59LHtcXFwiLi9iZGRcXFwiOjgsXFxcIi4vZXhwb3J0c1xcXCI6MTAsXFxcIi4vcXVuaXRcXFwiOjEyLFxcXCIuL3RkZFxcXCI6MTN9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XFxuXFxuLyoqXFxuICogUVVuaXQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgIHN1aXRlKCdBcnJheScpO1xcbiAqXFxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICB2YXIgYXJyID0gWzEsMiwzXTtcXG4gKiAgICAgICBvayhhcnIubGVuZ3RoID09IDMpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMSkgPT0gMCk7XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMikgPT0gMSk7XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMykgPT0gMik7XFxuICogICAgIH0pO1xcbiAqXFxuICogICAgIHN1aXRlKCdTdHJpbmcnKTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjbGVuZ3RoJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgb2soJ2ZvbycubGVuZ3RoID09IDMpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbihjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XFxuICAgICAgaWYgKHN1aXRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwgdGl0bGUpO1xcbiAgICAgIHN1aXRlLmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICByZXR1cm4gc3VpdGU7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gY29udGV4dC5zdWl0ZSh0aXRsZSwgZm4pO1xcbiAgICAgIG1vY2hhLmdyZXAoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZVxcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgdGVzdCA9IGNvbnRleHQudGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHZhciByZVN0cmluZyA9ICdeJyArIGVzY2FwZVJlKHRlc3QuZnVsbFRpdGxlKCkpICsgJyQnO1xcbiAgICAgIG1vY2hhLmdyZXAobmV3IFJlZ0V4cChyZVN0cmluZykpO1xcbiAgICB9O1xcblxcbiAgICBjb250ZXh0LnRlc3Quc2tpcCA9IGNvbW1vbi50ZXN0LnNraXA7XFxuICAgIGNvbnRleHQudGVzdC5yZXRyaWVzID0gY29tbW9uLnRlc3QucmV0cmllcztcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3N1aXRlXFxcIjozNyxcXFwiLi4vdGVzdFxcXCI6MzgsXFxcIi4vY29tbW9uXFxcIjo5LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NDl9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XFxuXFxuLyoqXFxuICogVERELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgc3VpdGUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIHN1aXRlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgc3VpdGVTZXR1cChmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBzdWl0ZVRlYXJkb3duKGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICogICAgICAgIH0pO1xcbiAqICAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24oY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0KTtcXG5cXG4gICAgY29udGV4dC5zZXR1cCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LnRlYXJkb3duID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5zdWl0ZVNldHVwID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5zdWl0ZVRlYXJkb3duID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nXFxuICAgICAqIG5lc3RlZCBzdWl0ZXMgYW5kL29yIHRlc3RzLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIHRpdGxlKTtcXG4gICAgICBzdWl0ZS5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyBzdWl0ZS5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUuc2tpcCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIHRpdGxlKTtcXG4gICAgICBzdWl0ZS5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gY29udGV4dC5zdWl0ZSh0aXRsZSwgZm4pO1xcbiAgICAgIG1vY2hhLmdyZXAoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZSB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZFxcbiAgICAgKiBjYWxsYmFjayBgZm5gIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xcbiAgICAgIGlmIChzdWl0ZS5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgZm4gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBjb250ZXh0LnRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB2YXIgcmVTdHJpbmcgPSAnXicgKyBlc2NhcGVSZSh0ZXN0LmZ1bGxUaXRsZSgpKSArICckJztcXG4gICAgICBtb2NoYS5ncmVwKG5ldyBSZWdFeHAocmVTdHJpbmcpKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzcsXFxcIi4uL3Rlc3RcXFwiOjM4LFxcXCIuL2NvbW1vblxcXCI6OSxcXFwiZXNjYXBlLXN0cmluZy1yZWdleHBcXFwiOjQ5fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsX19kaXJuYW1lKXtcXG4vKiFcXG4gKiBtb2NoYVxcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XFxuICogTUlUIExpY2Vuc2VkXFxuICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciByZXBvcnRlcnMgPSByZXF1aXJlKCcuL3JlcG9ydGVycycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1vY2hhYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNb2NoYTtcXG5cXG4vKipcXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxcbiAqL1xcblxcbmlmICghcHJvY2Vzcy5icm93c2VyKSB7XFxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKTtcXG4gIG1vZHVsZS5wYXRocy5wdXNoKGN3ZCwgcGF0aC5qb2luKGN3ZCwgJ25vZGVfbW9kdWxlcycpKTtcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIGludGVybmFscy5cXG4gKi9cXG5cXG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XFxuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XFxuZXhwb3J0cy5yZXBvcnRlcnMgPSByZXBvcnRlcnM7XFxuZXhwb3J0cy5SdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG5leHBvcnRzLkNvbnRleHQgPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcXG5leHBvcnRzLlJ1bm5lciA9IHJlcXVpcmUoJy4vcnVubmVyJyk7XFxuZXhwb3J0cy5TdWl0ZSA9IHJlcXVpcmUoJy4vc3VpdGUnKTtcXG5leHBvcnRzLkhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gaW1hZ2UgYG5hbWVgIHBhdGguXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBpbWFnZShuYW1lKSB7XFxuICByZXR1cm4gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2ltYWdlcycsIG5hbWUgKyAnLnBuZycpO1xcbn1cXG5cXG4vKipcXG4gKiBTZXQgdXAgbW9jaGEgd2l0aCBgb3B0aW9uc2AuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogICAtIGB1aWAgbmFtZSBcXFwiYmRkXFxcIiwgXFxcInRkZFxcXCIsIFxcXCJleHBvcnRzXFxcIiBldGNcXG4gKiAgIC0gYHJlcG9ydGVyYCByZXBvcnRlciBpbnN0YW5jZSwgZGVmYXVsdHMgdG8gYG1vY2hhLnJlcG9ydGVycy5zcGVjYFxcbiAqICAgLSBgZ2xvYmFsc2AgYXJyYXkgb2YgYWNjZXB0ZWQgZ2xvYmFsc1xcbiAqICAgLSBgdGltZW91dGAgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcXG4gKiAgIC0gYHJldHJpZXNgIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHNcXG4gKiAgIC0gYGJhaWxgIGJhaWwgb24gdGhlIGZpcnN0IHRlc3QgZmFpbHVyZVxcbiAqICAgLSBgc2xvd2AgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgdGVzdCBzbG93XFxuICogICAtIGBpZ25vcmVMZWFrc2AgaWdub3JlIGdsb2JhbCBsZWFrc1xcbiAqICAgLSBgZnVsbFRyYWNlYCBkaXNwbGF5IHRoZSBmdWxsIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKiAgIC0gYGdyZXBgIHN0cmluZyBvciByZWdleHAgdG8gZmlsdGVyIHRlc3RzIHdpdGhcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5mdW5jdGlvbiBNb2NoYShvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHRoaXMuZmlsZXMgPSBbXTtcXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuICBpZiAob3B0aW9ucy5ncmVwKSB7XFxuICAgIHRoaXMuZ3JlcChuZXcgUmVnRXhwKG9wdGlvbnMuZ3JlcCkpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZmdyZXApIHtcXG4gICAgdGhpcy5ncmVwKG9wdGlvbnMuZmdyZXApO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZSA9IG5ldyBleHBvcnRzLlN1aXRlKCcnLCBuZXcgZXhwb3J0cy5Db250ZXh0KCkpO1xcbiAgdGhpcy51aShvcHRpb25zLnVpKTtcXG4gIHRoaXMuYmFpbChvcHRpb25zLmJhaWwpO1xcbiAgdGhpcy5yZXBvcnRlcihvcHRpb25zLnJlcG9ydGVyLCBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyk7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy50aW1lb3V0ICE9PSBudWxsKSB7XFxuICAgIHRoaXMudGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJldHJpZXMgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMucmV0cmllcyAhPT0gbnVsbCkge1xcbiAgICB0aGlzLnJldHJpZXMob3B0aW9ucy5yZXRyaWVzKTtcXG4gIH1cXG4gIHRoaXMudXNlQ29sb3JzKG9wdGlvbnMudXNlQ29sb3JzKTtcXG4gIGlmIChvcHRpb25zLmVuYWJsZVRpbWVvdXRzICE9PSBudWxsKSB7XFxuICAgIHRoaXMuZW5hYmxlVGltZW91dHMob3B0aW9ucy5lbmFibGVUaW1lb3V0cyk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5zbG93KSB7XFxuICAgIHRoaXMuc2xvdyhvcHRpb25zLnNsb3cpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBiYWlsaW5nIG9uIHRoZSBmaXJzdCBmYWlsdXJlLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsXVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24oYmFpbCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIGJhaWwgPSB0cnVlO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZS5iYWlsKGJhaWwpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgdGVzdCBgZmlsZWAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFkZEZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XFxuICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCByZXBvcnRlciB0byBgcmVwb3J0ZXJgLCBkZWZhdWx0cyB0byBcXFwic3BlY1xcXCIuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRlck9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcmVwb3J0ZXJPcHRpb25zIG9wdGlvbmFsIG9wdGlvbnNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUucmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlciwgcmVwb3J0ZXJPcHRpb25zKSB7XFxuICBpZiAodHlwZW9mIHJlcG9ydGVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRoaXMuX3JlcG9ydGVyID0gcmVwb3J0ZXI7XFxuICB9IGVsc2Uge1xcbiAgICByZXBvcnRlciA9IHJlcG9ydGVyIHx8ICdzcGVjJztcXG4gICAgdmFyIF9yZXBvcnRlcjtcXG4gICAgLy8gVHJ5IHRvIGxvYWQgYSBidWlsdC1pbiByZXBvcnRlci5cXG4gICAgaWYgKHJlcG9ydGVyc1tyZXBvcnRlcl0pIHtcXG4gICAgICBfcmVwb3J0ZXIgPSByZXBvcnRlcnNbcmVwb3J0ZXJdO1xcbiAgICB9XFxuICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIHByb2Nlc3MuY3dkKCkgYW5kIG5vZGVfbW9kdWxlc1xcbiAgICBpZiAoIV9yZXBvcnRlcikge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBfcmVwb3J0ZXIgPSByZXF1aXJlKHJlcG9ydGVyKTtcXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIGVyci5tZXNzYWdlLmluZGV4T2YoJ0Nhbm5vdCBmaW5kIG1vZHVsZScpICE9PSAtMVxcbiAgICAgICAgICA/IGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIG5vdCBmb3VuZCcpXFxuICAgICAgICAgIDogY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgYmxldyB1cCB3aXRoIGVycm9yOlxcXFxuJyArIGVyci5zdGFjayk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghX3JlcG9ydGVyICYmIHJlcG9ydGVyID09PSAndGVhbWNpdHknKSB7XFxuICAgICAgY29uc29sZS53YXJuKCdUaGUgVGVhbWNpdHkgcmVwb3J0ZXIgd2FzIG1vdmVkIHRvIGEgcGFja2FnZSBuYW1lZCAnXFxuICAgICAgICArICdtb2NoYS10ZWFtY2l0eS1yZXBvcnRlciAnXFxuICAgICAgICArICcoaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9tb2NoYS10ZWFtY2l0eS1yZXBvcnRlcikuJyk7XFxuICAgIH1cXG4gICAgaWYgKCFfcmVwb3J0ZXIpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVwb3J0ZXIgXFxcIicgKyByZXBvcnRlciArICdcXFwiJyk7XFxuICAgIH1cXG4gICAgdGhpcy5fcmVwb3J0ZXIgPSBfcmVwb3J0ZXI7XFxuICB9XFxuICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJPcHRpb25zID0gcmVwb3J0ZXJPcHRpb25zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCBVSSBgbmFtZWAsIGRlZmF1bHRzIHRvIFxcXCJiZGRcXFwiLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gYmRkXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVpID0gZnVuY3Rpb24obmFtZSkge1xcbiAgbmFtZSA9IG5hbWUgfHwgJ2JkZCc7XFxuICB0aGlzLl91aSA9IGV4cG9ydHMuaW50ZXJmYWNlc1tuYW1lXTtcXG4gIGlmICghdGhpcy5fdWkpIHtcXG4gICAgdHJ5IHtcXG4gICAgICB0aGlzLl91aSA9IHJlcXVpcmUobmFtZSk7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnRlcmZhY2UgXFxcIicgKyBuYW1lICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5fdWkgPSB0aGlzLl91aSh0aGlzLnN1aXRlKTtcXG5cXG4gIHRoaXMuc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24oY29udGV4dCkge1xcbiAgICBleHBvcnRzLmFmdGVyRWFjaCA9IGNvbnRleHQuYWZ0ZXJFYWNoIHx8IGNvbnRleHQudGVhcmRvd247XFxuICAgIGV4cG9ydHMuYWZ0ZXIgPSBjb250ZXh0LmFmdGVyIHx8IGNvbnRleHQuc3VpdGVUZWFyZG93bjtcXG4gICAgZXhwb3J0cy5iZWZvcmVFYWNoID0gY29udGV4dC5iZWZvcmVFYWNoIHx8IGNvbnRleHQuc2V0dXA7XFxuICAgIGV4cG9ydHMuYmVmb3JlID0gY29udGV4dC5iZWZvcmUgfHwgY29udGV4dC5zdWl0ZVNldHVwO1xcbiAgICBleHBvcnRzLmRlc2NyaWJlID0gY29udGV4dC5kZXNjcmliZSB8fCBjb250ZXh0LnN1aXRlO1xcbiAgICBleHBvcnRzLml0ID0gY29udGV4dC5pdCB8fCBjb250ZXh0LnRlc3Q7XFxuICAgIGV4cG9ydHMuc2V0dXAgPSBjb250ZXh0LnNldHVwIHx8IGNvbnRleHQuYmVmb3JlRWFjaDtcXG4gICAgZXhwb3J0cy5zdWl0ZVNldHVwID0gY29udGV4dC5zdWl0ZVNldHVwIHx8IGNvbnRleHQuYmVmb3JlO1xcbiAgICBleHBvcnRzLnN1aXRlVGVhcmRvd24gPSBjb250ZXh0LnN1aXRlVGVhcmRvd24gfHwgY29udGV4dC5hZnRlcjtcXG4gICAgZXhwb3J0cy5zdWl0ZSA9IGNvbnRleHQuc3VpdGUgfHwgY29udGV4dC5kZXNjcmliZTtcXG4gICAgZXhwb3J0cy50ZWFyZG93biA9IGNvbnRleHQudGVhcmRvd24gfHwgY29udGV4dC5hZnRlckVhY2g7XFxuICAgIGV4cG9ydHMudGVzdCA9IGNvbnRleHQudGVzdCB8fCBjb250ZXh0Lml0O1xcbiAgICBleHBvcnRzLnJ1biA9IGNvbnRleHQucnVuO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIExvYWQgcmVnaXN0ZXJlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbihmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHRoaXMuZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XFxuICAgIGZpbGUgPSBwYXRoLnJlc29sdmUoZmlsZSk7XFxuICAgIHN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcXG4gICAgc3VpdGUuZW1pdCgncmVxdWlyZScsIHJlcXVpcmUoZmlsZSksIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdwb3N0LXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgfSk7XFxuICBmbiAmJiBmbigpO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuX2dyb3dsID0gZnVuY3Rpb24ocnVubmVyLCByZXBvcnRlcikge1xcbiAgdmFyIG5vdGlmeSA9IHJlcXVpcmUoJ2dyb3dsJyk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgc3RhdHMgPSByZXBvcnRlci5zdGF0cztcXG4gICAgaWYgKHN0YXRzLmZhaWx1cmVzKSB7XFxuICAgICAgdmFyIG1zZyA9IHN0YXRzLmZhaWx1cmVzICsgJyBvZiAnICsgcnVubmVyLnRvdGFsICsgJyB0ZXN0cyBmYWlsZWQnO1xcbiAgICAgIG5vdGlmeShtc2csIHsgbmFtZTogJ21vY2hhJywgdGl0bGU6ICdGYWlsZWQnLCBpbWFnZTogaW1hZ2UoJ2Vycm9yJykgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbm90aWZ5KHN0YXRzLnBhc3NlcyArICcgdGVzdHMgcGFzc2VkIGluICcgKyBzdGF0cy5kdXJhdGlvbiArICdtcycsIHtcXG4gICAgICAgIG5hbWU6ICdtb2NoYScsXFxuICAgICAgICB0aXRsZTogJ1Bhc3NlZCcsXFxuICAgICAgICBpbWFnZTogaW1hZ2UoJ29rJylcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgcmVnZXhwIHRvIGdyZXAsIGlmIGByZWAgaXMgYSBzdHJpbmcgaXQgaXMgZXNjYXBlZC5cXG4gKlxcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uKHJlKSB7XFxuICB0aGlzLm9wdGlvbnMuZ3JlcCA9IHR5cGVvZiByZSA9PT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKGVzY2FwZVJlKHJlKSkgOiByZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSW52ZXJ0IGAuZ3JlcCgpYCBtYXRjaGVzLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuaW52ZXJ0ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGdsb2JhbCBsZWFrcy5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5pZ25vcmVMZWFrcyA9IGZ1bmN0aW9uKGlnbm9yZSkge1xcbiAgdGhpcy5vcHRpb25zLmlnbm9yZUxlYWtzID0gQm9vbGVhbihpZ25vcmUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ2xvYmFsIGxlYWsgY2hlY2tpbmcuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5jaGVja0xlYWtzID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuaWdub3JlTGVha3MgPSBmYWxzZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGlzcGxheSBsb25nIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmZ1bGxTdGFja1RyYWNlID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ncm93bCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmdyb3dsID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGBnbG9iYWxzYCBhcnJheSBvciBzdHJpbmcuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uKGdsb2JhbHMpIHtcXG4gIHRoaXMub3B0aW9ucy5nbG9iYWxzID0gKHRoaXMub3B0aW9ucy5nbG9iYWxzIHx8IFtdKS5jb25jYXQoZ2xvYmFscyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVtaXQgY29sb3Igb3V0cHV0LlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUNvbG9ycyA9IGZ1bmN0aW9uKGNvbG9ycykge1xcbiAgaWYgKGNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXMub3B0aW9ucy51c2VDb2xvcnMgPSBjb2xvcnM7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVzZSBpbmxpbmUgZGlmZnMgcmF0aGVyIHRoYW4gKy8tLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51c2VJbmxpbmVEaWZmcyA9IGZ1bmN0aW9uKGlubGluZURpZmZzKSB7XFxuICB0aGlzLm9wdGlvbnMudXNlSW5saW5lRGlmZnMgPSBpbmxpbmVEaWZmcyAhPT0gdW5kZWZpbmVkICYmIGlubGluZURpZmZzO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0KSB7XFxuICB0aGlzLnN1aXRlLnRpbWVvdXQodGltZW91dCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXRyeSB0aW1lc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICB0aGlzLnN1aXRlLnJldHJpZXMobik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBzbG93bmVzcyB0aHJlc2hvbGQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHNsb3dcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbG93XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbihzbG93KSB7XFxuICB0aGlzLnN1aXRlLnNsb3coc2xvdyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSB0aW1lb3V0cy5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24oZW5hYmxlZCkge1xcbiAgdGhpcy5zdWl0ZS5lbmFibGVUaW1lb3V0cyhhcmd1bWVudHMubGVuZ3RoICYmIGVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZWQgOiB0cnVlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTWFrZXMgYWxsIHRlc3RzIGFzeW5jIChhY2NlcHRpbmcgYSBjYWxsYmFjaylcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFzeW5jT25seSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmFzeW5jT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERpc2FibGUgc3ludGF4IGhpZ2hsaWdodGluZyAoaW4gYnJvd3NlcikuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ub0hpZ2hsaWdodGluZyA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLm5vSGlnaGxpZ2h0aW5nID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIHVuY2F1Z2h0IGVycm9ycyB0byBwcm9wYWdhdGUgKGluIGJyb3dzZXIpLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYWxsb3dVbmNhdWdodCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmFsbG93VW5jYXVnaHQgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEZWxheSByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoKSB7XFxuICB0aGlzLm9wdGlvbnMuZGVsYXkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgYW5kIGludm9rZSBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtSdW5uZXJ9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGZuKSB7XFxuICBpZiAodGhpcy5maWxlcy5sZW5ndGgpIHtcXG4gICAgdGhpcy5sb2FkRmlsZXMoKTtcXG4gIH1cXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG4gIG9wdGlvbnMuZmlsZXMgPSB0aGlzLmZpbGVzO1xcbiAgdmFyIHJ1bm5lciA9IG5ldyBleHBvcnRzLlJ1bm5lcihzdWl0ZSwgb3B0aW9ucy5kZWxheSk7XFxuICB2YXIgcmVwb3J0ZXIgPSBuZXcgdGhpcy5fcmVwb3J0ZXIocnVubmVyLCBvcHRpb25zKTtcXG4gIHJ1bm5lci5pZ25vcmVMZWFrcyA9IG9wdGlvbnMuaWdub3JlTGVha3MgIT09IGZhbHNlO1xcbiAgcnVubmVyLmZ1bGxTdGFja1RyYWNlID0gb3B0aW9ucy5mdWxsU3RhY2tUcmFjZTtcXG4gIHJ1bm5lci5hc3luY09ubHkgPSBvcHRpb25zLmFzeW5jT25seTtcXG4gIHJ1bm5lci5hbGxvd1VuY2F1Z2h0ID0gb3B0aW9ucy5hbGxvd1VuY2F1Z2h0O1xcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xcbiAgICBydW5uZXIuZ3JlcChvcHRpb25zLmdyZXAsIG9wdGlvbnMuaW52ZXJ0KTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdsb2JhbHMpIHtcXG4gICAgcnVubmVyLmdsb2JhbHMob3B0aW9ucy5nbG9iYWxzKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdyb3dsKSB7XFxuICAgIHRoaXMuX2dyb3dsKHJ1bm5lciwgcmVwb3J0ZXIpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMudXNlQ29sb3JzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS51c2VDb2xvcnMgPSBvcHRpb25zLnVzZUNvbG9ycztcXG4gIH1cXG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaW5saW5lRGlmZnMgPSBvcHRpb25zLnVzZUlubGluZURpZmZzO1xcblxcbiAgZnVuY3Rpb24gZG9uZShmYWlsdXJlcykge1xcbiAgICBpZiAocmVwb3J0ZXIuZG9uZSkge1xcbiAgICAgIHJlcG9ydGVyLmRvbmUoZmFpbHVyZXMsIGZuKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmbiAmJiBmbihmYWlsdXJlcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBydW5uZXIucnVuKGRvbmUpO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSxcXFwiL2xpYlxcXCIpXFxufSx7XFxcIi4vY29udGV4dFxcXCI6NixcXFwiLi9ob29rXFxcIjo3LFxcXCIuL2ludGVyZmFjZXNcXFwiOjExLFxcXCIuL3JlcG9ydGVyc1xcXCI6MjIsXFxcIi4vcnVubmFibGVcXFwiOjM1LFxcXCIuL3J1bm5lclxcXCI6MzYsXFxcIi4vc3VpdGVcXFwiOjM3LFxcXCIuL3Rlc3RcXFwiOjM4LFxcXCIuL3V0aWxzXFxcIjozOSxcXFwiX3Byb2Nlc3NcXFwiOjU4LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NDksXFxcImdyb3dsXFxcIjo1MSxcXFwicGF0aFxcXCI6NDN9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogSGVscGVycy5cXG4gKi9cXG5cXG52YXIgcyA9IDEwMDA7XFxudmFyIG0gPSBzICogNjA7XFxudmFyIGggPSBtICogNjA7XFxudmFyIGQgPSBoICogMjQ7XFxudmFyIHkgPSBkICogMzY1LjI1O1xcblxcbi8qKlxcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcXG4gIH1cXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvMTAzNVxcbiAgcmV0dXJuIG9wdGlvbnNbJ2xvbmcnXSA/IGxvbmdGb3JtYXQodmFsKSA6IHNob3J0Rm9ybWF0KHZhbCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xcbiAgdmFyIG1hdGNoID0gKC9eKCg/OlxcXFxkKyk/XFxcXC4/XFxcXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kpLmV4ZWMoc3RyKTtcXG4gIGlmICghbWF0Y2gpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XFxuICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgY2FzZSAneWVhcnMnOlxcbiAgICBjYXNlICd5ZWFyJzpcXG4gICAgY2FzZSAneSc6XFxuICAgICAgcmV0dXJuIG4gKiB5O1xcbiAgICBjYXNlICdkYXlzJzpcXG4gICAgY2FzZSAnZGF5JzpcXG4gICAgY2FzZSAnZCc6XFxuICAgICAgcmV0dXJuIG4gKiBkO1xcbiAgICBjYXNlICdob3Vycyc6XFxuICAgIGNhc2UgJ2hvdXInOlxcbiAgICBjYXNlICdoJzpcXG4gICAgICByZXR1cm4gbiAqIGg7XFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxcbiAgICBjYXNlICdtaW51dGUnOlxcbiAgICBjYXNlICdtJzpcXG4gICAgICByZXR1cm4gbiAqIG07XFxuICAgIGNhc2UgJ3NlY29uZHMnOlxcbiAgICBjYXNlICdzZWNvbmQnOlxcbiAgICBjYXNlICdzJzpcXG4gICAgICByZXR1cm4gbiAqIHM7XFxuICAgIGNhc2UgJ21zJzpcXG4gICAgICByZXR1cm4gbjtcXG4gICAgZGVmYXVsdDpcXG4gICAgICAvLyBObyBkZWZhdWx0IGNhc2VcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHNob3J0Rm9ybWF0KG1zKSB7XFxuICBpZiAobXMgPj0gZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xcbiAgfVxcbiAgaWYgKG1zID49IGgpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcXG4gIH1cXG4gIGlmIChtcyA+PSBtKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XFxuICB9XFxuICBpZiAobXMgPj0gcykge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xcbiAgfVxcbiAgcmV0dXJuIG1zICsgJ21zJztcXG59XFxuXFxuLyoqXFxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gbG9uZ0Zvcm1hdChtcykge1xcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXFxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxcbiAgICB8fCBtcyArICcgbXMnO1xcbn1cXG5cXG4vKipcXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKi9cXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcXG4gIGlmIChtcyA8IG4pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcXG4gIH1cXG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XFxufVxcblxcbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFBlbmRpbmdgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQZW5kaW5nYCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcXG4gKi9cXG5mdW5jdGlvbiBQZW5kaW5nKG1lc3NhZ2UpIHtcXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxufVxcblxcbn0se31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcXG52YXIgZGlmZiA9IHJlcXVpcmUoJ2RpZmYnKTtcXG52YXIgbXMgPSByZXF1aXJlKCcuLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIHN1cHBvcnRzQ29sb3IgPSBwcm9jZXNzLmJyb3dzZXIgPyBudWxsIDogcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEJhc2VgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nLlxcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvaXNzdWVzLzIzN1xcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYm90aCBzdGRpbyBzdHJlYW1zIGFyZSBhc3NvY2lhdGVkIHdpdGggYSB0dHkuXFxuICovXFxuXFxudmFyIGlzYXR0eSA9IHR0eS5pc2F0dHkoMSkgJiYgdHR5LmlzYXR0eSgyKTtcXG5cXG4vKipcXG4gKiBFbmFibGUgY29sb3JpbmcgYnkgZGVmYXVsdCwgZXhjZXB0IGluIHRoZSBicm93c2VyIGludGVyZmFjZS5cXG4gKi9cXG5cXG5leHBvcnRzLnVzZUNvbG9ycyA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgKHN1cHBvcnRzQ29sb3IgfHwgKHByb2Nlc3MuZW52Lk1PQ0hBX0NPTE9SUyAhPT0gdW5kZWZpbmVkKSk7XFxuXFxuLyoqXFxuICogSW5saW5lIGRpZmZzIGluc3RlYWQgb2YgKy8tXFxuICovXFxuXFxuZXhwb3J0cy5pbmxpbmVEaWZmcyA9IGZhbHNlO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgY29sb3IgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0ge1xcbiAgcGFzczogOTAsXFxuICBmYWlsOiAzMSxcXG4gICdicmlnaHQgcGFzcyc6IDkyLFxcbiAgJ2JyaWdodCBmYWlsJzogOTEsXFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxcbiAgcGVuZGluZzogMzYsXFxuICBzdWl0ZTogMCxcXG4gICdlcnJvciB0aXRsZSc6IDAsXFxuICAnZXJyb3IgbWVzc2FnZSc6IDMxLFxcbiAgJ2Vycm9yIHN0YWNrJzogOTAsXFxuICBjaGVja21hcms6IDMyLFxcbiAgZmFzdDogOTAsXFxuICBtZWRpdW06IDMzLFxcbiAgc2xvdzogMzEsXFxuICBncmVlbjogMzIsXFxuICBsaWdodDogOTAsXFxuICAnZGlmZiBndXR0ZXInOiA5MCxcXG4gICdkaWZmIGFkZGVkJzogMzIsXFxuICAnZGlmZiByZW1vdmVkJzogMzFcXG59O1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc3ltYm9sIG1hcC5cXG4gKi9cXG5cXG5leHBvcnRzLnN5bWJvbHMgPSB7XFxuICBvazogJ+KckycsXFxuICBlcnI6ICfinJYnLFxcbiAgZG90OiAn4oCkJ1xcbn07XFxuXFxuLy8gV2l0aCBub2RlLmpzIG9uIFdpbmRvd3M6IHVzZSBzeW1ib2xzIGF2YWlsYWJsZSBpbiB0ZXJtaW5hbCBkZWZhdWx0IGZvbnRzXFxuaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcXG4gIGV4cG9ydHMuc3ltYm9scy5vayA9ICdcXFxcdTIyMUEnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmVyciA9ICdcXFxcdTAwRDcnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmRvdCA9ICcuJztcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYHR5cGVgLFxcbiAqIGFsbG93aW5nIGNvbG9ycyB0byBiZSBkaXNhYmxlZCxcXG4gKiBhcyB3ZWxsIGFzIHVzZXItZGVmaW5lZCBjb2xvclxcbiAqIHNjaGVtZXMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxudmFyIGNvbG9yID0gZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uKHR5cGUsIHN0cikge1xcbiAgaWYgKCFleHBvcnRzLnVzZUNvbG9ycykge1xcbiAgICByZXR1cm4gU3RyaW5nKHN0cik7XFxuICB9XFxuICByZXR1cm4gJ1xcXFx1MDAxYlsnICsgZXhwb3J0cy5jb2xvcnNbdHlwZV0gKyAnbScgKyBzdHIgKyAnXFxcXHUwMDFiWzBtJztcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0ZXJtIHdpbmRvdyBzaXplLCB3aXRoIHNvbWUgZGVmYXVsdHMgZm9yIHdoZW4gc3RkZXJyIGlzIG5vdCBhIHR0eS5cXG4gKi9cXG5cXG5leHBvcnRzLndpbmRvdyA9IHtcXG4gIHdpZHRoOiA3NVxcbn07XFxuXFxuaWYgKGlzYXR0eSkge1xcbiAgZXhwb3J0cy53aW5kb3cud2lkdGggPSBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplXFxuICAgICAgPyBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplKDEpWzBdXFxuICAgICAgOiB0dHkuZ2V0V2luZG93U2l6ZSgpWzFdO1xcbn1cXG5cXG4vKipcXG4gKiBFeHBvc2Ugc29tZSBiYXNpYyBjdXJzb3IgaW50ZXJhY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiBhbW9uZyByZXBvcnRlcnMuXFxuICovXFxuXFxuZXhwb3J0cy5jdXJzb3IgPSB7XFxuICBoaWRlOiBmdW5jdGlvbigpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbPzI1bCcpO1xcbiAgfSxcXG5cXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVoJyk7XFxuICB9LFxcblxcbiAgZGVsZXRlTGluZTogZnVuY3Rpb24oKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzJLJyk7XFxuICB9LFxcblxcbiAgYmVnaW5uaW5nT2ZMaW5lOiBmdW5jdGlvbigpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMEcnKTtcXG4gIH0sXFxuXFxuICBDUjogZnVuY3Rpb24oKSB7XFxuICAgIGlmIChpc2F0dHkpIHtcXG4gICAgICBleHBvcnRzLmN1cnNvci5kZWxldGVMaW5lKCk7XFxuICAgICAgZXhwb3J0cy5jdXJzb3IuYmVnaW5uaW5nT2ZMaW5lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxyJyk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHV0IHRoZSBnaXZlbiBgZmFpbHVyZXNgIGFzIGEgbGlzdC5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IGZhaWx1cmVzXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5leHBvcnRzLmxpc3QgPSBmdW5jdGlvbihmYWlsdXJlcykge1xcbiAgY29uc29sZS5sb2coKTtcXG4gIGZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24odGVzdCwgaSkge1xcbiAgICAvLyBmb3JtYXRcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXFxcbicpXFxuICAgICAgKyBjb2xvcignZXJyb3IgbWVzc2FnZScsICcgICAgICVzJylcXG4gICAgICArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG5cXG4gICAgLy8gbXNnXFxuICAgIHZhciBtc2c7XFxuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcXG4gICAgdmFyIG1lc3NhZ2U7XFxuICAgIGlmIChlcnIubWVzc2FnZSAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2UgKyAnJztcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLmluc3BlY3QoKSArICcnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG1lc3NhZ2UgPSAnJztcXG4gICAgfVxcbiAgICB2YXIgc3RhY2sgPSBlcnIuc3RhY2sgfHwgbWVzc2FnZTtcXG4gICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXhPZihtZXNzYWdlKTtcXG4gICAgdmFyIGFjdHVhbCA9IGVyci5hY3R1YWw7XFxuICAgIHZhciBleHBlY3RlZCA9IGVyci5leHBlY3RlZDtcXG4gICAgdmFyIGVzY2FwZSA9IHRydWU7XFxuXFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXG4gICAgICBtc2cgPSBtZXNzYWdlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluZGV4ICs9IG1lc3NhZ2UubGVuZ3RoO1xcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcXG4gICAgICAvLyByZW1vdmUgbXNnIGZyb20gc3RhY2tcXG4gICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGluZGV4ICsgMSk7XFxuICAgIH1cXG5cXG4gICAgLy8gdW5jYXVnaHRcXG4gICAgaWYgKGVyci51bmNhdWdodCkge1xcbiAgICAgIG1zZyA9ICdVbmNhdWdodCAnICsgbXNnO1xcbiAgICB9XFxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXFxuICAgIGlmIChlcnIuc2hvd0RpZmYgIT09IGZhbHNlICYmIHNhbWVUeXBlKGFjdHVhbCwgZXhwZWN0ZWQpICYmIGV4cGVjdGVkICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBlc2NhcGUgPSBmYWxzZTtcXG4gICAgICBpZiAoISh1dGlscy5pc1N0cmluZyhhY3R1YWwpICYmIHV0aWxzLmlzU3RyaW5nKGV4cGVjdGVkKSkpIHtcXG4gICAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWwgPSB1dGlscy5zdHJpbmdpZnkoYWN0dWFsKTtcXG4gICAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkID0gdXRpbHMuc3RyaW5naWZ5KGV4cGVjdGVkKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm10ID0gY29sb3IoJ2Vycm9yIHRpdGxlJywgJyAgJXMpICVzOlxcXFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG4gICAgICB2YXIgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eKFteOl0rKTogZXhwZWN0ZWQvKTtcXG4gICAgICBtc2cgPSAnXFxcXG4gICAgICAnICsgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCBtYXRjaCA/IG1hdGNoWzFdIDogbXNnKTtcXG5cXG4gICAgICBpZiAoZXhwb3J0cy5pbmxpbmVEaWZmcykge1xcbiAgICAgICAgbXNnICs9IGlubGluZURpZmYoZXJyLCBlc2NhcGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtc2cgKz0gdW5pZmllZERpZmYoZXJyLCBlc2NhcGUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBpbmRlbnQgc3RhY2sgdHJhY2VcXG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCAoaSArIDEpLCB0ZXN0LmZ1bGxUaXRsZSgpLCBtc2csIHN0YWNrKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQmFzZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBBbGwgb3RoZXIgcmVwb3J0ZXJzIGdlbmVyYWxseVxcbiAqIGluaGVyaXQgZnJvbSB0aGlzIHJlcG9ydGVyLCBwcm92aWRpbmdcXG4gKiBzdGF0cyBzdWNoIGFzIHRlc3QgZHVyYXRpb24sIG51bWJlclxcbiAqIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuXFxuICpcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBCYXNlKHJ1bm5lcikge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cyA9IHsgc3VpdGVzOiAwLCB0ZXN0czogMCwgcGFzc2VzOiAwLCBwZW5kaW5nOiAwLCBmYWlsdXJlczogMCB9O1xcbiAgdmFyIGZhaWx1cmVzID0gdGhpcy5mYWlsdXJlcyA9IFtdO1xcblxcbiAgaWYgKCFydW5uZXIpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XFxuXFxuICBydW5uZXIuc3RhdHMgPSBzdGF0cztcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgc3RhdHMuc3RhcnQgPSBuZXcgRGF0ZSgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgc3RhdHMuc3VpdGVzID0gc3RhdHMuc3VpdGVzIHx8IDA7XFxuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgc3RhdHMudGVzdHMgPSBzdGF0cy50ZXN0cyB8fCAwO1xcbiAgICBzdGF0cy50ZXN0cysrO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHN0YXRzLnBhc3NlcyA9IHN0YXRzLnBhc3NlcyB8fCAwO1xcblxcbiAgICBpZiAodGVzdC5kdXJhdGlvbiA+IHRlc3Quc2xvdygpKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdzbG93JztcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkgLyAyKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdtZWRpdW0nO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRlc3Quc3BlZWQgPSAnZmFzdCc7XFxuICAgIH1cXG5cXG4gICAgc3RhdHMucGFzc2VzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgICBzdGF0cy5mYWlsdXJlcyA9IHN0YXRzLmZhaWx1cmVzIHx8IDA7XFxuICAgIHN0YXRzLmZhaWx1cmVzKys7XFxuICAgIHRlc3QuZXJyID0gZXJyO1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBzdGF0cy5lbmQgPSBuZXcgRGF0ZSgpO1xcbiAgICBzdGF0cy5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGF0cy5zdGFydDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24oKSB7XFxuICAgIHN0YXRzLnBlbmRpbmcrKztcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBPdXRwdXQgY29tbW9uIGVwaWxvZ3VlIHVzZWQgYnkgbWFueSBvZlxcbiAqIHRoZSBidW5kbGVkIHJlcG9ydGVycy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuQmFzZS5wcm90b3R5cGUuZXBpbG9ndWUgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgZm10O1xcblxcbiAgY29uc29sZS5sb2coKTtcXG5cXG4gIC8vIHBhc3Nlc1xcbiAgZm10ID0gY29sb3IoJ2JyaWdodCBwYXNzJywgJyAnKVxcbiAgICArIGNvbG9yKCdncmVlbicsICcgJWQgcGFzc2luZycpXFxuICAgICsgY29sb3IoJ2xpZ2h0JywgJyAoJXMpJyk7XFxuXFxuICBjb25zb2xlLmxvZyhmbXQsXFxuICAgIHN0YXRzLnBhc3NlcyB8fCAwLFxcbiAgICBtcyhzdGF0cy5kdXJhdGlvbikpO1xcblxcbiAgLy8gcGVuZGluZ1xcbiAgaWYgKHN0YXRzLnBlbmRpbmcpIHtcXG4gICAgZm10ID0gY29sb3IoJ3BlbmRpbmcnLCAnICcpXFxuICAgICAgKyBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIHN0YXRzLnBlbmRpbmcpO1xcbiAgfVxcblxcbiAgLy8gZmFpbHVyZXNcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5mYWlsdXJlcyk7XFxuXFxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH1cXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYWQgdGhlIGdpdmVuIGBzdHJgIHRvIGBsZW5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZW5cXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gcGFkKHN0ciwgbGVuKSB7XFxuICBzdHIgPSBTdHJpbmcoc3RyKTtcXG4gIHJldHVybiBBcnJheShsZW4gLSBzdHIubGVuZ3RoICsgMSkuam9pbignICcpICsgc3RyO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGFuIGlubGluZSBkaWZmIGJldHdlZW4gMiBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB3aXRoIGFjdHVhbC9leHBlY3RlZFxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlXFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXFxuICovXFxuZnVuY3Rpb24gaW5saW5lRGlmZihlcnIsIGVzY2FwZSkge1xcbiAgdmFyIG1zZyA9IGVycm9yRGlmZihlcnIsICdXb3Jkc1dpdGhTcGFjZScsIGVzY2FwZSk7XFxuXFxuICAvLyBsaW5lbm9zXFxuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcXFxuJyk7XFxuICBpZiAobGluZXMubGVuZ3RoID4gNCkge1xcbiAgICB2YXIgd2lkdGggPSBTdHJpbmcobGluZXMubGVuZ3RoKS5sZW5ndGg7XFxuICAgIG1zZyA9IGxpbmVzLm1hcChmdW5jdGlvbihzdHIsIGkpIHtcXG4gICAgICByZXR1cm4gcGFkKCsraSwgd2lkdGgpICsgJyB8JyArICcgJyArIHN0cjtcXG4gICAgfSkuam9pbignXFxcXG4nKTtcXG4gIH1cXG5cXG4gIC8vIGxlZ2VuZFxcbiAgbXNnID0gJ1xcXFxuJ1xcbiAgICArIGNvbG9yKCdkaWZmIHJlbW92ZWQnLCAnYWN0dWFsJylcXG4gICAgKyAnICdcXG4gICAgKyBjb2xvcignZGlmZiBhZGRlZCcsICdleHBlY3RlZCcpXFxuICAgICsgJ1xcXFxuXFxcXG4nXFxuICAgICsgbXNnXFxuICAgICsgJ1xcXFxuJztcXG5cXG4gIC8vIGluZGVudFxcbiAgbXNnID0gbXNnLnJlcGxhY2UoL14vZ20sICcgICAgICAnKTtcXG4gIHJldHVybiBtc2c7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSB1bmlmaWVkIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB3aXRoIGFjdHVhbC9leHBlY3RlZFxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlXFxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGlmZi5cXG4gKi9cXG5mdW5jdGlvbiB1bmlmaWVkRGlmZihlcnIsIGVzY2FwZSkge1xcbiAgdmFyIGluZGVudCA9ICcgICAgICAnO1xcbiAgZnVuY3Rpb24gY2xlYW5VcChsaW5lKSB7XFxuICAgIGlmIChlc2NhcGUpIHtcXG4gICAgICBsaW5lID0gZXNjYXBlSW52aXNpYmxlcyhsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJysnKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCBsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJy0nKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lLm1hdGNoKC9cXFxcQFxcXFxALykpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBpZiAobGluZS5tYXRjaCgvXFxcXFxcXFwgTm8gbmV3bGluZS8pKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGluZGVudCArIGxpbmU7XFxuICB9XFxuICBmdW5jdGlvbiBub3RCbGFuayhsaW5lKSB7XFxuICAgIHJldHVybiB0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbGluZSAhPT0gbnVsbDtcXG4gIH1cXG4gIHZhciBtc2cgPSBkaWZmLmNyZWF0ZVBhdGNoKCdzdHJpbmcnLCBlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpO1xcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXFxcbicpLnNwbGljZSg0KTtcXG4gIHJldHVybiAnXFxcXG4gICAgICAnXFxuICAgICsgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsICcrIGV4cGVjdGVkJykgKyAnICdcXG4gICAgKyBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCAnLSBhY3R1YWwnKVxcbiAgICArICdcXFxcblxcXFxuJ1xcbiAgICArIGxpbmVzLm1hcChjbGVhblVwKS5maWx0ZXIobm90QmxhbmspLmpvaW4oJ1xcXFxuJyk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIGNoYXJhY3RlciBkaWZmIGZvciBgZXJyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXFxuICogQHBhcmFtIHtib29sZWFufSBlc2NhcGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gZXJyb3JEaWZmKGVyciwgdHlwZSwgZXNjYXBlKSB7XFxuICB2YXIgYWN0dWFsID0gZXNjYXBlID8gZXNjYXBlSW52aXNpYmxlcyhlcnIuYWN0dWFsKSA6IGVyci5hY3R1YWw7XFxuICB2YXIgZXhwZWN0ZWQgPSBlc2NhcGUgPyBlc2NhcGVJbnZpc2libGVzKGVyci5leHBlY3RlZCkgOiBlcnIuZXhwZWN0ZWQ7XFxuICByZXR1cm4gZGlmZlsnZGlmZicgKyB0eXBlXShhY3R1YWwsIGV4cGVjdGVkKS5tYXAoZnVuY3Rpb24oc3RyKSB7XFxuICAgIGlmIChzdHIuYWRkZWQpIHtcXG4gICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKHN0ci5yZW1vdmVkKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHN0ci52YWx1ZTtcXG4gIH0pLmpvaW4oJycpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYWxsIGludmlzaWJsZSBjaGFyYWN0ZXJzIGluIHBsYWluIHRleHRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVzY2FwZUludmlzaWJsZXMobGluZSkge1xcbiAgcmV0dXJuIGxpbmUucmVwbGFjZSgvXFxcXHQvZywgJzx0YWI+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxyL2csICc8Q1I+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxuL2csICc8TEY+XFxcXG4nKTtcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgbGluZXMgZm9yIGBzdHJgLCB1c2luZyB0aGUgY29sb3IgYG5hbWVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGNvbG9yTGluZXMobmFtZSwgc3RyKSB7XFxuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihzdHIpIHtcXG4gICAgcmV0dXJuIGNvbG9yKG5hbWUsIHN0cik7XFxuICB9KS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgdGhhdCBhIC8gYiBoYXZlIHRoZSBzYW1lIHR5cGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBzYW1lVHlwZShhLCBiKSB7XFxuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbChhKSA9PT0gb2JqVG9TdHJpbmcuY2FsbChiKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vbXNcXFwiOjE1LFxcXCIuLi91dGlsc1xcXCI6MzksXFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwiZGlmZlxcXCI6NDgsXFxcInN1cHBvcnRzLWNvbG9yXFxcIjo0MyxcXFwidHR5XFxcIjo1fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG9jYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb2M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG9jYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIERvYyhydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIGluZGVudHMgPSAyO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50KCkge1xcbiAgICByZXR1cm4gQXJyYXkoaW5kZW50cykuam9pbignICAnKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxzZWN0aW9uIGNsYXNzPVxcXCJzdWl0ZVxcXCI+JywgaW5kZW50KCkpO1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxoMT4lczwvaDE+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZShzdWl0ZS50aXRsZSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXM8ZGw+JywgaW5kZW50KCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnNvbGUubG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xcbiAgICAtLWluZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczwvc2VjdGlvbj4nLCBpbmRlbnQoKSk7XFxuICAgIC0taW5kZW50cztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkdD4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZD48cHJlPjxjb2RlPiVzPC9jb2RlPjwvcHJlPjwvZGQ+JywgaW5kZW50KCksIGNvZGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0LCBlcnIpIHtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZHQgY2xhc3M9XFxcImVycm9yXFxcIj4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuZm4uYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZCBjbGFzcz1cXFwiZXJyb3JcXFwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+JXM8L2RkPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoZXJyKSk7XFxuICB9KTtcXG59XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOSxcXFwiLi9iYXNlXFxcIjoxN31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gRG90KHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIC43NSB8IDA7XFxuICB2YXIgbiA9IC0xO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24oKSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3BlbmRpbmcnLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ3Nsb3cnKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ2JyaWdodCB5ZWxsb3cnLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IodGVzdC5zcGVlZCwgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdmYWlsJywgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoRG90LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTh9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLF9fZGlybmFtZSl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgSlNPTkNvdiA9IHJlcXVpcmUoJy4vanNvbi1jb3YnKTtcXG52YXIgcmVhZEZpbGVTeW5jID0gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmM7XFxudmFyIGpvaW4gPSByZXF1aXJlKCdwYXRoJykuam9pbjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhUTUxDb3ZgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUxDb3Y7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSnNDb3ZlcmFnZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBIVE1MQ292KHJ1bm5lcikge1xcbiAgdmFyIGphZGUgPSByZXF1aXJlKCdqYWRlJyk7XFxuICB2YXIgZmlsZSA9IGpvaW4oX19kaXJuYW1lLCAnL3RlbXBsYXRlcy9jb3ZlcmFnZS5qYWRlJyk7XFxuICB2YXIgc3RyID0gcmVhZEZpbGVTeW5jKGZpbGUsICd1dGY4Jyk7XFxuICB2YXIgZm4gPSBqYWRlLmNvbXBpbGUoc3RyLCB7IGZpbGVuYW1lOiBmaWxlIH0pO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgSlNPTkNvdi5jYWxsKHRoaXMsIHJ1bm5lciwgZmFsc2UpO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoZm4oe1xcbiAgICAgIGNvdjogc2VsZi5jb3YsXFxuICAgICAgY292ZXJhZ2VDbGFzczogY292ZXJhZ2VDbGFzc1xcbiAgICB9KSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGNvdmVyYWdlIGNsYXNzIGZvciBhIGdpdmVuIGNvdmVyYWdlIHBlcmNlbnRhZ2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gY292ZXJhZ2VQY3RnXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGNvdmVyYWdlQ2xhc3MoY292ZXJhZ2VQY3RnKSB7XFxuICBpZiAoY292ZXJhZ2VQY3RnID49IDc1KSB7XFxuICAgIHJldHVybiAnaGlnaCc7XFxuICB9XFxuICBpZiAoY292ZXJhZ2VQY3RnID49IDUwKSB7XFxuICAgIHJldHVybiAnbWVkaXVtJztcXG4gIH1cXG4gIGlmIChjb3ZlcmFnZVBjdGcgPj0gMjUpIHtcXG4gICAgcmV0dXJuICdsb3cnO1xcbiAgfVxcbiAgcmV0dXJuICd0ZXJyaWJsZSc7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLFxcXCIvbGliL3JlcG9ydGVyc1xcXCIpXFxufSx7XFxcIi4vanNvbi1jb3ZcXFwiOjIzLFxcXCJfcHJvY2Vzc1xcXCI6NTgsXFxcImZzXFxcIjo0MyxcXFwiamFkZVxcXCI6NDMsXFxcInBhdGhcXFwiOjQzfV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcuLi9icm93c2VyL3Byb2dyZXNzJyk7XFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhUTUxgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XFxuXFxuLyoqXFxuICogU3RhdHMgdGVtcGxhdGUuXFxuICovXFxuXFxudmFyIHN0YXRzVGVtcGxhdGUgPSAnPHVsIGlkPVxcXCJtb2NoYS1zdGF0c1xcXCI+J1xcbiAgKyAnPGxpIGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+PGNhbnZhcyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiPjwvY2FudmFzPjwvbGk+J1xcbiAgKyAnPGxpIGNsYXNzPVxcXCJwYXNzZXNcXFwiPjxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPnBhc3Nlczo8L2E+IDxlbT4wPC9lbT48L2xpPidcXG4gICsgJzxsaSBjbGFzcz1cXFwiZmFpbHVyZXNcXFwiPjxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPmZhaWx1cmVzOjwvYT4gPGVtPjA8L2VtPjwvbGk+J1xcbiAgKyAnPGxpIGNsYXNzPVxcXCJkdXJhdGlvblxcXCI+ZHVyYXRpb246IDxlbT4wPC9lbT5zPC9saT4nXFxuICArICc8L3VsPic7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSFRNTGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBIVE1MKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIHN0YXQgPSBmcmFnbWVudChzdGF0c1RlbXBsYXRlKTtcXG4gIHZhciBpdGVtcyA9IHN0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XFxuICB2YXIgcGFzc2VzID0gaXRlbXNbMV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgcGFzc2VzTGluayA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XFxuICB2YXIgZmFpbHVyZXMgPSBpdGVtc1syXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBmYWlsdXJlc0xpbmsgPSBpdGVtc1syXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xcbiAgdmFyIGR1cmF0aW9uID0gaXRlbXNbM10uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgY2FudmFzID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XFxuICB2YXIgcmVwb3J0ID0gZnJhZ21lbnQoJzx1bCBpZD1cXFwibW9jaGEtcmVwb3J0XFxcIj48L3VsPicpO1xcbiAgdmFyIHN0YWNrID0gW3JlcG9ydF07XFxuICB2YXIgcHJvZ3Jlc3M7XFxuICB2YXIgY3R4O1xcbiAgdmFyIHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKTtcXG5cXG4gIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xcbiAgICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBjYW52YXMud2lkdGg7XFxuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xcbiAgICBjYW52YXMud2lkdGggKj0gcmF0aW87XFxuICAgIGNhbnZhcy5oZWlnaHQgKj0gcmF0aW87XFxuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xcbiAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcXG4gICAgcHJvZ3Jlc3MgPSBuZXcgUHJvZ3Jlc3MoKTtcXG4gIH1cXG5cXG4gIGlmICghcm9vdCkge1xcbiAgICByZXR1cm4gZXJyb3IoJyNtb2NoYSBkaXYgbWlzc2luZywgYWRkIGl0IHRvIHlvdXIgZG9jdW1lbnQnKTtcXG4gIH1cXG5cXG4gIC8vIHBhc3MgdG9nZ2xlXFxuICBvbihwYXNzZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbihldnQpIHtcXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIHVuaGlkZSgpO1xcbiAgICB2YXIgbmFtZSA9ICgvcGFzcy8pLnRlc3QocmVwb3J0LmNsYXNzTmFtZSkgPyAnJyA6ICcgcGFzcyc7XFxuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xcbiAgICBpZiAocmVwb3J0LmNsYXNzTmFtZS50cmltKCkpIHtcXG4gICAgICBoaWRlU3VpdGVzV2l0aG91dCgndGVzdCBwYXNzJyk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gZmFpbHVyZSB0b2dnbGVcXG4gIG9uKGZhaWx1cmVzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XFxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB1bmhpZGUoKTtcXG4gICAgdmFyIG5hbWUgPSAoL2ZhaWwvKS50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIGZhaWwnO1xcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcXG4gICAgaWYgKHJlcG9ydC5jbGFzc05hbWUudHJpbSgpKSB7XFxuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgZmFpbCcpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJvb3QuYXBwZW5kQ2hpbGQoc3RhdCk7XFxuICByb290LmFwcGVuZENoaWxkKHJlcG9ydCk7XFxuXFxuICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgcHJvZ3Jlc3Muc2l6ZSg0MCk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gc3VpdGVcXG4gICAgdmFyIHVybCA9IHNlbGYuc3VpdGVVUkwoc3VpdGUpO1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJzdWl0ZVxcXCI+PGgxPjxhIGhyZWY9XFxcIiVzXFxcIj4lczwvYT48L2gxPjwvbGk+JywgdXJsLCBlc2NhcGUoc3VpdGUudGl0bGUpKTtcXG5cXG4gICAgLy8gY29udGFpbmVyXFxuICAgIHN0YWNrWzBdLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgc3RhY2sudW5zaGlmdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpKTtcXG4gICAgZWwuYXBwZW5kQ2hpbGQoc3RhY2tbMF0pO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHN0YWNrLnNoaWZ0KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIHVybCA9IHNlbGYudGVzdFVSTCh0ZXN0KTtcXG4gICAgdmFyIG1hcmt1cCA9ICc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyAlZVxcXCI+PGgyPiVlPHNwYW4gY2xhc3M9XFxcImR1cmF0aW9uXFxcIj4lZW1zPC9zcGFuPiAnXFxuICAgICAgKyAnPGEgaHJlZj1cXFwiJXNcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPuKAozwvYT48L2gyPjwvbGk+JztcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQobWFya3VwLCB0ZXN0LnNwZWVkLCB0ZXN0LnRpdGxlLCB0ZXN0LmR1cmF0aW9uLCB1cmwpO1xcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInRlc3QgZmFpbFxcXCI+PGgyPiVlIDxhIGhyZWY9XFxcIiVlXFxcIiBjbGFzcz1cXFwicmVwbGF5XFxcIj7igKM8L2E+PC9oMj48L2xpPicsXFxuICAgICAgdGVzdC50aXRsZSwgc2VsZi50ZXN0VVJMKHRlc3QpKTtcXG4gICAgdmFyIHN0YWNrU3RyaW5nOyAvLyBOb3RlOiBJbmNsdWRlcyBsZWFkaW5nIG5ld2xpbmVcXG4gICAgdmFyIG1lc3NhZ2UgPSB0ZXN0LmVyci50b1N0cmluZygpO1xcblxcbiAgICAvLyA8PUlFNyBzdHJpbmdpZmllcyB0byBbT2JqZWN0IEVycm9yXS4gU2luY2UgaXQgY2FuIGJlIG92ZXJsb2FkZWQsIHdlXFxuICAgIC8vIGNoZWNrIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBzdHJpbmdpZnlpbmcuXFxuICAgIGlmIChtZXNzYWdlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XFxuICAgICAgbWVzc2FnZSA9IHRlc3QuZXJyLm1lc3NhZ2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRlc3QuZXJyLnN0YWNrKSB7XFxuICAgICAgdmFyIGluZGV4T2ZNZXNzYWdlID0gdGVzdC5lcnIuc3RhY2suaW5kZXhPZih0ZXN0LmVyci5tZXNzYWdlKTtcXG4gICAgICBpZiAoaW5kZXhPZk1lc3NhZ2UgPT09IC0xKSB7XFxuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrLnN1YnN0cih0ZXN0LmVyci5tZXNzYWdlLmxlbmd0aCArIGluZGV4T2ZNZXNzYWdlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuc291cmNlVVJMICYmIHRlc3QuZXJyLmxpbmUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGdpdmUgeW91IGEgc3RhY2suIExldCdzIGF0IGxlYXN0IHByb3ZpZGUgYSBzb3VyY2UgbGluZS5cXG4gICAgICBzdGFja1N0cmluZyA9ICdcXFxcbignICsgdGVzdC5lcnIuc291cmNlVVJMICsgJzonICsgdGVzdC5lcnIubGluZSArICcpJztcXG4gICAgfVxcblxcbiAgICBzdGFja1N0cmluZyA9IHN0YWNrU3RyaW5nIHx8ICcnO1xcblxcbiAgICBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UgJiYgc3RhY2tTdHJpbmcpIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBjbGFzcz1cXFwiaHRtbC1lcnJvclxcXCI+JXNcXFxcbjxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZTwvcHJlPjwvZGl2PicsXFxuICAgICAgICB0ZXN0LmVyci5odG1sTWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSkge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lczwvZGl2PicsIHRlc3QuZXJyLmh0bWxNZXNzYWdlKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZSVlPC9wcmU+JywgbWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyBwZW5kaW5nXFxcIj48aDI+JWU8L2gyPjwvbGk+JywgdGVzdC50aXRsZSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBmdW5jdGlvbiBhcHBlbmRUb1N0YWNrKGVsKSB7XFxuICAgIC8vIERvbid0IGNhbGwgLmFwcGVuZENoaWxkIGlmICNtb2NoYS1yZXBvcnQgd2FzIGFscmVhZHkgLnNoaWZ0KCknZWQgb2ZmIHRoZSBzdGFjay5cXG4gICAgaWYgKHN0YWNrWzBdKSB7XFxuICAgICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVTdGF0cygpIHtcXG4gICAgLy8gVE9ETzogYWRkIHRvIHN0YXRzXFxuICAgIHZhciBwZXJjZW50ID0gc3RhdHMudGVzdHMgLyB0aGlzLnRvdGFsICogMTAwIHwgMDtcXG4gICAgaWYgKHByb2dyZXNzKSB7XFxuICAgICAgcHJvZ3Jlc3MudXBkYXRlKHBlcmNlbnQpLmRyYXcoY3R4KTtcXG4gICAgfVxcblxcbiAgICAvLyB1cGRhdGUgc3RhdHNcXG4gICAgdmFyIG1zID0gbmV3IERhdGUoKSAtIHN0YXRzLnN0YXJ0O1xcbiAgICB0ZXh0KHBhc3Nlcywgc3RhdHMucGFzc2VzKTtcXG4gICAgdGV4dChmYWlsdXJlcywgc3RhdHMuZmFpbHVyZXMpO1xcbiAgICB0ZXh0KGR1cmF0aW9uLCAobXMgLyAxMDAwKS50b0ZpeGVkKDIpKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogTWFrZXMgYSBVUkwsIHByZXNlcnZpbmcgcXVlcnlzdHJpbmcgKFxcXCJzZWFyY2hcXFwiKSBwYXJhbWV0ZXJzLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgbmV3IFVSTC5cXG4gKi9cXG5mdW5jdGlvbiBtYWtlVXJsKHMpIHtcXG4gIHZhciBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xcblxcbiAgLy8gUmVtb3ZlIHByZXZpb3VzIGdyZXAgcXVlcnkgcGFyYW1ldGVyIGlmIHByZXNlbnRcXG4gIGlmIChzZWFyY2gpIHtcXG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoL1s/Jl1ncmVwPVteJlxcXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcXG4gIH1cXG5cXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArICdncmVwPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlUmUocykpO1xcbn1cXG5cXG4vKipcXG4gKiBQcm92aWRlIHN1aXRlIFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3VpdGVdXFxuICovXFxuSFRNTC5wcm90b3R5cGUuc3VpdGVVUkwgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgcmV0dXJuIG1ha2VVcmwoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUHJvdmlkZSB0ZXN0IFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGVzdF1cXG4gKi9cXG5IVE1MLnByb3RvdHlwZS50ZXN0VVJMID0gZnVuY3Rpb24odGVzdCkge1xcbiAgcmV0dXJuIG1ha2VVcmwodGVzdC5mdWxsVGl0bGUoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGRzIGNvZGUgdG9nZ2xlIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBwcm92aWRlZCB0ZXN0J3MgbGlzdCBlbGVtZW50LlxcbiAqXFxuICogQHBhcmFtIHtIVE1MTElFbGVtZW50fSBlbFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50c1xcbiAqL1xcbkhUTUwucHJvdG90eXBlLmFkZENvZGVUb2dnbGUgPSBmdW5jdGlvbihlbCwgY29udGVudHMpIHtcXG4gIHZhciBoMiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpWzBdO1xcblxcbiAgb24oaDIsICdjbGljaycsIGZ1bmN0aW9uKCkge1xcbiAgICBwcmUuc3R5bGUuZGlzcGxheSA9IHByZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnYmxvY2snIDogJ25vbmUnO1xcbiAgfSk7XFxuXFxuICB2YXIgcHJlID0gZnJhZ21lbnQoJzxwcmU+PGNvZGU+JWU8L2NvZGU+PC9wcmU+JywgdXRpbHMuY2xlYW4oY29udGVudHMpKTtcXG4gIGVsLmFwcGVuZENoaWxkKHByZSk7XFxuICBwcmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcXG59O1xcblxcbi8qKlxcbiAqIERpc3BsYXkgZXJyb3IgYG1zZ2AuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXFxuICovXFxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGlkPVxcXCJtb2NoYS1lcnJvclxcXCI+JXM8L2Rpdj4nLCBtc2cpKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgRE9NIGZyYWdtZW50IGZyb20gYGh0bWxgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcXG4gKi9cXG5mdW5jdGlvbiBmcmFnbWVudChodG1sKSB7XFxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gIHZhciBpID0gMTtcXG5cXG4gIGRpdi5pbm5lckhUTUwgPSBodG1sLnJlcGxhY2UoLyUoW3NlXSkvZywgZnVuY3Rpb24oXywgdHlwZSkge1xcbiAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICBjYXNlICdzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJ2UnOiByZXR1cm4gZXNjYXBlKGFyZ3NbaSsrXSk7XFxuICAgICAgLy8gbm8gZGVmYXVsdFxcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgZm9yIHN1aXRlcyB0aGF0IGRvIG5vdCBoYXZlIGVsZW1lbnRzXFxuICogd2l0aCBgY2xhc3NuYW1lYCwgYW5kIGhpZGUgdGhlbS5cXG4gKlxcbiAqIEBwYXJhbSB7dGV4dH0gY2xhc3NuYW1lXFxuICovXFxuZnVuY3Rpb24gaGlkZVN1aXRlc1dpdGhvdXQoY2xhc3NuYW1lKSB7XFxuICB2YXIgc3VpdGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUnKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBlbHMgPSBzdWl0ZXNbaV0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc25hbWUpO1xcbiAgICBpZiAoIWVscy5sZW5ndGgpIHtcXG4gICAgICBzdWl0ZXNbaV0uY2xhc3NOYW1lICs9ICcgaGlkZGVuJztcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBVbmhpZGUgLmhpZGRlbiBzdWl0ZXMuXFxuICovXFxuZnVuY3Rpb24gdW5oaWRlKCkge1xcbiAgdmFyIGVscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlIGhpZGRlbicpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgZWxzW2ldLmNsYXNzTmFtZSA9IGVsc1tpXS5jbGFzc05hbWUucmVwbGFjZSgnc3VpdGUgaGlkZGVuJywgJ3N1aXRlJyk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFNldCBhbiBlbGVtZW50J3MgdGV4dCBjb250ZW50cy5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXFxuICovXFxuZnVuY3Rpb24gdGV4dChlbCwgY29udGVudHMpIHtcXG4gIGlmIChlbC50ZXh0Q29udGVudCkge1xcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuaW5uZXJUZXh0ID0gY29udGVudHM7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIExpc3RlbiBvbiBgZXZlbnRgIHdpdGggY2FsbGJhY2sgYGZuYC5cXG4gKi9cXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XFxuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XFxuICB9XFxufVxcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi9icm93c2VyL3Byb2dyZXNzXFxcIjo0LFxcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo0OX1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBBbGlhcyBleHBvcnRzIHRvIGEgdGhlaXIgbm9ybWFsaXplZCBmb3JtYXQgTW9jaGEjcmVwb3J0ZXIgdG8gcHJldmVudCBhIG5lZWRcXG4vLyBmb3IgZHluYW1pYyAodHJ5L2NhdGNoKSByZXF1aXJlcywgd2hpY2ggQnJvd3NlcmlmeSBkb2Vzbid0IGhhbmRsZS5cXG5leHBvcnRzLkJhc2UgPSBleHBvcnRzLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5leHBvcnRzLkRvdCA9IGV4cG9ydHMuZG90ID0gcmVxdWlyZSgnLi9kb3QnKTtcXG5leHBvcnRzLkRvYyA9IGV4cG9ydHMuZG9jID0gcmVxdWlyZSgnLi9kb2MnKTtcXG5leHBvcnRzLlRBUCA9IGV4cG9ydHMudGFwID0gcmVxdWlyZSgnLi90YXAnKTtcXG5leHBvcnRzLkpTT04gPSBleHBvcnRzLmpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcXG5leHBvcnRzLkhUTUwgPSBleHBvcnRzLmh0bWwgPSByZXF1aXJlKCcuL2h0bWwnKTtcXG5leHBvcnRzLkxpc3QgPSBleHBvcnRzLmxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcXG5leHBvcnRzLk1pbiA9IGV4cG9ydHMubWluID0gcmVxdWlyZSgnLi9taW4nKTtcXG5leHBvcnRzLlNwZWMgPSBleHBvcnRzLnNwZWMgPSByZXF1aXJlKCcuL3NwZWMnKTtcXG5leHBvcnRzLk55YW4gPSBleHBvcnRzLm55YW4gPSByZXF1aXJlKCcuL255YW4nKTtcXG5leHBvcnRzLlhVbml0ID0gZXhwb3J0cy54dW5pdCA9IHJlcXVpcmUoJy4veHVuaXQnKTtcXG5leHBvcnRzLk1hcmtkb3duID0gZXhwb3J0cy5tYXJrZG93biA9IHJlcXVpcmUoJy4vbWFya2Rvd24nKTtcXG5leHBvcnRzLlByb2dyZXNzID0gZXhwb3J0cy5wcm9ncmVzcyA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3MnKTtcXG5leHBvcnRzLkxhbmRpbmcgPSBleHBvcnRzLmxhbmRpbmcgPSByZXF1aXJlKCcuL2xhbmRpbmcnKTtcXG5leHBvcnRzLkpTT05Db3YgPSBleHBvcnRzWydqc29uLWNvdiddID0gcmVxdWlyZSgnLi9qc29uLWNvdicpO1xcbmV4cG9ydHMuSFRNTENvdiA9IGV4cG9ydHNbJ2h0bWwtY292J10gPSByZXF1aXJlKCcuL2h0bWwtY292Jyk7XFxuZXhwb3J0cy5KU09OU3RyZWFtID0gZXhwb3J0c1snanNvbi1zdHJlYW0nXSA9IHJlcXVpcmUoJy4vanNvbi1zdHJlYW0nKTtcXG5cXG59LHtcXFwiLi9iYXNlXFxcIjoxNyxcXFwiLi9kb2NcXFwiOjE4LFxcXCIuL2RvdFxcXCI6MTksXFxcIi4vaHRtbFxcXCI6MjEsXFxcIi4vaHRtbC1jb3ZcXFwiOjIwLFxcXCIuL2pzb25cXFwiOjI1LFxcXCIuL2pzb24tY292XFxcIjoyMyxcXFwiLi9qc29uLXN0cmVhbVxcXCI6MjQsXFxcIi4vbGFuZGluZ1xcXCI6MjYsXFxcIi4vbGlzdFxcXCI6MjcsXFxcIi4vbWFya2Rvd25cXFwiOjI4LFxcXCIuL21pblxcXCI6MjksXFxcIi4vbnlhblxcXCI6MzAsXFxcIi4vcHJvZ3Jlc3NcXFwiOjMxLFxcXCIuL3NwZWNcXFwiOjMyLFxcXCIuL3RhcFxcXCI6MzMsXFxcIi4veHVuaXRcXFwiOjM0fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEpTT05Db3ZgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEpTT05Db3Y7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSnNDb3ZlcmFnZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG91dHB1dFxcbiAqL1xcbmZ1bmN0aW9uIEpTT05Db3YocnVubmVyLCBvdXRwdXQpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBvdXRwdXQ7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBbXTtcXG4gIHZhciBmYWlsdXJlcyA9IFtdO1xcbiAgdmFyIHBhc3NlcyA9IFtdO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBwYXNzZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgY292ID0gZ2xvYmFsLl8kanNjb3ZlcmFnZSB8fCB7fTtcXG4gICAgdmFyIHJlc3VsdCA9IHNlbGYuY292ID0gbWFwKGNvdik7XFxuICAgIHJlc3VsdC5zdGF0cyA9IHNlbGYuc3RhdHM7XFxuICAgIHJlc3VsdC50ZXN0cyA9IHRlc3RzLm1hcChjbGVhbik7XFxuICAgIHJlc3VsdC5mYWlsdXJlcyA9IGZhaWx1cmVzLm1hcChjbGVhbik7XFxuICAgIHJlc3VsdC5wYXNzZXMgPSBwYXNzZXMubWFwKGNsZWFuKTtcXG4gICAgaWYgKCFvdXRwdXQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogTWFwIGpzY292ZXJhZ2UgZGF0YSB0byBhIEpTT04gc3RydWN0dXJlXFxuICogc3VpdGFibGUgZm9yIHJlcG9ydGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb3ZcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuXFxuZnVuY3Rpb24gbWFwKGNvdikge1xcbiAgdmFyIHJldCA9IHtcXG4gICAgaW5zdHJ1bWVudGF0aW9uOiAnbm9kZS1qc2NvdmVyYWdlJyxcXG4gICAgc2xvYzogMCxcXG4gICAgaGl0czogMCxcXG4gICAgbWlzc2VzOiAwLFxcbiAgICBjb3ZlcmFnZTogMCxcXG4gICAgZmlsZXM6IFtdXFxuICB9O1xcblxcbiAgZm9yICh2YXIgZmlsZW5hbWUgaW4gY292KSB7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY292LCBmaWxlbmFtZSkpIHtcXG4gICAgICB2YXIgZGF0YSA9IGNvdmVyYWdlKGZpbGVuYW1lLCBjb3ZbZmlsZW5hbWVdKTtcXG4gICAgICByZXQuZmlsZXMucHVzaChkYXRhKTtcXG4gICAgICByZXQuaGl0cyArPSBkYXRhLmhpdHM7XFxuICAgICAgcmV0Lm1pc3NlcyArPSBkYXRhLm1pc3NlcztcXG4gICAgICByZXQuc2xvYyArPSBkYXRhLnNsb2M7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldC5maWxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcXG4gICAgcmV0dXJuIGEuZmlsZW5hbWUubG9jYWxlQ29tcGFyZShiLmZpbGVuYW1lKTtcXG4gIH0pO1xcblxcbiAgaWYgKHJldC5zbG9jID4gMCkge1xcbiAgICByZXQuY292ZXJhZ2UgPSAocmV0LmhpdHMgLyByZXQuc2xvYykgKiAxMDA7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vKipcXG4gKiBNYXAganNjb3ZlcmFnZSBkYXRhIGZvciBhIHNpbmdsZSBzb3VyY2UgZmlsZVxcbiAqIHRvIGEgSlNPTiBzdHJ1Y3R1cmUgc3VpdGFibGUgZm9yIHJlcG9ydGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSBuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGpzY292ZXJhZ2UgY292ZXJhZ2UgZGF0YVxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjb3ZlcmFnZShmaWxlbmFtZSwgZGF0YSkge1xcbiAgdmFyIHJldCA9IHtcXG4gICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxcbiAgICBjb3ZlcmFnZTogMCxcXG4gICAgaGl0czogMCxcXG4gICAgbWlzc2VzOiAwLFxcbiAgICBzbG9jOiAwLFxcbiAgICBzb3VyY2U6IHt9XFxuICB9O1xcblxcbiAgZGF0YS5zb3VyY2UuZm9yRWFjaChmdW5jdGlvbihsaW5lLCBudW0pIHtcXG4gICAgbnVtKys7XFxuXFxuICAgIGlmIChkYXRhW251bV0gPT09IDApIHtcXG4gICAgICByZXQubWlzc2VzKys7XFxuICAgICAgcmV0LnNsb2MrKztcXG4gICAgfSBlbHNlIGlmIChkYXRhW251bV0gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldC5oaXRzKys7XFxuICAgICAgcmV0LnNsb2MrKztcXG4gICAgfVxcblxcbiAgICByZXQuc291cmNlW251bV0gPSB7XFxuICAgICAgc291cmNlOiBsaW5lLFxcbiAgICAgIGNvdmVyYWdlOiBkYXRhW251bV0gPT09IHVuZGVmaW5lZCA/ICcnIDogZGF0YVtudW1dXFxuICAgIH07XFxuICB9KTtcXG5cXG4gIHJldC5jb3ZlcmFnZSA9IHJldC5oaXRzIC8gcmV0LnNsb2MgKiAxMDA7XFxuXFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcyBldGMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbih0ZXN0KSB7XFxuICByZXR1cm4ge1xcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpLFxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXFxuICAgIHRpdGxlOiB0ZXN0LnRpdGxlXFxuICB9O1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTh9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMaXN0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExpc3RgIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMaXN0KHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsnc3RhcnQnLCB7IHRvdGFsOiB0b3RhbCB9XSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsncGFzcycsIGNsZWFuKHRlc3QpXSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0LCBlcnIpIHtcXG4gICAgdGVzdCA9IGNsZWFuKHRlc3QpO1xcbiAgICB0ZXN0LmVyciA9IGVyci5tZXNzYWdlO1xcbiAgICB0ZXN0LnN0YWNrID0gZXJyLnN0YWNrIHx8IG51bGw7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsnZmFpbCcsIHRlc3RdKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KFsnZW5kJywgc2VsZi5zdGF0c10pKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcyBldGMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbih0ZXN0KSB7XFxuICByZXR1cm4ge1xcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpXFxuICB9O1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjU4fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSlNPTmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSlNPTlJlcG9ydGVyO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEpTT05gIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gSlNPTlJlcG9ydGVyKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBbXTtcXG4gIHZhciBwZW5kaW5nID0gW107XFxuICB2YXIgZmFpbHVyZXMgPSBbXTtcXG4gIHZhciBwYXNzZXMgPSBbXTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgcGFzc2VzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBwZW5kaW5nLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciBvYmogPSB7XFxuICAgICAgc3RhdHM6IHNlbGYuc3RhdHMsXFxuICAgICAgdGVzdHM6IHRlc3RzLm1hcChjbGVhbiksXFxuICAgICAgcGVuZGluZzogcGVuZGluZy5tYXAoY2xlYW4pLFxcbiAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcy5tYXAoY2xlYW4pLFxcbiAgICAgIHBhc3NlczogcGFzc2VzLm1hcChjbGVhbilcXG4gICAgfTtcXG5cXG4gICAgcnVubmVyLnRlc3RSZXN1bHRzID0gb2JqO1xcblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcyBldGMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbih0ZXN0KSB7XFxuICByZXR1cm4ge1xcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpLFxcbiAgICBlcnI6IGVycm9ySlNPTih0ZXN0LmVyciB8fCB7fSlcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIFRyYW5zZm9ybSBgZXJyb3JgIGludG8gYSBKU09OIG9iamVjdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBlcnJvckpTT04oZXJyKSB7XFxuICB2YXIgcmVzID0ge307XFxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XFxuICAgIHJlc1trZXldID0gZXJyW2tleV07XFxuICB9LCBlcnIpO1xcbiAgcmV0dXJuIHJlcztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1OH1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGFuZGluZ2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGFuZGluZztcXG5cXG4vKipcXG4gKiBBaXJwbGFuZSBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wbGFuZSA9IDA7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY3Jhc2ggY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnNbJ3BsYW5lIGNyYXNoJ10gPSAzMTtcXG5cXG4vKipcXG4gKiBSdW53YXkgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucnVud2F5ID0gOTA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGFuZGluZ2AgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMYW5kaW5nKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIC43NSB8IDA7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuICB2YXIgc3RyZWFtID0gcHJvY2Vzcy5zdGRvdXQ7XFxuICB2YXIgcGxhbmUgPSBjb2xvcigncGxhbmUnLCAn4pyIJyk7XFxuICB2YXIgY3Jhc2hlZCA9IC0xO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgZnVuY3Rpb24gcnVud2F5KCkge1xcbiAgICB2YXIgYnVmID0gQXJyYXkod2lkdGgpLmpvaW4oJy0nKTtcXG4gICAgcmV0dXJuICcgICcgKyBjb2xvcigncnVud2F5JywgYnVmKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcblxcXFxuXFxcXG4gICcpO1xcbiAgICBjdXJzb3IuaGlkZSgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICAvLyBjaGVjayBpZiB0aGUgcGxhbmUgY3Jhc2hlZFxcbiAgICB2YXIgY29sID0gY3Jhc2hlZCA9PT0gLTEgPyB3aWR0aCAqICsrbiAvIHRvdGFsIHwgMCA6IGNyYXNoZWQ7XFxuXFxuICAgIC8vIHNob3cgdGhlIGNyYXNoXFxuICAgIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICAgIHBsYW5lID0gY29sb3IoJ3BsYW5lIGNyYXNoJywgJ+KciCcpO1xcbiAgICAgIGNyYXNoZWQgPSBjb2w7XFxuICAgIH1cXG5cXG4gICAgLy8gcmVuZGVyIGxhbmRpbmcgc3RyaXBcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcdTAwMWJbJyArICh3aWR0aCArIDEpICsgJ0RcXFxcdTAwMWJbMkEnKTtcXG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIHN0cmVhbS53cml0ZShjb2xvcigncnVud2F5JywgQXJyYXkoY29sKS5qb2luKCfii4UnKSkpO1xcbiAgICBzdHJlYW0ud3JpdGUocGxhbmUpO1xcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KHdpZHRoIC0gY29sKS5qb2luKCfii4UnKSArICdcXFxcbicpKTtcXG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcdTAwMWJbMG0nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgY3Vyc29yLnNob3coKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1OH1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGlzdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGlzdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBMaXN0YCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGlzdChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwYXNzJywgJyAgICAnICsgdGVzdC5mdWxsVGl0bGUoKSArICc6ICcpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgZm10ID0gY29sb3IoJ2NoZWNrbWFyaycsICcgIC0nKVxcbiAgICAgICsgY29sb3IoJ3BlbmRpbmcnLCAnICVzJyk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLmRvdClcXG4gICAgICArIGNvbG9yKCdwYXNzJywgJyAlczogJylcXG4gICAgICArIGNvbG9yKHRlc3Quc3BlZWQsICclZG1zJyk7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCksIHRlc3QuZHVyYXRpb24pO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExpc3QsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1OH1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIENvbnN0YW50c1xcbiAqL1xcblxcbnZhciBTVUlURV9QUkVGSVggPSAnJCc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBNYXJrZG93bmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWFya2Rvd247XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTWFya2Rvd25gIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTWFya2Rvd24ocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBsZXZlbCA9IDA7XFxuICB2YXIgYnVmID0gJyc7XFxuXFxuICBmdW5jdGlvbiB0aXRsZShzdHIpIHtcXG4gICAgcmV0dXJuIEFycmF5KGxldmVsKS5qb2luKCcjJykgKyAnICcgKyBzdHI7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYXBUT0Moc3VpdGUsIG9iaikge1xcbiAgICB2YXIgcmV0ID0gb2JqO1xcbiAgICB2YXIga2V5ID0gU1VJVEVfUFJFRklYICsgc3VpdGUudGl0bGU7XFxuXFxuICAgIG9iaiA9IG9ialtrZXldID0gb2JqW2tleV0gfHwgeyBzdWl0ZTogc3VpdGUgfTtcXG4gICAgc3VpdGUuc3VpdGVzLmZvckVhY2goZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgICBtYXBUT0Moc3VpdGUsIG9iaik7XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RyaW5naWZ5VE9DKG9iaiwgbGV2ZWwpIHtcXG4gICAgKytsZXZlbDtcXG4gICAgdmFyIGJ1ZiA9ICcnO1xcbiAgICB2YXIgbGluaztcXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICAgIGlmIChrZXkgPT09ICdzdWl0ZScpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoa2V5ICE9PSBTVUlURV9QUkVGSVgpIHtcXG4gICAgICAgIGxpbmsgPSAnIC0gWycgKyBrZXkuc3Vic3RyaW5nKDEpICsgJ10nO1xcbiAgICAgICAgbGluayArPSAnKCMnICsgdXRpbHMuc2x1ZyhvYmpba2V5XS5zdWl0ZS5mdWxsVGl0bGUoKSkgKyAnKVxcXFxuJztcXG4gICAgICAgIGJ1ZiArPSBBcnJheShsZXZlbCkuam9pbignICAnKSArIGxpbms7XFxuICAgICAgfVxcbiAgICAgIGJ1ZiArPSBzdHJpbmdpZnlUT0Mob2JqW2tleV0sIGxldmVsKTtcXG4gICAgfVxcbiAgICByZXR1cm4gYnVmO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVUT0Moc3VpdGUpIHtcXG4gICAgdmFyIG9iaiA9IG1hcFRPQyhzdWl0ZSwge30pO1xcbiAgICByZXR1cm4gc3RyaW5naWZ5VE9DKG9iaiwgMCk7XFxuICB9XFxuXFxuICBnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBzbHVnID0gdXRpbHMuc2x1ZyhzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuICAgIGJ1ZiArPSAnPGEgbmFtZT1cXFwiJyArIHNsdWcgKyAnXFxcIj48L2E+JyArICdcXFxcbic7XFxuICAgIGJ1ZiArPSB0aXRsZShzdWl0ZS50aXRsZSkgKyAnXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICAtLWxldmVsO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuY2xlYW4odGVzdC5ib2R5KTtcXG4gICAgYnVmICs9IHRlc3QudGl0bGUgKyAnLlxcXFxuJztcXG4gICAgYnVmICs9ICdcXFxcbmBgYGpzXFxcXG4nO1xcbiAgICBidWYgKz0gY29kZSArICdcXFxcbic7XFxuICAgIGJ1ZiArPSAnYGBgXFxcXG5cXFxcbic7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCcjIFRPQ1xcXFxuJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShidWYpO1xcbiAgfSk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1OH1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWluYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNaW47XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTWluYCBtaW5pbWFsIHRlc3QgcmVwb3J0ZXIgKGJlc3QgdXNlZCB3aXRoIC0td2F0Y2gpLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTWluKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIC8vIGNsZWFyIHNjcmVlblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzJKJyk7XFxuICAgIC8vIHNldCBjdXJzb3IgcG9zaXRpb25cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsxOzNIJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgdGhpcy5lcGlsb2d1ZS5iaW5kKHRoaXMpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTWluLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTh9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYERvdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTnlhbkNhdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gTnlhbkNhdChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAuNzUgfCAwO1xcbiAgdmFyIG55YW5DYXRXaWR0aCA9IHRoaXMubnlhbkNhdFdpZHRoID0gMTE7XFxuXFxuICB0aGlzLmNvbG9ySW5kZXggPSAwO1xcbiAgdGhpcy5udW1iZXJPZkxpbmVzID0gNDtcXG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcXG4gIHRoaXMuc2NvcmVib2FyZFdpZHRoID0gNTtcXG4gIHRoaXMudGljayA9IDA7XFxuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XFxuICB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCA9ICh3aWR0aCAtIG55YW5DYXRXaWR0aCk7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIEJhc2UuY3Vyc29yLmhpZGUoKTtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKCkge1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24oKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbigpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIEJhc2UuY3Vyc29yLnNob3coKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm51bWJlck9mTGluZXM7IGkrKykge1xcbiAgICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgICB9XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhOeWFuQ2F0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBueWFuIGNhdFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5hcHBlbmRSYWluYm93KCk7XFxuICB0aGlzLmRyYXdTY29yZWJvYXJkKCk7XFxuICB0aGlzLmRyYXdSYWluYm93KCk7XFxuICB0aGlzLmRyYXdOeWFuQ2F0KCk7XFxuICB0aGlzLnRpY2sgPSAhdGhpcy50aWNrO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgXFxcInNjb3JlYm9hcmRcXFwiIHNob3dpbmcgdGhlIG51bWJlclxcbiAqIG9mIHBhc3NlcywgZmFpbHVyZXMgYW5kIHBlbmRpbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3U2NvcmVib2FyZCA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG5cXG4gIGZ1bmN0aW9uIGRyYXcodHlwZSwgbikge1xcbiAgICB3cml0ZSgnICcpO1xcbiAgICB3cml0ZShCYXNlLmNvbG9yKHR5cGUsIG4pKTtcXG4gICAgd3JpdGUoJ1xcXFxuJyk7XFxuICB9XFxuXFxuICBkcmF3KCdncmVlbicsIHN0YXRzLnBhc3Nlcyk7XFxuICBkcmF3KCdmYWlsJywgc3RhdHMuZmFpbHVyZXMpO1xcbiAgZHJhdygncGVuZGluZycsIHN0YXRzLnBlbmRpbmcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBBcHBlbmQgdGhlIHJhaW5ib3cuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5hcHBlbmRSYWluYm93ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VnbWVudCA9IHRoaXMudGljayA/ICdfJyA6ICctJztcXG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XFxuXFxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5udW1iZXJPZkxpbmVzOyBpbmRleCsrKSB7XFxuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xcbiAgICBpZiAodHJhamVjdG9yeS5sZW5ndGggPj0gdGhpcy50cmFqZWN0b3J5V2lkdGhNYXgpIHtcXG4gICAgICB0cmFqZWN0b3J5LnNoaWZ0KCk7XFxuICAgIH1cXG4gICAgdHJhamVjdG9yeS5wdXNoKHJhaW5ib3dpZmllZCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIHRoaXMudHJhamVjdG9yaWVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xcbiAgICB3cml0ZSgnXFxcXHUwMDFiWycgKyBzZWxmLnNjb3JlYm9hcmRXaWR0aCArICdDJyk7XFxuICAgIHdyaXRlKGxpbmUuam9pbignJykpO1xcbiAgICB3cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgbnlhbiBjYXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmRyYXdOeWFuQ2F0ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xcbiAgdmFyIGRpc3QgPSAnXFxcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xcbiAgdmFyIHBhZGRpbmcgPSAnJztcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgd3JpdGUoJ18sLS0tLS0tLCcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnICAnIDogJyAgICc7XFxuICB3cml0ZSgnX3wnICsgcGFkZGluZyArICcvXFxcXFxcXFxfL1xcXFxcXFxcICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnXycgOiAnX18nO1xcbiAgdmFyIHRhaWwgPSBzZWxmLnRpY2sgPyAnficgOiAnXic7XFxuICB3cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcXG4gIHdyaXRlKHBhZGRpbmcgKyAnXFxcIlxcXCIgIFxcXCJcXFwiICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZmFjZSA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICByZXR1cm4gJyggeCAueCknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wZW5kaW5nKSB7XFxuICAgIHJldHVybiAnKCBvIC5vKSc7XFxuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xcbiAgICByZXR1cm4gJyggXiAuXiknO1xcbiAgfVxcbiAgcmV0dXJuICcoIC0gLi0pJztcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIHVwIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbihuKSB7XFxuICB3cml0ZSgnXFxcXHUwMDFiWycgKyBuICsgJ0EnKTtcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIGRvd24gYG5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24obikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdCJyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgY29sb3JzID0gW107XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8ICg2ICogNyk7IGkrKykge1xcbiAgICB2YXIgcGkzID0gTWF0aC5mbG9vcihNYXRoLlBJIC8gMyk7XFxuICAgIHZhciBuID0gKGkgKiAoMS4wIC8gNikpO1xcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4pICsgMyk7XFxuICAgIHZhciBnID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obiArIDIgKiBwaTMpICsgMyk7XFxuICAgIHZhciBiID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obiArIDQgKiBwaTMpICsgMyk7XFxuICAgIGNvbG9ycy5wdXNoKDM2ICogciArIDYgKiBnICsgYiArIDE2KTtcXG4gIH1cXG5cXG4gIHJldHVybiBjb2xvcnM7XFxufTtcXG5cXG4vKipcXG4gKiBBcHBseSByYWluYm93IHRvIHRoZSBnaXZlbiBgc3RyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUucmFpbmJvd2lmeSA9IGZ1bmN0aW9uKHN0cikge1xcbiAgaWYgKCFCYXNlLnVzZUNvbG9ycykge1xcbiAgICByZXR1cm4gc3RyO1xcbiAgfVxcbiAgdmFyIGNvbG9yID0gdGhpcy5yYWluYm93Q29sb3JzW3RoaXMuY29sb3JJbmRleCAlIHRoaXMucmFpbmJvd0NvbG9ycy5sZW5ndGhdO1xcbiAgdGhpcy5jb2xvckluZGV4ICs9IDE7XFxuICByZXR1cm4gJ1xcXFx1MDAxYlszODs1OycgKyBjb2xvciArICdtJyArIHN0ciArICdcXFxcdTAwMWJbMG0nO1xcbn07XFxuXFxuLyoqXFxuICogU3Rkb3V0IGhlbHBlci5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQSBtZXNzYWdlIHRvIHdyaXRlIHRvIHN0ZG91dC5cXG4gKi9cXG5mdW5jdGlvbiB3cml0ZShzdHJpbmcpIHtcXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHN0cmluZyk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1OH1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUHJvZ3Jlc3NgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzO1xcblxcbi8qKlxcbiAqIEdlbmVyYWwgcHJvZ3Jlc3MgYmFyIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnByb2dyZXNzID0gOTA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUHJvZ3Jlc3NgIGJhciB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKi9cXG5mdW5jdGlvbiBQcm9ncmVzcyhydW5uZXIsIG9wdGlvbnMpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAuNTAgfCAwO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcbiAgdmFyIGNvbXBsZXRlID0gMDtcXG4gIHZhciBsYXN0TiA9IC0xO1xcblxcbiAgLy8gZGVmYXVsdCBjaGFyc1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICBvcHRpb25zLm9wZW4gPSBvcHRpb25zLm9wZW4gfHwgJ1snO1xcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGUgfHwgJ+KWrCc7XFxuICBvcHRpb25zLmluY29tcGxldGUgPSBvcHRpb25zLmluY29tcGxldGUgfHwgQmFzZS5zeW1ib2xzLmRvdDtcXG4gIG9wdGlvbnMuY2xvc2UgPSBvcHRpb25zLmNsb3NlIHx8ICddJztcXG4gIG9wdGlvbnMudmVyYm9zZSA9IGZhbHNlO1xcblxcbiAgLy8gdGVzdHMgc3RhcnRlZFxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBjdXJzb3IuaGlkZSgpO1xcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBjb21wbGV0ZVxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb21wbGV0ZSsrO1xcblxcbiAgICB2YXIgcGVyY2VudCA9IGNvbXBsZXRlIC8gdG90YWw7XFxuICAgIHZhciBuID0gd2lkdGggKiBwZXJjZW50IHwgMDtcXG4gICAgdmFyIGkgPSB3aWR0aCAtIG47XFxuXFxuICAgIGlmIChuID09PSBsYXN0TiAmJiAhb3B0aW9ucy52ZXJib3NlKSB7XFxuICAgICAgLy8gRG9uJ3QgcmUtcmVuZGVyIHRoZSBsaW5lIGlmIGl0IGhhc24ndCBjaGFuZ2VkXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGxhc3ROID0gbjtcXG5cXG4gICAgY3Vyc29yLkNSKCk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbSicpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncHJvZ3Jlc3MnLCAnICAnICsgb3B0aW9ucy5vcGVuKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KG4pLmpvaW4ob3B0aW9ucy5jb21wbGV0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShBcnJheShpKS5qb2luKG9wdGlvbnMuaW5jb21wbGV0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncHJvZ3Jlc3MnLCBvcHRpb25zLmNsb3NlKSk7XFxuICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncHJvZ3Jlc3MnLCAnICcgKyBjb21wbGV0ZSArICcgb2YgJyArIHRvdGFsKSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gdGVzdHMgYXJlIGNvbXBsZXRlLCBvdXRwdXQgc29tZSBzdGF0c1xcbiAgLy8gYW5kIHRoZSBmYWlsdXJlcyBpZiBhbnlcXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIGN1cnNvci5zaG93KCk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhQcm9ncmVzcywgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOSxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjU4fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3BlY2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3BlYztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTcGVjYCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gU3BlYyhydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIGluZGVudHMgPSAwO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50KCkge1xcbiAgICByZXR1cm4gQXJyYXkoaW5kZW50cykuam9pbignICAnKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ3N1aXRlJywgJyVzJXMnKSwgaW5kZW50KCksIHN1aXRlLnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgLS1pbmRlbnRzO1xcbiAgICBpZiAoaW5kZW50cyA9PT0gMSkge1xcbiAgICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgZm10ID0gaW5kZW50KCkgKyBjb2xvcigncGVuZGluZycsICcgIC0gJXMnKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgZm10O1xcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ2Zhc3QnKSB7XFxuICAgICAgZm10ID0gaW5kZW50KClcXG4gICAgICAgICsgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spXFxuICAgICAgICArIGNvbG9yKCdwYXNzJywgJyAlcycpO1xcbiAgICAgIGN1cnNvci5DUigpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm10ID0gaW5kZW50KClcXG4gICAgICAgICsgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spXFxuICAgICAgICArIGNvbG9yKCdwYXNzJywgJyAlcycpXFxuICAgICAgICArIGNvbG9yKHRlc3Quc3BlZWQsICcgKCVkbXMpJyk7XFxuICAgICAgY3Vyc29yLkNSKCk7XFxuICAgICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlLCB0ZXN0LmR1cmF0aW9uKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgc2VsZi5lcGlsb2d1ZS5iaW5kKHNlbGYpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3BlYywgQmFzZSk7XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOSxcXFwiLi9iYXNlXFxcIjoxN31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBUQVBgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFRBUDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBUQVBgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gVEFQKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgbiA9IDE7XFxuICB2YXIgcGFzc2VzID0gMDtcXG4gIHZhciBmYWlsdXJlcyA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciB0b3RhbCA9IHJ1bm5lci5ncmVwVG90YWwocnVubmVyLnN1aXRlKTtcXG4gICAgY29uc29sZS5sb2coJyVkLi4lZCcsIDEsIHRvdGFsKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICArK247XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzICMgU0tJUCAtJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHBhc3NlcysrO1xcbiAgICBjb25zb2xlLmxvZygnb2sgJWQgJXMnLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgICBmYWlsdXJlcysrO1xcbiAgICBjb25zb2xlLmxvZygnbm90IG9rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgICBpZiAoZXJyLnN0YWNrKSB7XFxuICAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygnIyB0ZXN0cyAnICsgKHBhc3NlcyArIGZhaWx1cmVzKSk7XFxuICAgIGNvbnNvbGUubG9nKCcjIHBhc3MgJyArIHBhc3Nlcyk7XFxuICAgIGNvbnNvbGUubG9nKCcjIGZhaWwgJyArIGZhaWx1cmVzKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBUQVAtc2FmZSB0aXRsZSBvZiBgdGVzdGBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRpdGxlKHRlc3QpIHtcXG4gIHJldHVybiB0ZXN0LmZ1bGxUaXRsZSgpLnJlcGxhY2UoLyMvZywgJycpO1xcbn1cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjoxN31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xcbnZhciBlc2NhcGUgPSB1dGlscy5lc2NhcGU7XFxudmFyIG1rZGlycCA9IHJlcXVpcmUoJ21rZGlycCcpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBFeHBvc2UgYFhVbml0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBYVW5pdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBYVW5pdGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBYVW5pdChydW5uZXIsIG9wdGlvbnMpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciB0ZXN0cyA9IFtdO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgaWYgKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zICYmIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkge1xcbiAgICBpZiAoIWZzLmNyZWF0ZVdyaXRlU3RyZWFtKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlIG91dHB1dCBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcXG4gICAgfVxcbiAgICBta2RpcnAuc3luYyhwYXRoLmRpcm5hbWUob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KSk7XFxuICAgIHNlbGYuZmlsZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBzZWxmLndyaXRlKHRhZygndGVzdHN1aXRlJywge1xcbiAgICAgIG5hbWU6ICdNb2NoYSBUZXN0cycsXFxuICAgICAgdGVzdHM6IHN0YXRzLnRlc3RzLFxcbiAgICAgIGZhaWx1cmVzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICBlcnJvcnM6IHN0YXRzLmZhaWx1cmVzLFxcbiAgICAgIHNraXBwZWQ6IHN0YXRzLnRlc3RzIC0gc3RhdHMuZmFpbHVyZXMgLSBzdGF0cy5wYXNzZXMsXFxuICAgICAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkudG9VVENTdHJpbmcoKSxcXG4gICAgICB0aW1lOiAoc3RhdHMuZHVyYXRpb24gLyAxMDAwKSB8fCAwXFxuICAgIH0sIGZhbHNlKSk7XFxuXFxuICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24odCkge1xcbiAgICAgIHNlbGYudGVzdCh0KTtcXG4gICAgfSk7XFxuXFxuICAgIHNlbGYud3JpdGUoJzwvdGVzdHN1aXRlPicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFhVbml0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBPdmVycmlkZSBkb25lIHRvIGNsb3NlIHRoZSBzdHJlYW0gKGlmIGl0J3MgYSBmaWxlKS5cXG4gKlxcbiAqIEBwYXJhbSBmYWlsdXJlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuWFVuaXQucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbihmYWlsdXJlcywgZm4pIHtcXG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcXG4gICAgdGhpcy5maWxlU3RyZWFtLmVuZChmdW5jdGlvbigpIHtcXG4gICAgICBmbihmYWlsdXJlcyk7XFxuICAgIH0pO1xcbiAgfSBlbHNlIHtcXG4gICAgZm4oZmFpbHVyZXMpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogV3JpdGUgb3V0IHRoZSBnaXZlbiBsaW5lLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmVcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihsaW5lKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyhsaW5lKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHB1dCB0YWcgZm9yIHRoZSBnaXZlbiBgdGVzdC5gXFxuICpcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHRlc3QpIHtcXG4gIHZhciBhdHRycyA9IHtcXG4gICAgY2xhc3NuYW1lOiB0ZXN0LnBhcmVudC5mdWxsVGl0bGUoKSxcXG4gICAgbmFtZTogdGVzdC50aXRsZSxcXG4gICAgdGltZTogKHRlc3QuZHVyYXRpb24gLyAxMDAwKSB8fCAwXFxuICB9O1xcblxcbiAgaWYgKHRlc3Quc3RhdGUgPT09ICdmYWlsZWQnKSB7XFxuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIGZhbHNlLCB0YWcoJ2ZhaWx1cmUnLCB7fSwgZmFsc2UsIGVzY2FwZShlcnIubWVzc2FnZSkgKyAnXFxcXG4nICsgZXNjYXBlKGVyci5zdGFjaykpKSk7XFxuICB9IGVsc2UgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIGZhbHNlLCB0YWcoJ3NraXBwZWQnLCB7fSwgdHJ1ZSkpKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCB0cnVlKSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBIVE1MIHRhZyBoZWxwZXIuXFxuICpcXG4gKiBAcGFyYW0gbmFtZVxcbiAqIEBwYXJhbSBhdHRyc1xcbiAqIEBwYXJhbSBjbG9zZVxcbiAqIEBwYXJhbSBjb250ZW50XFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRhZyhuYW1lLCBhdHRycywgY2xvc2UsIGNvbnRlbnQpIHtcXG4gIHZhciBlbmQgPSBjbG9zZSA/ICcvPicgOiAnPic7XFxuICB2YXIgcGFpcnMgPSBbXTtcXG4gIHZhciB0YWc7XFxuXFxuICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRycywga2V5KSkge1xcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz1cXFwiJyArIGVzY2FwZShhdHRyc1trZXldKSArICdcXFwiJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRhZyA9ICc8JyArIG5hbWUgKyAocGFpcnMubGVuZ3RoID8gJyAnICsgcGFpcnMuam9pbignICcpIDogJycpICsgZW5kO1xcbiAgaWYgKGNvbnRlbnQpIHtcXG4gICAgdGFnICs9IGNvbnRlbnQgKyAnPC8nICsgbmFtZSArIGVuZDtcXG4gIH1cXG4gIHJldHVybiB0YWc7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOSxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjU4LFxcXCJmc1xcXCI6NDMsXFxcIm1rZGlycFxcXCI6NTUsXFxcInBhdGhcXFwiOjQzfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uYWJsZScpO1xcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuL21zJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcoKS5cXG4gKi9cXG5cXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUnVubmFibGVgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUnVubmFibGU7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUnVubmFibGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gUnVubmFibGUodGl0bGUsIGZuKSB7XFxuICB0aGlzLnRpdGxlID0gdGl0bGU7XFxuICB0aGlzLmZuID0gZm47XFxuICB0aGlzLmJvZHkgPSAoZm4gfHwgJycpLnRvU3RyaW5nKCk7XFxuICB0aGlzLmFzeW5jID0gZm4gJiYgZm4ubGVuZ3RoO1xcbiAgdGhpcy5zeW5jID0gIXRoaXMuYXN5bmM7XFxuICB0aGlzLl90aW1lb3V0ID0gMjAwMDtcXG4gIHRoaXMuX3Nsb3cgPSA3NTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gdHJ1ZTtcXG4gIHRoaXMudGltZWRPdXQgPSBmYWxzZTtcXG4gIHRoaXMuX3RyYWNlID0gbmV3IEVycm9yKCdkb25lKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XFxuICB0aGlzLl9yZXRyaWVzID0gLTE7XFxuICB0aGlzLl9jdXJyZW50UmV0cnkgPSAwO1xcbiAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUnVubmFibGUsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogU2V0ICYgZ2V0IHRpbWVvdXQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxudW1iZXJ9IG1zIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24obXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcXG4gIH1cXG4gIGlmIChtcyA9PT0gMCkge1xcbiAgICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGZhbHNlO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCBtcyk7XFxuICB0aGlzLl90aW1lb3V0ID0gbXM7XFxuICBpZiAodGhpcy50aW1lcikge1xcbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgJiBnZXQgc2xvdyBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9zbG93O1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCBtcyk7XFxuICB0aGlzLl9zbG93ID0gbXM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBhbmQgZ2V0IHdoZXRoZXIgdGltZW91dCBpcyBgZW5hYmxlZGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxib29sZWFufSBlbmFibGVkIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlVGltZW91dHM7XFxuICB9XFxuICBkZWJ1ZygnZW5hYmxlVGltZW91dHMgJXMnLCBlbmFibGVkKTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZW5hYmxlZDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSGFsdCBhbmQgbWFyayBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhyb3cgbmV3IFBlbmRpbmcoKTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHRoaXMgcnVubmFibGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBudW1iZXIgb2YgcmV0cmllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xcbiAgfVxcbiAgdGhpcy5fcmV0cmllcyA9IG47XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgY3VycmVudCByZXRyeVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmN1cnJlbnRSZXRyeSA9IGZ1bmN0aW9uKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJldHJ5O1xcbiAgfVxcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gbjtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiBmdWxsIHRpdGxlLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpICsgJyAnICsgdGhpcy50aXRsZTtcXG59O1xcblxcbi8qKlxcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKCkge1xcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbn07XFxuXFxuLyoqXFxuICogSW5zcGVjdCB0aGUgcnVubmFibGUgdm9pZCBvZiBwcml2YXRlIHByb3BlcnRpZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLCBmdW5jdGlvbihrZXksIHZhbCkge1xcbiAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKGtleSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICByZXR1cm4gJyM8U3VpdGU+JztcXG4gICAgfVxcbiAgICBpZiAoa2V5ID09PSAnY3R4Jykge1xcbiAgICAgIHJldHVybiAnIzxDb250ZXh0Pic7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH0sIDIpO1xcbn07XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmVzZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKSB8fCAxZTk7XFxuXFxuICBpZiAoIXRoaXMuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XFxuICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgaWYgKCFzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzZWxmLmNhbGxiYWNrKG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgbXMgKyAnbXMgZXhjZWVkZWQuIEVuc3VyZSB0aGUgZG9uZSgpIGNhbGxiYWNrIGlzIGJlaW5nIGNhbGxlZCBpbiB0aGlzIHRlc3QuJykpO1xcbiAgICBzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcXG4gIH0sIG1zKTtcXG59O1xcblxcbi8qKlxcbiAqIFdoaXRlbGlzdCBhIGxpc3Qgb2YgZ2xvYmFscyBmb3IgdGhpcyB0ZXN0IHJ1bi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdsb2JhbHNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uKGdsb2JhbHMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fYWxsb3dlZEdsb2JhbHM7XFxuICB9XFxuICB0aGlzLl9hbGxvd2VkR2xvYmFscyA9IGdsb2JhbHM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGhlIHRlc3QgYW5kIGludm9rZSBgZm4oZXJyKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcXG4gIHZhciBjdHggPSB0aGlzLmN0eDtcXG4gIHZhciBmaW5pc2hlZDtcXG4gIHZhciBlbWl0dGVkO1xcblxcbiAgLy8gU29tZXRpbWVzIHRoZSBjdHggZXhpc3RzLCBidXQgaXQgaXMgbm90IHJ1bm5hYmxlXFxuICBpZiAoY3R4ICYmIGN0eC5ydW5uYWJsZSkge1xcbiAgICBjdHgucnVubmFibGUodGhpcyk7XFxuICB9XFxuXFxuICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcXG4gIGZ1bmN0aW9uIG11bHRpcGxlKGVycikge1xcbiAgICBpZiAoZW1pdHRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyciB8fCBuZXcgRXJyb3IoJ2RvbmUoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXM7IHN0YWNrdHJhY2UgbWF5IGJlIGluYWNjdXJhdGUnKSk7XFxuICB9XFxuXFxuICAvLyBmaW5pc2hlZFxcbiAgZnVuY3Rpb24gZG9uZShlcnIpIHtcXG4gICAgdmFyIG1zID0gc2VsZi50aW1lb3V0KCk7XFxuICAgIGlmIChzZWxmLnRpbWVkT3V0KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChmaW5pc2hlZCkge1xcbiAgICAgIHJldHVybiBtdWx0aXBsZShlcnIgfHwgc2VsZi5fdHJhY2UpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KCk7XFxuICAgIHNlbGYuZHVyYXRpb24gPSBuZXcgRGF0ZSgpIC0gc3RhcnQ7XFxuICAgIGZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgaWYgKCFlcnIgJiYgc2VsZi5kdXJhdGlvbiA+IG1zICYmIHNlbGYuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgICAgZXJyID0gbmV3IEVycm9yKCd0aW1lb3V0IG9mICcgKyBtcyArICdtcyBleGNlZWRlZC4gRW5zdXJlIHRoZSBkb25lKCkgY2FsbGJhY2sgaXMgYmVpbmcgY2FsbGVkIGluIHRoaXMgdGVzdC4nKTtcXG4gICAgfVxcbiAgICBmbihlcnIpO1xcbiAgfVxcblxcbiAgLy8gZm9yIC5yZXNldFRpbWVvdXQoKVxcbiAgdGhpcy5jYWxsYmFjayA9IGRvbmU7XFxuXFxuICAvLyBleHBsaWNpdCBhc3luYyB3aXRoIGBkb25lYCBhcmd1bWVudFxcbiAgaWYgKHRoaXMuYXN5bmMpIHtcXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcXG5cXG4gICAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICAgIHJldHVybiBjYWxsRm5Bc3luYyh0aGlzLmZuKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBkb25lKHV0aWxzLmdldEVycm9yKGVycikpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICBkb25lKCk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIHN5bmMgb3IgcHJvbWlzZS1yZXR1cm5pbmdcXG4gIHRyeSB7XFxuICAgIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgICAgZG9uZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxGbih0aGlzLmZuKTtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGRvbmUodXRpbHMuZ2V0RXJyb3IoZXJyKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsRm4oZm4pIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4KTtcXG4gICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBzZWxmLnJlc2V0VGltZW91dCgpO1xcbiAgICAgIHJlc3VsdFxcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGRvbmUoKTtcXG4gICAgICAgICAgLy8gUmV0dXJuIG51bGwgc28gbGlicmFyaWVzIGxpa2UgYmx1ZWJpcmQgZG8gbm90IHdhcm4gYWJvdXRcXG4gICAgICAgICAgLy8gc3Vic2VxdWVudGx5IGNvbnN0cnVjdGVkIFByb21pc2VzLlxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmdW5jdGlvbihyZWFzb24pIHtcXG4gICAgICAgICAgZG9uZShyZWFzb24gfHwgbmV3IEVycm9yKCdQcm9taXNlIHJlamVjdGVkIHdpdGggbm8gb3IgZmFsc3kgcmVhc29uJykpO1xcbiAgICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHNlbGYuYXN5bmNPbmx5KSB7XFxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJy0tYXN5bmMtb25seSBvcHRpb24gaW4gdXNlIHdpdGhvdXQgZGVjbGFyaW5nIGBkb25lKClgIG9yIHJldHVybmluZyBhIHByb21pc2UnKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbmUoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FsbEZuQXN5bmMoZm4pIHtcXG4gICAgZm4uY2FsbChjdHgsIGZ1bmN0aW9uKGVycikge1xcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcXG4gICAgICAgIHJldHVybiBkb25lKGVycik7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcXG4gICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdkb25lKCkgaW52b2tlZCB3aXRoIG5vbi1FcnJvcjogJ1xcbiAgICAgICAgICAgICsgSlNPTi5zdHJpbmdpZnkoZXJyKSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdkb25lKCkgaW52b2tlZCB3aXRoIG5vbi1FcnJvcjogJyArIGVycikpO1xcbiAgICAgIH1cXG4gICAgICBkb25lKCk7XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbXNcXFwiOjE1LFxcXCIuL3BlbmRpbmdcXFwiOjE2LFxcXCIuL3V0aWxzXFxcIjozOSxcXFwiZGVidWdcXFwiOjIsXFxcImV2ZW50c1xcXCI6M31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmVyJyk7XFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBmaWx0ZXIgPSB1dGlscy5maWx0ZXI7XFxudmFyIGluZGV4T2YgPSB1dGlscy5pbmRleE9mO1xcbnZhciBrZXlzID0gdXRpbHMua2V5cztcXG52YXIgc3RhY2tGaWx0ZXIgPSB1dGlscy5zdGFja1RyYWNlRmlsdGVyKCk7XFxudmFyIHN0cmluZ2lmeSA9IHV0aWxzLnN0cmluZ2lmeTtcXG52YXIgdHlwZSA9IHV0aWxzLnR5cGU7XFxudmFyIHVuZGVmaW5lZEVycm9yID0gdXRpbHMudW5kZWZpbmVkRXJyb3I7XFxudmFyIGlzQXJyYXkgPSB1dGlscy5pc0FycmF5O1xcblxcbi8qKlxcbiAqIE5vbi1lbnVtZXJhYmxlIGdsb2JhbHMuXFxuICovXFxuXFxudmFyIGdsb2JhbHMgPSBbXFxuICAnc2V0VGltZW91dCcsXFxuICAnY2xlYXJUaW1lb3V0JyxcXG4gICdzZXRJbnRlcnZhbCcsXFxuICAnY2xlYXJJbnRlcnZhbCcsXFxuICAnWE1MSHR0cFJlcXVlc3QnLFxcbiAgJ0RhdGUnLFxcbiAgJ3NldEltbWVkaWF0ZScsXFxuICAnY2xlYXJJbW1lZGlhdGUnXFxuXTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFJ1bm5lcmAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSdW5uZXI7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIGBSdW5uZXJgIGZvciB0aGUgZ2l2ZW4gYHN1aXRlYC5cXG4gKlxcbiAqIEV2ZW50czpcXG4gKlxcbiAqICAgLSBgc3RhcnRgICBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgZW5kYCAgZXhlY3V0aW9uIGNvbXBsZXRlXFxuICogICAtIGBzdWl0ZWAgIChzdWl0ZSkgdGVzdCBzdWl0ZSBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgc3VpdGUgZW5kYCAgKHN1aXRlKSBhbGwgdGVzdHMgKGFuZCBzdWItc3VpdGVzKSBoYXZlIGZpbmlzaGVkXFxuICogICAtIGB0ZXN0YCAgKHRlc3QpIHRlc3QgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYHRlc3QgZW5kYCAgKHRlc3QpIHRlc3QgY29tcGxldGVkXFxuICogICAtIGBob29rYCAgKGhvb2spIGhvb2sgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYGhvb2sgZW5kYCAgKGhvb2spIGhvb2sgY29tcGxldGVcXG4gKiAgIC0gYHBhc3NgICAodGVzdCkgdGVzdCBwYXNzZWRcXG4gKiAgIC0gYGZhaWxgICAodGVzdCwgZXJyKSB0ZXN0IGZhaWxlZFxcbiAqICAgLSBgcGVuZGluZ2AgICh0ZXN0KSB0ZXN0IHBlbmRpbmdcXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlbGF5XSBXaGV0aGVyIG9yIG5vdCB0byBkZWxheSBleGVjdXRpb24gb2Ygcm9vdCBzdWl0ZVxcbiAqIHVudGlsIHJlYWR5LlxcbiAqL1xcbmZ1bmN0aW9uIFJ1bm5lcihzdWl0ZSwgZGVsYXkpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHRoaXMuX2dsb2JhbHMgPSBbXTtcXG4gIHRoaXMuX2Fib3J0ID0gZmFsc2U7XFxuICB0aGlzLl9kZWxheSA9IGRlbGF5O1xcbiAgdGhpcy5zdWl0ZSA9IHN1aXRlO1xcbiAgdGhpcy5zdGFydGVkID0gZmFsc2U7XFxuICB0aGlzLnRvdGFsID0gc3VpdGUudG90YWwoKTtcXG4gIHRoaXMuZmFpbHVyZXMgPSAwO1xcbiAgdGhpcy5vbigndGVzdCBlbmQnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHNlbGYuY2hlY2tHbG9iYWxzKHRlc3QpO1xcbiAgfSk7XFxuICB0aGlzLm9uKCdob29rIGVuZCcsIGZ1bmN0aW9uKGhvb2spIHtcXG4gICAgc2VsZi5jaGVja0dsb2JhbHMoaG9vayk7XFxuICB9KTtcXG4gIHRoaXMuX2RlZmF1bHRHcmVwID0gLy4qLztcXG4gIHRoaXMuZ3JlcCh0aGlzLl9kZWZhdWx0R3JlcCk7XFxuICB0aGlzLmdsb2JhbHModGhpcy5nbG9iYWxQcm9wcygpLmNvbmNhdChleHRyYUdsb2JhbHMoKSkpO1xcbn1cXG5cXG4vKipcXG4gKiBXcmFwcGVyIGZvciBzZXRJbW1lZGlhdGUsIHByb2Nlc3MubmV4dFRpY2ssIG9yIGJyb3dzZXIgcG9seWZpbGwuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5pbW1lZGlhdGVseSA9IGdsb2JhbC5zZXRJbW1lZGlhdGUgfHwgcHJvY2Vzcy5uZXh0VGljaztcXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFJ1bm5lciwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgd2l0aCBmdWxsIHRpdGxlcyBtYXRjaGluZyBgcmVgLiBVcGRhdGVzIHJ1bm5lci50b3RhbFxcbiAqIHdpdGggbnVtYmVyIG9mIHRlc3RzIG1hdGNoZWQuXFxuICpcXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGludmVydFxcbiAqIEByZXR1cm4ge1J1bm5lcn0gZm9yIGNoYWluaW5nXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydFxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uKHJlLCBpbnZlcnQpIHtcXG4gIGRlYnVnKCdncmVwICVzJywgcmUpO1xcbiAgdGhpcy5fZ3JlcCA9IHJlO1xcbiAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xcbiAgdGhpcy50b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHRoaXMuc3VpdGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGVzdHMgbWF0Y2hpbmcgdGhlIGdyZXAgc2VhcmNoIGZvciB0aGVcXG4gKiBnaXZlbiBzdWl0ZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHJldHVybiB7TnVtYmVyfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwVG90YWwgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gMDtcXG5cXG4gIHN1aXRlLmVhY2hUZXN0KGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XFxuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XFxuICAgIH1cXG4gICAgaWYgKG1hdGNoKSB7XFxuICAgICAgdG90YWwrKztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGdsb2JhbCBwcm9wZXJ0aWVzLlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxQcm9wcyA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHByb3BzID0ga2V5cyhnbG9iYWwpO1xcblxcbiAgLy8gbm9uLWVudW1lcmFibGVzXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JhbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKH5pbmRleE9mKHByb3BzLCBnbG9iYWxzW2ldKSkge1xcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIHByb3BzLnB1c2goZ2xvYmFsc1tpXSk7XFxuICB9XFxuXFxuICByZXR1cm4gcHJvcHM7XFxufTtcXG5cXG4vKipcXG4gKiBBbGxvdyB0aGUgZ2l2ZW4gYGFycmAgb2YgZ2xvYmFscy5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEByZXR1cm4ge1J1bm5lcn0gZm9yIGNoYWluaW5nXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbihhcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcXG4gIH1cXG4gIGRlYnVnKCdnbG9iYWxzICVqJywgYXJyKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChhcnIpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBmb3IgZ2xvYmFsIHZhcmlhYmxlIGxlYWtzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5jaGVja0dsb2JhbHMgPSBmdW5jdGlvbih0ZXN0KSB7XFxuICBpZiAodGhpcy5pZ25vcmVMZWFrcykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgb2sgPSB0aGlzLl9nbG9iYWxzO1xcblxcbiAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbFByb3BzKCk7XFxuICB2YXIgbGVha3M7XFxuXFxuICBpZiAodGVzdCkge1xcbiAgICBvayA9IG9rLmNvbmNhdCh0ZXN0Ll9hbGxvd2VkR2xvYmFscyB8fCBbXSk7XFxuICB9XFxuXFxuICBpZiAodGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9PT0gZ2xvYmFscy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9IGdsb2JhbHMubGVuZ3RoO1xcblxcbiAgbGVha3MgPSBmaWx0ZXJMZWFrcyhvaywgZ2xvYmFscyk7XFxuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQobGVha3MpO1xcblxcbiAgaWYgKGxlYWtzLmxlbmd0aCA+IDEpIHtcXG4gICAgdGhpcy5mYWlsKHRlc3QsIG5ldyBFcnJvcignZ2xvYmFsIGxlYWtzIGRldGVjdGVkOiAnICsgbGVha3Muam9pbignLCAnKSArICcnKSk7XFxuICB9IGVsc2UgaWYgKGxlYWtzLmxlbmd0aCkge1xcbiAgICB0aGlzLmZhaWwodGVzdCwgbmV3IEVycm9yKCdnbG9iYWwgbGVhayBkZXRlY3RlZDogJyArIGxlYWtzWzBdKSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBGYWlsIHRoZSBnaXZlbiBgdGVzdGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbih0ZXN0LCBlcnIpIHtcXG4gICsrdGhpcy5mYWlsdXJlcztcXG4gIHRlc3Quc3RhdGUgPSAnZmFpbGVkJztcXG5cXG4gIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IGVyciAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSkge1xcbiAgICBlcnIgPSBuZXcgRXJyb3IoJ3RoZSAnICsgdHlwZShlcnIpICsgJyAnICsgc3RyaW5naWZ5KGVycikgKyAnIHdhcyB0aHJvd24sIHRocm93IGFuIEVycm9yIDopJyk7XFxuICB9XFxuXFxuICBlcnIuc3RhY2sgPSAodGhpcy5mdWxsU3RhY2tUcmFjZSB8fCAhZXJyLnN0YWNrKVxcbiAgICA/IGVyci5zdGFja1xcbiAgICA6IHN0YWNrRmlsdGVyKGVyci5zdGFjayk7XFxuXFxuICB0aGlzLmVtaXQoJ2ZhaWwnLCB0ZXN0LCBlcnIpO1xcbn07XFxuXFxuLyoqXFxuICogRmFpbCB0aGUgZ2l2ZW4gYGhvb2tgIHdpdGggYGVycmAuXFxuICpcXG4gKiBIb29rIGZhaWx1cmVzIHdvcmsgaW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxcbiAqIC0gSWYgYmFpbCwgdGhlbiBleGl0XFxuICogLSBGYWlsZWQgYGJlZm9yZWAgaG9vayBza2lwcyBhbGwgdGVzdHMgaW4gYSBzdWl0ZSBhbmQgc3Vic3VpdGVzLFxcbiAqICAgYnV0IGp1bXBzIHRvIGNvcnJlc3BvbmRpbmcgYGFmdGVyYCBob29rXFxuICogLSBGYWlsZWQgYGJlZm9yZSBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXFxuICogICBzdWl0ZSBhbmQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgaG9vayxcXG4gKiAgIHdoaWNoIGlzIHJ1biBvbmx5IG9uY2VcXG4gKiAtIEZhaWxlZCBgYWZ0ZXJgIGhvb2sgZG9lcyBub3QgYWx0ZXJcXG4gKiAgIGV4ZWN1dGlvbiBvcmRlclxcbiAqIC0gRmFpbGVkIGBhZnRlciBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXFxuICogICBzdWl0ZSBhbmQgc3Vic3VpdGVzLCBidXQgZXhlY3V0ZXMgb3RoZXIgYGFmdGVyIGVhY2hgXFxuICogICBob29rc1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtIb29rfSBob29rXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5mYWlsSG9vayA9IGZ1bmN0aW9uKGhvb2ssIGVycikge1xcbiAgaWYgKGhvb2suY3R4ICYmIGhvb2suY3R4LmN1cnJlbnRUZXN0KSB7XFxuICAgIGhvb2sub3JpZ2luYWxUaXRsZSA9IGhvb2sub3JpZ2luYWxUaXRsZSB8fCBob29rLnRpdGxlO1xcbiAgICBob29rLnRpdGxlID0gaG9vay5vcmlnaW5hbFRpdGxlICsgJyBmb3IgXFxcIicgKyBob29rLmN0eC5jdXJyZW50VGVzdC50aXRsZSArICdcXFwiJztcXG4gIH1cXG5cXG4gIHRoaXMuZmFpbChob29rLCBlcnIpO1xcbiAgaWYgKHRoaXMuc3VpdGUuYmFpbCgpKSB7XFxuICAgIHRoaXMuZW1pdCgnZW5kJyk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9vayBgbmFtZWAgY2FsbGJhY2tzIGFuZCB0aGVuIGludm9rZSBgZm4oKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuXFxuUnVubmVyLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgaG9va3MgPSBzdWl0ZVsnXycgKyBuYW1lXTtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG5leHQoaSkge1xcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xcbiAgICBpZiAoIWhvb2spIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcbiAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IGhvb2s7XFxuXFxuICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gc2VsZi50ZXN0O1xcblxcbiAgICBzZWxmLmVtaXQoJ2hvb2snLCBob29rKTtcXG5cXG4gICAgaWYgKCFob29rLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcXG4gICAgICBob29rLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgc2VsZi5mYWlsSG9vayhob29rLCBlcnIpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGhvb2sucnVuKGZ1bmN0aW9uKGVycikge1xcbiAgICAgIHZhciB0ZXN0RXJyb3IgPSBob29rLmVycm9yKCk7XFxuICAgICAgaWYgKHRlc3RFcnJvcikge1xcbiAgICAgICAgc2VsZi5mYWlsKHNlbGYudGVzdCwgdGVzdEVycm9yKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgc3VpdGUucGVuZGluZyA9IHRydWU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWxmLmZhaWxIb29rKGhvb2ssIGVycik7XFxuXFxuICAgICAgICAgIC8vIHN0b3AgZXhlY3V0aW5nIGhvb2tzLCBub3RpZnkgY2FsbGVlIG9mIGhvb2sgZXJyXFxuICAgICAgICAgIHJldHVybiBmbihlcnIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBzZWxmLmVtaXQoJ2hvb2sgZW5kJywgaG9vayk7XFxuICAgICAgZGVsZXRlIGhvb2suY3R4LmN1cnJlbnRUZXN0O1xcbiAgICAgIG5leHQoKytpKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBSdW5uZXIuaW1tZWRpYXRlbHkoZnVuY3Rpb24oKSB7XFxuICAgIG5leHQoMCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rIGBuYW1lYCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGBzdWl0ZXNgXFxuICogaW4gb3JkZXIsIGFuZCBjYWxsYmFjayBgZm4oZXJyLCBlcnJTdWl0ZSlgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va3MgPSBmdW5jdGlvbihuYW1lLCBzdWl0ZXMsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgb3JpZyA9IHRoaXMuc3VpdGU7XFxuXFxuICBmdW5jdGlvbiBuZXh0KHN1aXRlKSB7XFxuICAgIHNlbGYuc3VpdGUgPSBzdWl0ZTtcXG5cXG4gICAgaWYgKCFzdWl0ZSkge1xcbiAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuaG9vayhuYW1lLCBmdW5jdGlvbihlcnIpIHtcXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICB2YXIgZXJyU3VpdGUgPSBzZWxmLnN1aXRlO1xcbiAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgICByZXR1cm4gZm4oZXJyLCBlcnJTdWl0ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIG5leHQoc3VpdGVzLnBvcCgpKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBuZXh0KHN1aXRlcy5wb3AoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9va3MgZnJvbSB0aGUgdG9wIGxldmVsIGRvd24uXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rVXAgPSBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpLnJldmVyc2UoKTtcXG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9va3MgZnJvbSB0aGUgYm90dG9tIHVwLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va0Rvd24gPSBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpO1xcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBvZiBwYXJlbnQgU3VpdGVzIGZyb21cXG4gKiBjbG9zZXN0IHRvIGZ1cnRoZXN0LlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIHN1aXRlcyA9IFtdO1xcbiAgd2hpbGUgKHN1aXRlLnBhcmVudCkge1xcbiAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudDtcXG4gICAgc3VpdGVzLnB1c2goc3VpdGUpO1xcbiAgfVxcbiAgcmV0dXJuIHN1aXRlcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgY3VycmVudCB0ZXN0IGFuZCBjYWxsYmFjayBgZm4oZXJyKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuVGVzdCA9IGZ1bmN0aW9uKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdCA9IHRoaXMudGVzdDtcXG5cXG4gIGlmICh0aGlzLmFzeW5jT25seSkge1xcbiAgICB0ZXN0LmFzeW5jT25seSA9IHRydWU7XFxuICB9XFxuXFxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgIHRlc3QuYWxsb3dVbmNhdWdodCA9IHRydWU7XFxuICAgIHJldHVybiB0ZXN0LnJ1bihmbik7XFxuICB9XFxuICB0cnkge1xcbiAgICB0ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xcbiAgICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgICB9KTtcXG4gICAgdGVzdC5ydW4oZm4pO1xcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGZuKGVycik7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgaW4gdGhlIGdpdmVuIGBzdWl0ZWAgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0cyA9IGZ1bmN0aW9uKHN1aXRlLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gc3VpdGUudGVzdHMuc2xpY2UoKTtcXG4gIHZhciB0ZXN0O1xcblxcbiAgZnVuY3Rpb24gaG9va0VycihfLCBlcnJTdWl0ZSwgYWZ0ZXIpIHtcXG4gICAgLy8gYmVmb3JlL2FmdGVyIEVhY2ggaG9vayBmb3IgZXJyU3VpdGUgZmFpbGVkOlxcbiAgICB2YXIgb3JpZyA9IHNlbGYuc3VpdGU7XFxuXFxuICAgIC8vIGZvciBmYWlsZWQgJ2FmdGVyIGVhY2gnIGhvb2sgc3RhcnQgZnJvbSBlcnJTdWl0ZSBwYXJlbnQsXFxuICAgIC8vIG90aGVyd2lzZSBzdGFydCBmcm9tIGVyclN1aXRlIGl0c2VsZlxcbiAgICBzZWxmLnN1aXRlID0gYWZ0ZXIgPyBlcnJTdWl0ZS5wYXJlbnQgOiBlcnJTdWl0ZTtcXG5cXG4gICAgaWYgKHNlbGYuc3VpdGUpIHtcXG4gICAgICAvLyBjYWxsIGhvb2tVcCBhZnRlckVhY2hcXG4gICAgICBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgZnVuY3Rpb24oZXJyMiwgZXJyU3VpdGUyKSB7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIC8vIHNvbWUgaG9va3MgbWF5IGZhaWwgZXZlbiBub3dcXG4gICAgICAgIGlmIChlcnIyKSB7XFxuICAgICAgICAgIHJldHVybiBob29rRXJyKGVycjIsIGVyclN1aXRlMiwgdHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyByZXBvcnQgZXJyb3Igc3VpdGVcXG4gICAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIGNhbGxpbmcgb3RoZXIgJ2FmdGVyIGVhY2gnIGhvb2tzXFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBuZXh0KGVyciwgZXJyU3VpdGUpIHtcXG4gICAgLy8gaWYgd2UgYmFpbCBhZnRlciBmaXJzdCBlcnJcXG4gICAgaWYgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgLy8gbmV4dCB0ZXN0XFxuICAgIHRlc3QgPSB0ZXN0cy5zaGlmdCgpO1xcblxcbiAgICAvLyBhbGwgZG9uZVxcbiAgICBpZiAoIXRlc3QpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICAvLyBncmVwXFxuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gICAgaWYgKHNlbGYuX2ludmVydCkge1xcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xcbiAgICB9XFxuICAgIGlmICghbWF0Y2gpIHtcXG4gICAgICAvLyBSdW4gaW1tZWRpYXRlbHkgb25seSBpZiB3ZSBoYXZlIGRlZmluZWQgYSBncmVwLiBXaGVuIHdlXFxuICAgICAgLy8gZGVmaW5lIGEgZ3JlcCDigJQgSXQgY2FuIGNhdXNlIG1heGltdW0gY2FsbHN0YWNrIGVycm9yIGlmXFxuICAgICAgLy8gdGhlIGdyZXAgaXMgZG9pbmcgYSBsYXJnZSByZWN1cnNpdmUgbG9vcCBieSBuZWdsZWN0aW5nXFxuICAgICAgLy8gYWxsIHRlc3RzLiBUaGUgcnVuIGltbWVkaWF0ZWx5IGZ1bmN0aW9uIGFsc28gY29tZXMgd2l0aFxcbiAgICAgIC8vIGEgcGVyZm9ybWFuY2UgY29zdC4gU28gd2UgZG9uJ3Qgd2FudCB0byBydW4gaW1tZWRpYXRlbHlcXG4gICAgICAvLyBpZiB3ZSBydW4gdGhlIHdob2xlIHRlc3Qgc3VpdGUsIGJlY2F1c2UgcnVubmluZyB0aGUgd2hvbGVcXG4gICAgICAvLyB0ZXN0IHN1aXRlIGRvbid0IGRvIGFueSBpbW1lZGlhdGUgcmVjdXJzaXZlIGxvb3BzLiBUaHVzLFxcbiAgICAgIC8vIGFsbG93aW5nIGEgSlMgcnVudGltZSB0byBicmVhdGhlLlxcbiAgICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xcbiAgICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KG5leHQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICB9XFxuXFxuICAgIC8vIGV4ZWN1dGUgdGVzdCBhbmQgaG9vayhzKVxcbiAgICBzZWxmLmVtaXQoJ3Rlc3QnLCBzZWxmLnRlc3QgPSB0ZXN0KTtcXG4gICAgc2VsZi5ob29rRG93bignYmVmb3JlRWFjaCcsIGZ1bmN0aW9uKGVyciwgZXJyU3VpdGUpIHtcXG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IHNlbGYudGVzdDtcXG4gICAgICBzZWxmLnJ1blRlc3QoZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgICB0ZXN0ID0gc2VsZi50ZXN0O1xcbiAgICAgICAgaWYgKGVycikge1xcbiAgICAgICAgICB2YXIgcmV0cnkgPSB0ZXN0LmN1cnJlbnRSZXRyeSgpO1xcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICAgIHRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgICAgc2VsZi5lbWl0KCdwZW5kaW5nJywgdGVzdCk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocmV0cnkgPCB0ZXN0LnJldHJpZXMoKSkge1xcbiAgICAgICAgICAgIHZhciBjbG9uZWRUZXN0ID0gdGVzdC5jbG9uZSgpO1xcbiAgICAgICAgICAgIGNsb25lZFRlc3QuY3VycmVudFJldHJ5KHJldHJ5ICsgMSk7XFxuICAgICAgICAgICAgdGVzdHMudW5zaGlmdChjbG9uZWRUZXN0KTtcXG5cXG4gICAgICAgICAgICAvLyBFYXJseSByZXR1cm4gKyBob29rIHRyaWdnZXIgc28gdGhhdCBpdCBkb2Vzbid0XFxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjb3VudCB3cm9uZ1xcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIGVycik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcblxcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRlc3Quc3RhdGUgPSAncGFzc2VkJztcXG4gICAgICAgIHNlbGYuZW1pdCgncGFzcycsIHRlc3QpO1xcbiAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgICAgc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHRoaXMubmV4dCA9IG5leHQ7XFxuICB0aGlzLmhvb2tFcnIgPSBob29rRXJyO1xcbiAgbmV4dCgpO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuU3VpdGUgPSBmdW5jdGlvbihzdWl0ZSwgZm4pIHtcXG4gIHZhciBpID0gMDtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHN1aXRlKTtcXG4gIHZhciBhZnRlckFsbEhvb2tDYWxsZWQgPSBmYWxzZTtcXG5cXG4gIGRlYnVnKCdydW4gc3VpdGUgJXMnLCBzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuXFxuICBpZiAoIXRvdGFsIHx8IChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSkge1xcbiAgICByZXR1cm4gZm4oKTtcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCB0aGlzLnN1aXRlID0gc3VpdGUpO1xcblxcbiAgZnVuY3Rpb24gbmV4dChlcnJTdWl0ZSkge1xcbiAgICBpZiAoZXJyU3VpdGUpIHtcXG4gICAgICAvLyBjdXJyZW50IHN1aXRlIGZhaWxlZCBvbiBhIGhvb2sgZnJvbSBlcnJTdWl0ZVxcbiAgICAgIGlmIChlcnJTdWl0ZSA9PT0gc3VpdGUpIHtcXG4gICAgICAgIC8vIGlmIGVyclN1aXRlIGlzIGN1cnJlbnQgc3VpdGVcXG4gICAgICAgIC8vIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHNpYmxpbmcgc3VpdGVcXG4gICAgICAgIHJldHVybiBkb25lKCk7XFxuICAgICAgfVxcbiAgICAgIC8vIGVyclN1aXRlIGlzIGFtb25nIHRoZSBwYXJlbnRzIG9mIGN1cnJlbnQgc3VpdGVcXG4gICAgICAvLyBzdG9wIGV4ZWN1dGlvbiBvZiBlcnJTdWl0ZSBhbmQgYWxsIHN1Yi1zdWl0ZXNcXG4gICAgICByZXR1cm4gZG9uZShlcnJTdWl0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcblxcbiAgICB2YXIgY3VyciA9IHN1aXRlLnN1aXRlc1tpKytdO1xcbiAgICBpZiAoIWN1cnIpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuXFxuICAgIC8vIEF2b2lkIGdyZXAgbmVnbGVjdGluZyBsYXJnZSBudW1iZXIgb2YgdGVzdHMgY2F1c2luZyBhXFxuICAgIC8vIGh1Z2UgcmVjdXJzaXZlIGxvb3AgYW5kIHRodXMgYSBtYXhpbXVtIGNhbGwgc3RhY2sgZXJyb3IuXFxuICAgIC8vIFNlZSBjb21tZW50IGluIGB0aGlzLnJ1blRlc3RzKClgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcbiAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcXG4gICAgICBSdW5uZXIuaW1tZWRpYXRlbHkoZnVuY3Rpb24oKSB7XFxuICAgICAgICBzZWxmLnJ1blN1aXRlKGN1cnIsIG5leHQpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRvbmUoZXJyU3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcbiAgICBzZWxmLm5leHRTdWl0ZSA9IG5leHQ7XFxuXFxuICAgIGlmIChhZnRlckFsbEhvb2tDYWxsZWQpIHtcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gbWFyayB0aGF0IHRoZSBhZnRlckFsbCBibG9jayBoYXMgYmVlbiBjYWxsZWQgb25jZVxcbiAgICAgIC8vIGFuZCBzbyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiBpdC5cXG4gICAgICBhZnRlckFsbEhvb2tDYWxsZWQgPSB0cnVlO1xcblxcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdGVzdFxcbiAgICAgIGRlbGV0ZSBzZWxmLnRlc3Q7XFxuXFxuICAgICAgc2VsZi5ob29rKCdhZnRlckFsbCcsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgc2VsZi5lbWl0KCdzdWl0ZSBlbmQnLCBzdWl0ZSk7XFxuICAgICAgICBmbihlcnJTdWl0ZSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRoaXMubmV4dFN1aXRlID0gbmV4dDtcXG5cXG4gIHRoaXMuaG9vaygnYmVmb3JlQWxsJywgZnVuY3Rpb24oZXJyKSB7XFxuICAgIGlmIChlcnIpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuICAgIHNlbGYucnVuVGVzdHMoc3VpdGUsIG5leHQpO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBIYW5kbGUgdW5jYXVnaHQgZXhjZXB0aW9ucy5cXG4gKlxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUudW5jYXVnaHQgPSBmdW5jdGlvbihlcnIpIHtcXG4gIGlmIChlcnIpIHtcXG4gICAgZGVidWcoJ3VuY2F1Z2h0IGV4Y2VwdGlvbiAlcycsIGVyciAhPT0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0uY2FsbChlcnIpID8gZXJyIDogKGVyci5tZXNzYWdlIHx8IGVycikpO1xcbiAgfSBlbHNlIHtcXG4gICAgZGVidWcoJ3VuY2F1Z2h0IHVuZGVmaW5lZCBleGNlcHRpb24nKTtcXG4gICAgZXJyID0gdW5kZWZpbmVkRXJyb3IoKTtcXG4gIH1cXG4gIGVyci51bmNhdWdodCA9IHRydWU7XFxuXFxuICB2YXIgcnVubmFibGUgPSB0aGlzLmN1cnJlbnRSdW5uYWJsZTtcXG5cXG4gIGlmICghcnVubmFibGUpIHtcXG4gICAgcnVubmFibGUgPSBuZXcgUnVubmFibGUoJ1VuY2F1Z2h0IGVycm9yIG91dHNpZGUgdGVzdCBzdWl0ZScpO1xcbiAgICBydW5uYWJsZS5wYXJlbnQgPSB0aGlzLnN1aXRlO1xcblxcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XFxuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIENhbid0IHJlY292ZXIgZnJvbSB0aGlzIGZhaWx1cmVcXG4gICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XFxuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgcnVubmFibGUuY2xlYXJUaW1lb3V0KCk7XFxuXFxuICAvLyBJZ25vcmUgZXJyb3JzIGlmIGNvbXBsZXRlXFxuICBpZiAocnVubmFibGUuc3RhdGUpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcblxcbiAgLy8gcmVjb3ZlciBmcm9tIHRlc3RcXG4gIGlmIChydW5uYWJsZS50eXBlID09PSAndGVzdCcpIHtcXG4gICAgdGhpcy5lbWl0KCd0ZXN0IGVuZCcsIHJ1bm5hYmxlKTtcXG4gICAgdGhpcy5ob29rVXAoJ2FmdGVyRWFjaCcsIHRoaXMubmV4dCk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gLy8gcmVjb3ZlciBmcm9tIGhvb2tzXFxuICBpZiAocnVubmFibGUudHlwZSA9PT0gJ2hvb2snKSB7XFxuICAgIHZhciBlcnJTdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBhZnRlckVhY2ggYmxvY2tcXG4gICAgaWYgKHJ1bm5hYmxlLmZ1bGxUaXRsZSgpLmluZGV4T2YoJ2FmdGVyIGVhY2gnKSA+IC0xKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcXG4gICAgfVxcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYmVmb3JlRWFjaCBibG9ja1xcbiAgICBpZiAocnVubmFibGUuZnVsbFRpdGxlKCkuaW5kZXhPZignYmVmb3JlIGVhY2gnKSA+IC0xKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuaG9va0VycihlcnIsIGVyclN1aXRlLCBmYWxzZSk7XFxuICAgIH1cXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGFmdGVyIG9yIGJlZm9yZSBibG9ja3NcXG4gICAgcmV0dXJuIHRoaXMubmV4dFN1aXRlKGVyclN1aXRlKTtcXG4gIH1cXG5cXG4gIC8vIGJhaWxcXG4gIHRoaXMuZW1pdCgnZW5kJyk7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhbnMgdXAgdGhlIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnNcXG4gKiAoYmVmb3JlL2FmdGVyL2JlZm9yZUVhY2gvYWZ0ZXJFYWNoKSBhbmQgdGVzdHMgb2YgYSBTdWl0ZS5cXG4gKiBUaGVzZSBtdXN0IGJlIGRlbGV0ZWQgb3RoZXJ3aXNlIGEgbWVtb3J5IGxlYWsgY2FuIGhhcHBlbixcXG4gKiBhcyB0aG9zZSBmdW5jdGlvbnMgbWF5IHJlZmVyZW5jZSB2YXJpYWJsZXMgZnJvbSBjbG9zdXJlcyxcXG4gKiB0aHVzIHRob3NlIHZhcmlhYmxlcyBjYW4gbmV2ZXIgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYXMgbG9uZ1xcbiAqIGFzIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnMgZXhpc3QuXFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuU3VpdGVSZWZlcmVuY2VzKHN1aXRlKSB7XFxuICBmdW5jdGlvbiBjbGVhbkFyclJlZmVyZW5jZXMoYXJyKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgZGVsZXRlIGFycltpXS5mbjtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2JlZm9yZUFsbCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9iZWZvcmVBbGwpO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2JlZm9yZUVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlRWFjaCk7XFxuICB9XFxuXFxuICBpZiAoaXNBcnJheShzdWl0ZS5fYWZ0ZXJBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJBbGwpO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2FmdGVyRWFjaCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9hZnRlckVhY2gpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZS50ZXN0cy5sZW5ndGg7IGkrKykge1xcbiAgICBkZWxldGUgc3VpdGUudGVzdHNbaV0uZm47XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFJ1biB0aGUgcm9vdCBzdWl0ZSBhbmQgaW52b2tlIGBmbihmYWlsdXJlcylgXFxuICogb24gY29tcGxldGlvbi5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfSBmb3IgY2hhaW5pbmdcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHJvb3RTdWl0ZSA9IHRoaXMuc3VpdGU7XFxuXFxuICBmbiA9IGZuIHx8IGZ1bmN0aW9uKCkge307XFxuXFxuICBmdW5jdGlvbiB1bmNhdWdodChlcnIpIHtcXG4gICAgc2VsZi51bmNhdWdodChlcnIpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XFxuICAgIHNlbGYuc3RhcnRlZCA9IHRydWU7XFxuICAgIHNlbGYuZW1pdCgnc3RhcnQnKTtcXG4gICAgc2VsZi5ydW5TdWl0ZShyb290U3VpdGUsIGZ1bmN0aW9uKCkge1xcbiAgICAgIGRlYnVnKCdmaW5pc2hlZCBydW5uaW5nJyk7XFxuICAgICAgc2VsZi5lbWl0KCdlbmQnKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBkZWJ1Zygnc3RhcnQnKTtcXG5cXG4gIC8vIHJlZmVyZW5jZXMgY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcXG4gIHRoaXMub24oJ3N1aXRlIGVuZCcsIGNsZWFuU3VpdGVSZWZlcmVuY2VzKTtcXG5cXG4gIC8vIGNhbGxiYWNrXFxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgZGVidWcoJ2VuZCcpO1xcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHVuY2F1Z2h0KTtcXG4gICAgZm4oc2VsZi5mYWlsdXJlcyk7XFxuICB9KTtcXG5cXG4gIC8vIHVuY2F1Z2h0IGV4Y2VwdGlvblxcbiAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuXFxuICBpZiAodGhpcy5fZGVsYXkpIHtcXG4gICAgLy8gZm9yIHJlcG9ydGVycywgSSBndWVzcy5cXG4gICAgLy8gbWlnaHQgYmUgbmljZSB0byBkZWJvdW5jZSBzb21lIGRvdHMgd2hpbGUgd2Ugd2FpdC5cXG4gICAgdGhpcy5lbWl0KCd3YWl0aW5nJywgcm9vdFN1aXRlKTtcXG4gICAgcm9vdFN1aXRlLm9uY2UoJ3J1bicsIHN0YXJ0KTtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXJ0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENsZWFubHkgYWJvcnQgZXhlY3V0aW9uLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XFxuICBkZWJ1ZygnYWJvcnRpbmcnKTtcXG4gIHRoaXMuX2Fib3J0ID0gdHJ1ZTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRmlsdGVyIGxlYWtzIHdpdGggdGhlIGdpdmVuIGdsb2JhbHMgZmxhZ2dlZCBhcyBgb2tgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gb2tcXG4gKiBAcGFyYW0ge0FycmF5fSBnbG9iYWxzXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZnVuY3Rpb24gZmlsdGVyTGVha3Mob2ssIGdsb2JhbHMpIHtcXG4gIHJldHVybiBmaWx0ZXIoZ2xvYmFscywgZnVuY3Rpb24oa2V5KSB7XFxuICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBleHBvc2VzIGlmcmFtZXMgYXMgaW5kZXggaW5zaWRlIHRoZSB3aW5kb3cgb2JqZWN0XFxuICAgIGlmICgvXmQrLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gaW4gZmlyZWZveFxcbiAgICAvLyBpZiBydW5uZXIgcnVucyBpbiBhbiBpZnJhbWUsIHRoaXMgaWZyYW1lJ3Mgd2luZG93LmdldEludGVyZmFjZSBtZXRob2Qgbm90IGluaXQgYXQgZmlyc3RcXG4gICAgLy8gaXQgaXMgYXNzaWduZWQgaW4gc29tZSBzZWNvbmRzXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmICgvXmdldEludGVyZmFjZS8pLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBhbiBpZnJhbWUgY291bGQgYmUgYXBwcm9hY2hlZCBieSB3aW5kb3dbaWZyYW1lSW5kZXhdXFxuICAgIC8vIGluIGllNiw3LDggYW5kIG9wZXJhLCBpZnJhbWVJbmRleCBpcyBlbnVtZXJhYmxlLCB0aGlzIGNvdWxkIGNhdXNlIGxlYWtcXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgKC9eXFxcXGQrLykudGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIE9wZXJhIGFuZCBJRSBleHBvc2UgZ2xvYmFsIHZhcmlhYmxlcyBmb3IgSFRNTCBlbGVtZW50IElEcyAoaXNzdWUgIzI0MylcXG4gICAgaWYgKC9ebW9jaGEtLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgdmFyIG1hdGNoZWQgPSBmaWx0ZXIob2ssIGZ1bmN0aW9uKG9rKSB7XFxuICAgICAgaWYgKH5vay5pbmRleE9mKCcqJykpIHtcXG4gICAgICAgIHJldHVybiBrZXkuaW5kZXhPZihvay5zcGxpdCgnKicpWzBdKSA9PT0gMDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGtleSA9PT0gb2s7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gIW1hdGNoZWQubGVuZ3RoICYmICghZ2xvYmFsLm5hdmlnYXRvciB8fCBrZXkgIT09ICdvbmVycm9yJyk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogQXJyYXkgb2YgZ2xvYmFscyBkZXBlbmRlbnQgb24gdGhlIGVudmlyb25tZW50LlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gZXh0cmFHbG9iYWxzKCkge1xcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9uID09PSAnc3RyaW5nJykge1xcbiAgICB2YXIgcGFydHMgPSBwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKTtcXG4gICAgdmFyIG5vZGVWZXJzaW9uID0gdXRpbHMucmVkdWNlKHBhcnRzLCBmdW5jdGlvbihhLCB2KSB7XFxuICAgICAgcmV0dXJuIGEgPDwgOCB8IHY7XFxuICAgIH0pO1xcblxcbiAgICAvLyAnZXJybm8nIHdhcyByZW5hbWVkIHRvIHByb2Nlc3MuX2Vycm5vIGluIHYwLjkuMTEuXFxuXFxuICAgIGlmIChub2RlVmVyc2lvbiA8IDB4MDAwOTBCKSB7XFxuICAgICAgcmV0dXJuIFsnZXJybm8nXTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIFtdO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL3BlbmRpbmdcXFwiOjE2LFxcXCIuL3J1bm5hYmxlXFxcIjozNSxcXFwiLi91dGlsc1xcXCI6MzksXFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwiZGVidWdcXFwiOjIsXFxcImV2ZW50c1xcXCI6M31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIEhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6c3VpdGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3VpdGVgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN1aXRlO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBgU3VpdGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIHBhcmVudCBgU3VpdGVgLiBXaGVuIGEgc3VpdGVcXG4gKiB3aXRoIHRoZSBzYW1lIHRpdGxlIGlzIGFscmVhZHkgcHJlc2VudCwgdGhhdCBzdWl0ZSBpcyByZXR1cm5lZCB0byBwcm92aWRlXFxuICogbmljZXIgcmVwb3J0ZXIgYW5kIG1vcmUgZmxleGlibGUgbWV0YS10ZXN0aW5nLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBwYXJlbnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhcmVudCwgdGl0bGUpIHtcXG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aXRsZSwgcGFyZW50LmN0eCk7XFxuICBzdWl0ZS5wYXJlbnQgPSBwYXJlbnQ7XFxuICB0aXRsZSA9IHN1aXRlLmZ1bGxUaXRsZSgpO1xcbiAgcGFyZW50LmFkZFN1aXRlKHN1aXRlKTtcXG4gIHJldHVybiBzdWl0ZTtcXG59O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBgY3R4YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7Q29udGV4dH0gcGFyZW50Q29udGV4dFxcbiAqL1xcbmZ1bmN0aW9uIFN1aXRlKHRpdGxlLCBwYXJlbnRDb250ZXh0KSB7XFxuICB0aGlzLnRpdGxlID0gdGl0bGU7XFxuICBmdW5jdGlvbiBDb250ZXh0KCkge31cXG4gIENvbnRleHQucHJvdG90eXBlID0gcGFyZW50Q29udGV4dDtcXG4gIHRoaXMuY3R4ID0gbmV3IENvbnRleHQoKTtcXG4gIHRoaXMuc3VpdGVzID0gW107XFxuICB0aGlzLnRlc3RzID0gW107XFxuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcXG4gIHRoaXMuX2JlZm9yZUVhY2ggPSBbXTtcXG4gIHRoaXMuX2JlZm9yZUFsbCA9IFtdO1xcbiAgdGhpcy5fYWZ0ZXJFYWNoID0gW107XFxuICB0aGlzLl9hZnRlckFsbCA9IFtdO1xcbiAgdGhpcy5yb290ID0gIXRpdGxlO1xcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IHRydWU7XFxuICB0aGlzLl9zbG93ID0gNzU7XFxuICB0aGlzLl9iYWlsID0gZmFsc2U7XFxuICB0aGlzLl9yZXRyaWVzID0gLTE7XFxuICB0aGlzLmRlbGF5ZWQgPSBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhTdWl0ZSwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBjbG9uZSBvZiB0aGlzIGBTdWl0ZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aGlzLnRpdGxlKTtcXG4gIGRlYnVnKCdjbG9uZScpO1xcbiAgc3VpdGUuY3R4ID0gdGhpcy5jdHg7XFxuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHN1aXRlLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgc3VpdGUuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xcbiAgc3VpdGUuYmFpbCh0aGlzLmJhaWwoKSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGltZW91dCBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcXFwiMnNcXFwiLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xcbiAgfVxcbiAgaWYgKG1zLnRvU3RyaW5nKCkgPT09ICcwJykge1xcbiAgICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGZhbHNlO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCBtcyk7XFxuICB0aGlzLl90aW1lb3V0ID0gcGFyc2VJbnQobXMsIDEwKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBhIGZhaWxlZCB0ZXN0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcXG4gIH1cXG4gIGRlYnVnKCdyZXRyaWVzICVkJywgbik7XFxuICB0aGlzLl9yZXRyaWVzID0gcGFyc2VJbnQobiwgMTApIHx8IDA7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAgKiBTZXQgdGltZW91dCB0byBgZW5hYmxlZGAuXFxuICAqXFxuICAqIEBhcGkgcHJpdmF0ZVxcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gICogQHJldHVybiB7U3VpdGV8Ym9vbGVhbn0gc2VsZiBvciBlbmFibGVkXFxuICAqL1xcblN1aXRlLnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlVGltZW91dHM7XFxuICB9XFxuICBkZWJ1ZygnZW5hYmxlVGltZW91dHMgJXMnLCBlbmFibGVkKTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZW5hYmxlZDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHNsb3cgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXFxcIjJzXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24obXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCdzbG93ICVkJywgbXMpO1xcbiAgdGhpcy5fc2xvdyA9IG1zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXRzIHdoZXRoZXIgdG8gYmFpbCBhZnRlciBmaXJzdCBlcnJvci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFpbFxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJhaWwgPSBmdW5jdGlvbihiYWlsKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2JhaWw7XFxuICB9XFxuICBkZWJ1ZygnYmFpbCAlcycsIGJhaWwpO1xcbiAgdGhpcy5fYmFpbCA9IGJhaWw7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHRoaXMgc3VpdGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2JlZm9yZUFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVBbGwnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGFsbFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IG5ldyBIb29rKHRpdGxlLCBmbik7XFxuICBob29rLnBhcmVudCA9IHRoaXM7XFxuICBob29rLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgaG9vay5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIGhvb2suZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIGhvb2suc2xvdyh0aGlzLnNsb3coKSk7XFxuICBob29rLmN0eCA9IHRoaXMuY3R4O1xcbiAgdGhpcy5fYWZ0ZXJBbGwucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYWZ0ZXJBbGwnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJiZWZvcmUgZWFjaFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IG5ldyBIb29rKHRpdGxlLCBmbik7XFxuICBob29rLnBhcmVudCA9IHRoaXM7XFxuICBob29rLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgaG9vay5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIGhvb2suZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIGhvb2suc2xvdyh0aGlzLnNsb3coKSk7XFxuICBob29rLmN0eCA9IHRoaXMuY3R4O1xcbiAgdGhpcy5fYmVmb3JlRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2FmdGVyRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckVhY2gnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIGEgdGVzdCBgc3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFkZFN1aXRlID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHN1aXRlLnBhcmVudCA9IHRoaXM7XFxuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHN1aXRlLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgc3VpdGUuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xcbiAgc3VpdGUuYmFpbCh0aGlzLmJhaWwoKSk7XFxuICB0aGlzLnN1aXRlcy5wdXNoKHN1aXRlKTtcXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCBzdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIGB0ZXN0YCB0byB0aGlzIHN1aXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZGRUZXN0ID0gZnVuY3Rpb24odGVzdCkge1xcbiAgdGVzdC5wYXJlbnQgPSB0aGlzO1xcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMudGVzdHMucHVzaCh0ZXN0KTtcXG4gIHRoaXMuZW1pdCgndGVzdCcsIHRlc3QpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogZnVsbCB0aXRsZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbigpIHtcXG4gIGlmICh0aGlzLnBhcmVudCkge1xcbiAgICB2YXIgZnVsbCA9IHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpO1xcbiAgICBpZiAoZnVsbCkge1xcbiAgICAgIHJldHVybiBmdWxsICsgJyAnICsgdGhpcy50aXRsZTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXMudGl0bGU7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50b3RhbCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHV0aWxzLnJlZHVjZSh0aGlzLnN1aXRlcywgZnVuY3Rpb24oc3VtLCBzdWl0ZSkge1xcbiAgICByZXR1cm4gc3VtICsgc3VpdGUudG90YWwoKTtcXG4gIH0sIDApICsgdGhpcy50ZXN0cy5sZW5ndGg7XFxufTtcXG5cXG4vKipcXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxcbiAqIGZ1bmN0aW9uIGluIHRoZSBmb3JtYXQgYGZuKHRlc3QpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmVhY2hUZXN0ID0gZnVuY3Rpb24oZm4pIHtcXG4gIHV0aWxzLmZvckVhY2godGhpcy50ZXN0cywgZm4pO1xcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLnN1aXRlcywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgc3VpdGUuZWFjaFRlc3QoZm4pO1xcbiAgfSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFRoaXMgd2lsbCBydW4gdGhlIHJvb3Qgc3VpdGUgaWYgd2UgaGFwcGVuIHRvIGJlIHJ1bm5pbmcgaW4gZGVsYXllZCBtb2RlLlxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XFxuICBpZiAodGhpcy5yb290KSB7XFxuICAgIHRoaXMuZW1pdCgncnVuJyk7XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi9ob29rXFxcIjo3LFxcXCIuL21zXFxcIjoxNSxcXFwiLi91dGlsc1xcXCI6MzksXFxcImRlYnVnXFxcIjoyLFxcXCJldmVudHNcXFwiOjN9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVGVzdGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRlc3RgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFRlc3QodGl0bGUsIGZuKSB7XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnBlbmRpbmcgPSAhZm47XFxuICB0aGlzLnR5cGUgPSAndGVzdCc7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhUZXN0LCBSdW5uYWJsZSk7XFxuXFxuVGVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcXG4gIHZhciB0ZXN0ID0gbmV3IFRlc3QodGhpcy50aXRsZSwgdGhpcy5mbik7XFxuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHRlc3QuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmN1cnJlbnRSZXRyeSh0aGlzLmN1cnJlbnRSZXRyeSgpKTtcXG4gIHRlc3QuZ2xvYmFscyh0aGlzLmdsb2JhbHMoKSk7XFxuICB0ZXN0LnBhcmVudCA9IHRoaXMucGFyZW50O1xcbiAgdGVzdC5maWxlID0gdGhpcy5maWxlO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHJldHVybiB0ZXN0O1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjM1LFxcXCIuL3V0aWxzXFxcIjozOX1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBiYXNlbmFtZSA9IHJlcXVpcmUoJ3BhdGgnKS5iYXNlbmFtZTtcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTp3YXRjaCcpO1xcbnZhciBleGlzdHMgPSByZXF1aXJlKCdmcycpLmV4aXN0c1N5bmMgfHwgcmVxdWlyZSgncGF0aCcpLmV4aXN0c1N5bmM7XFxudmFyIGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XFxudmFyIGpvaW4gPSByZXF1aXJlKCdwYXRoJykuam9pbjtcXG52YXIgcmVhZGRpclN5bmMgPSByZXF1aXJlKCdmcycpLnJlYWRkaXJTeW5jO1xcbnZhciBzdGF0U3luYyA9IHJlcXVpcmUoJ2ZzJykuc3RhdFN5bmM7XFxudmFyIHdhdGNoRmlsZSA9IHJlcXVpcmUoJ2ZzJykud2F0Y2hGaWxlO1xcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJ3RvLWlzby1zdHJpbmcnKTtcXG5cXG4vKipcXG4gKiBJZ25vcmVkIGRpcmVjdG9yaWVzLlxcbiAqL1xcblxcbnZhciBpZ25vcmUgPSBbJ25vZGVfbW9kdWxlcycsICcuZ2l0J107XFxuXFxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSAge3N0cmluZ30gaHRtbFxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uKGh0bWwpIHtcXG4gIHJldHVybiBTdHJpbmcoaHRtbClcXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcXG4gICAgLnJlcGxhY2UoL1xcXCIvZywgJyZxdW90OycpXFxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I2ZvckVhY2ggKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcXG4gKi9cXG5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbihhcnIsIGZuLCBzY29wZSkge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGZuLmNhbGwoc2NvcGUsIGFycltpXSwgaSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBUZXN0IGlmIHRoZSBnaXZlbiBvYmogaXMgdHlwZSBvZiBzdHJpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XFxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheSNtYXAgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uKGFyciwgZm4sIHNjb3BlKSB7XFxuICB2YXIgcmVzdWx0ID0gW107XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgcmVzdWx0LnB1c2goZm4uY2FsbChzY29wZSwgYXJyW2ldLCBpLCBhcnIpKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheSNpbmRleE9mICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gZmluZCBpbmRleCBvZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5leHBvcnRzLmluZGV4T2YgPSBmdW5jdGlvbihhcnIsIG9iaiwgc3RhcnQpIHtcXG4gIGZvciAodmFyIGkgPSBzdGFydCB8fCAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcXG4gICAgICByZXR1cm4gaTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIC0xO1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjcmVkdWNlICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBJbml0aWFsIHZhbHVlLlxcbiAqIEByZXR1cm4geyp9XFxuICovXFxuZXhwb3J0cy5yZWR1Y2UgPSBmdW5jdGlvbihhcnIsIGZuLCB2YWwpIHtcXG4gIHZhciBydmFsID0gdmFsO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIHJ2YWwgPSBmbihydmFsLCBhcnJbaV0sIGksIGFycik7XFxuICB9XFxuXFxuICByZXR1cm4gcnZhbDtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I2ZpbHRlciAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMuZmlsdGVyID0gZnVuY3Rpb24oYXJyLCBmbikge1xcbiAgdmFyIHJldCA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIHZhciB2YWwgPSBhcnJbaV07XFxuICAgIGlmIChmbih2YWwsIGksIGFycikpIHtcXG4gICAgICByZXQucHVzaCh2YWwpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuLyoqXFxuICogT2JqZWN0LmtleXMgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXFxuICovXFxuZXhwb3J0cy5rZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmtleXMgOiBmdW5jdGlvbihvYmopIHtcXG4gIHZhciBrZXlzID0gW107XFxuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsgLy8gZm9yIGB3aW5kb3dgIG9uIDw9SUU4XFxuXFxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcXG4gICAgICBrZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGtleXM7XFxufTtcXG5cXG4vKipcXG4gKiBXYXRjaCB0aGUgZ2l2ZW4gYGZpbGVzYCBmb3IgY2hhbmdlc1xcbiAqIGFuZCBpbnZva2UgYGZuKGZpbGUpYCBvbiBtb2RpZmljYXRpb24uXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBmaWxlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZXhwb3J0cy53YXRjaCA9IGZ1bmN0aW9uKGZpbGVzLCBmbikge1xcbiAgdmFyIG9wdGlvbnMgPSB7IGludGVydmFsOiAxMDAgfTtcXG4gIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xcbiAgICBkZWJ1ZygnZmlsZSAlcycsIGZpbGUpO1xcbiAgICB3YXRjaEZpbGUoZmlsZSwgb3B0aW9ucywgZnVuY3Rpb24oY3VyciwgcHJldikge1xcbiAgICAgIGlmIChwcmV2Lm10aW1lIDwgY3Vyci5tdGltZSkge1xcbiAgICAgICAgZm4oZmlsZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkuaXNBcnJheSAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICogQHJldHVybiB7Qm9vbGVhbn1cXG4gKi9cXG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uKG9iaikge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xcbn07XFxuXFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG4vKipcXG4gKiBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiBwb2x5ZmlsbC5cXG4gKlxcbiAqIEB0eXBlIHtGdW5jdGlvbn1cXG4gKi9cXG5pZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLnByb3RvdHlwZSkge1xcbiAgQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiB8fCBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIDApO1xcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogSWdub3JlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBpZ25vcmVkKHBhdGgpIHtcXG4gIHJldHVybiAhfmlnbm9yZS5pbmRleE9mKHBhdGgpO1xcbn1cXG5cXG4vKipcXG4gKiBMb29rdXAgZmlsZXMgaW4gdGhlIGdpdmVuIGBkaXJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IGRpclxcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtleHQ9WycuanMnXV1cXG4gKiBAcGFyYW0ge0FycmF5fSBbcmV0PVtdXVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMuZmlsZXMgPSBmdW5jdGlvbihkaXIsIGV4dCwgcmV0KSB7XFxuICByZXQgPSByZXQgfHwgW107XFxuICBleHQgPSBleHQgfHwgWydqcyddO1xcblxcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwuKCcgKyBleHQuam9pbignfCcpICsgJykkJyk7XFxuXFxuICByZWFkZGlyU3luYyhkaXIpXFxuICAgIC5maWx0ZXIoaWdub3JlZClcXG4gICAgLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xcbiAgICAgIHBhdGggPSBqb2luKGRpciwgcGF0aCk7XFxuICAgICAgaWYgKHN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIGV4cG9ydHMuZmlsZXMocGF0aCwgZXh0LCByZXQpO1xcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaChyZSkpIHtcXG4gICAgICAgIHJldC5wdXNoKHBhdGgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuLyoqXFxuICogQ29tcHV0ZSBhIHNsdWcgZnJvbSB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuc2x1ZyA9IGZ1bmN0aW9uKHN0cikge1xcbiAgcmV0dXJuIHN0clxcbiAgICAudG9Mb3dlckNhc2UoKVxcbiAgICAucmVwbGFjZSgvICsvZywgJy0nKVxcbiAgICAucmVwbGFjZSgvW14tXFxcXHddL2csICcnKTtcXG59O1xcblxcbi8qKlxcbiAqIFN0cmlwIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uIGZyb20gYHN0cmAsIGFuZCByZS1pbmRlbnQgZm9yIHByZSB3aGl0ZXNwYWNlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLmNsZWFuID0gZnVuY3Rpb24oc3RyKSB7XFxuICBzdHIgPSBzdHJcXG4gICAgLnJlcGxhY2UoL1xcXFxyXFxcXG4/fFtcXFxcblxcXFx1MjAyOFxcXFx1MjAyOV0vZywgJ1xcXFxuJykucmVwbGFjZSgvXlxcXFx1RkVGRi8sICcnKVxcbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uICpcXFxcKC4qXFxcXClcXFxccypcXFxce3xcXFxcKC4qXFxcXCkgKj0+ICpcXFxcez8vLCAnJylcXG4gICAgLnJlcGxhY2UoL1xcXFxzK1xcXFx9JC8sICcnKTtcXG5cXG4gIHZhciBzcGFjZXMgPSBzdHIubWF0Y2goL15cXFxcbj8oICopLylbMV0ubGVuZ3RoO1xcbiAgdmFyIHRhYnMgPSBzdHIubWF0Y2goL15cXFxcbj8oXFxcXHQqKS8pWzFdLmxlbmd0aDtcXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ15cXFxcbj8nICsgKHRhYnMgPyAnXFxcXHQnIDogJyAnKSArICd7JyArICh0YWJzID8gdGFicyA6IHNwYWNlcykgKyAnfScsICdnbScpO1xcblxcbiAgc3RyID0gc3RyLnJlcGxhY2UocmUsICcnKTtcXG5cXG4gIHJldHVybiBleHBvcnRzLnRyaW0oc3RyKTtcXG59O1xcblxcbi8qKlxcbiAqIFRyaW0gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnRyaW0gPSBmdW5jdGlvbihzdHIpIHtcXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxcXFxzK3xcXFxccyskL2csICcnKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgcXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHFzXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmV4cG9ydHMucGFyc2VRdWVyeSA9IGZ1bmN0aW9uKHFzKSB7XFxuICByZXR1cm4gZXhwb3J0cy5yZWR1Y2UocXMucmVwbGFjZSgnPycsICcnKS5zcGxpdCgnJicpLCBmdW5jdGlvbihvYmosIHBhaXIpIHtcXG4gICAgdmFyIGkgPSBwYWlyLmluZGV4T2YoJz0nKTtcXG4gICAgdmFyIGtleSA9IHBhaXIuc2xpY2UoMCwgaSk7XFxuICAgIHZhciB2YWwgPSBwYWlyLnNsaWNlKCsraSk7XFxuXFxuICAgIG9ialtrZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XFxuICAgIHJldHVybiBvYmo7XFxuICB9LCB7fSk7XFxufTtcXG5cXG4vKipcXG4gKiBIaWdobGlnaHQgdGhlIGdpdmVuIHN0cmluZyBvZiBganNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IGpzXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGhpZ2hsaWdodChqcykge1xcbiAgcmV0dXJuIGpzXFxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxcbiAgICAucmVwbGFjZSgvXFxcXC9cXFxcLyguKikvZ20sICc8c3BhbiBjbGFzcz1cXFwiY29tbWVudFxcXCI+Ly8kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKCcuKj8nKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJzdHJpbmdcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oXFxcXGQrXFxcXC5cXFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XFxcIm51bWJlclxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLyhcXFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XFxcIm51bWJlclxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxibmV3WyBcXFxcdF0rKFxcXFx3KykvZ20sICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+bmV3PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiaW5pdFxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxiKGZ1bmN0aW9ufG5ld3x0aHJvd3xyZXR1cm58dmFyfGlmfGVsc2UpXFxcXGIvZ20sICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+JDE8L3NwYW4+Jyk7XFxufVxcblxcbi8qKlxcbiAqIEhpZ2hsaWdodCB0aGUgY29udGVudHMgb2YgdGFnIGBuYW1lYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICovXFxuZXhwb3J0cy5oaWdobGlnaHRUYWdzID0gZnVuY3Rpb24obmFtZSkge1xcbiAgdmFyIGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKS5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKTtcXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGNvZGVbaV0uaW5uZXJIVE1MID0gaGlnaGxpZ2h0KGNvZGVbaV0uaW5uZXJIVE1MKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIElmIGEgdmFsdWUgY291bGQgaGF2ZSBwcm9wZXJ0aWVzLCBhbmQgaGFzIG5vbmUsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLFxcbiAqIHdoaWNoIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVtcHR5IHZhbHVlLlxcbiAqXFxuICogRnVuY3Rpb25zIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAnW0Z1bmN0aW9uXSdgXFxuICogQXJyYXlzIHcvIGxlbmd0aCA9PT0gMCByZXR1cm4gYCdbXSdgXFxuICogT2JqZWN0cyB3LyBubyBwcm9wZXJ0aWVzIHJldHVybiBgJ3t9J2BcXG4gKiBBbGwgZWxzZTogcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXFxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUsIGlmIGtub3duLlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZSkge1xcbiAgdHlwZSA9IHR5cGUgfHwgZXhwb3J0cy50eXBlKHZhbHVlKTtcXG5cXG4gIHN3aXRjaCAodHlwZSkge1xcbiAgICBjYXNlICdmdW5jdGlvbic6XFxuICAgICAgcmV0dXJuICdbRnVuY3Rpb25dJztcXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICByZXR1cm4gJ3t9JztcXG4gICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIHJldHVybiAnW10nO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBUYWtlcyBzb21lIHZhcmlhYmxlIGFuZCBhc2tzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClgIHdoYXQgaXQgdGhpbmtzIGl0XFxuICogaXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXFxuICogQHJldHVybnMge3N0cmluZ31cXG4gKiBAZXhhbXBsZVxcbiAqIHR5cGUoe30pIC8vICdvYmplY3QnXFxuICogdHlwZShbXSkgLy8gJ2FycmF5J1xcbiAqIHR5cGUoMSkgLy8gJ251bWJlcidcXG4gKiB0eXBlKGZhbHNlKSAvLyAnYm9vbGVhbidcXG4gKiB0eXBlKEluZmluaXR5KSAvLyAnbnVtYmVyJ1xcbiAqIHR5cGUobnVsbCkgLy8gJ251bGwnXFxuICogdHlwZShuZXcgRGF0ZSgpKSAvLyAnZGF0ZSdcXG4gKiB0eXBlKC9mb28vKSAvLyAncmVnZXhwJ1xcbiAqIHR5cGUoJ3R5cGUnKSAvLyAnc3RyaW5nJ1xcbiAqIHR5cGUoZ2xvYmFsKSAvLyAnZ2xvYmFsJ1xcbiAqL1xcbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIHR5cGUodmFsdWUpIHtcXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiAndW5kZWZpbmVkJztcXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcXG4gICAgcmV0dXJuICdudWxsJztcXG4gIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xcbiAgICByZXR1cm4gJ2J1ZmZlcic7XFxuICB9XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxcbiAgICAucmVwbGFjZSgvXlxcXFxbLitcXFxccyguKz8pXFxcXF0kLywgJyQxJylcXG4gICAgLnRvTG93ZXJDYXNlKCk7XFxufTtcXG5cXG4vKipcXG4gKiBTdHJpbmdpZnkgYHZhbHVlYC4gRGlmZmVyZW50IGJlaGF2aW9yIGRlcGVuZGluZyBvbiB0eXBlIG9mIHZhbHVlOlxcbiAqXFxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgbm90IGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgIHdyYXBwZWQgaW4gZG91YmxlLXF1b3Rlcy5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgYW4gKmVtcHR5KiBvYmplY3QsIGZ1bmN0aW9uLCBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBmdW5jdGlvblxcbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxcbiAqIC0gSWYgYHZhbHVlYCBoYXMgcHJvcGVydGllcywgY2FsbCB7QGxpbmsgZXhwb3J0cy5jYW5vbmljYWxpemV9IG9uIGl0LCB0aGVuIHJldHVybiByZXN1bHQgb2ZcXG4gKiAgIEpTT04uc3RyaW5naWZ5KCkuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgdmFyIHR5cGUgPSBleHBvcnRzLnR5cGUodmFsdWUpO1xcblxcbiAgaWYgKCF+ZXhwb3J0cy5pbmRleE9mKFsnb2JqZWN0JywgJ2FycmF5JywgJ2Z1bmN0aW9uJ10sIHR5cGUpKSB7XFxuICAgIGlmICh0eXBlICE9PSAnYnVmZmVyJykge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KHZhbHVlKTtcXG4gICAgfVxcbiAgICB2YXIganNvbiA9IHZhbHVlLnRvSlNPTigpO1xcbiAgICAvLyBCYXNlZCBvbiB0aGUgdG9KU09OIHJlc3VsdFxcbiAgICByZXR1cm4ganNvblN0cmluZ2lmeShqc29uLmRhdGEgJiYganNvbi50eXBlID8ganNvbi5kYXRhIDoganNvbiwgMilcXG4gICAgICAucmVwbGFjZSgvLChcXFxcbnwkKS9nLCAnJDEnKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcHJvcCkpIHtcXG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShleHBvcnRzLmNhbm9uaWNhbGl6ZSh2YWx1ZSksIDIpLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlKTtcXG59O1xcblxcbi8qKlxcbiAqIGxpa2UgSlNPTi5zdHJpbmdpZnkgYnV0IG1vcmUgc2Vuc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gIG9iamVjdFxcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc3BhY2VzXFxuICogQHBhcmFtIHtudW1iZXI9fSBkZXB0aFxcbiAqIEByZXR1cm5zIHsqfVxcbiAqL1xcbmZ1bmN0aW9uIGpzb25TdHJpbmdpZnkob2JqZWN0LCBzcGFjZXMsIGRlcHRoKSB7XFxuICBpZiAodHlwZW9mIHNwYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgLy8gcHJpbWl0aXZlIHR5cGVzXFxuICAgIHJldHVybiBfc3RyaW5naWZ5KG9iamVjdCk7XFxuICB9XFxuXFxuICBkZXB0aCA9IGRlcHRoIHx8IDE7XFxuICB2YXIgc3BhY2UgPSBzcGFjZXMgKiBkZXB0aDtcXG4gIHZhciBzdHIgPSBpc0FycmF5KG9iamVjdCkgPyAnWycgOiAneyc7XFxuICB2YXIgZW5kID0gaXNBcnJheShvYmplY3QpID8gJ10nIDogJ30nO1xcbiAgdmFyIGxlbmd0aCA9IHR5cGVvZiBvYmplY3QubGVuZ3RoID09PSAnbnVtYmVyJyA/IG9iamVjdC5sZW5ndGggOiBleHBvcnRzLmtleXMob2JqZWN0KS5sZW5ndGg7XFxuICAvLyBgLnJlcGVhdCgpYCBwb2x5ZmlsbFxcbiAgZnVuY3Rpb24gcmVwZWF0KHMsIG4pIHtcXG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWwpIHtcXG4gICAgc3dpdGNoIChleHBvcnRzLnR5cGUodmFsKSkge1xcbiAgICAgIGNhc2UgJ251bGwnOlxcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XFxuICAgICAgICB2YWwgPSAnWycgKyB2YWwgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdhcnJheSc6XFxuICAgICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICAgIHZhbCA9IGpzb25TdHJpbmdpZnkodmFsLCBzcGFjZXMsIGRlcHRoICsgMSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICBjYXNlICdyZWdleHAnOlxcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XFxuICAgICAgY2FzZSAnbnVtYmVyJzpcXG4gICAgICAgIHZhbCA9IHZhbCA9PT0gMCAmJiAoMSAvIHZhbCkgPT09IC1JbmZpbml0eSAvLyBgLTBgXFxuICAgICAgICAgID8gJy0wJ1xcbiAgICAgICAgICA6IHZhbC50b1N0cmluZygpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnZGF0ZSc6XFxuICAgICAgICB2YXIgc0RhdGU7XFxuICAgICAgICBpZiAoaXNOYU4odmFsLmdldFRpbWUoKSkpIHsgLy8gSW52YWxpZCBkYXRlXFxuICAgICAgICAgIHNEYXRlID0gdmFsLnRvU3RyaW5nKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzRGF0ZSA9IHZhbC50b0lTT1N0cmluZyA/IHZhbC50b0lTT1N0cmluZygpIDogdG9JU09TdHJpbmcodmFsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhbCA9ICdbRGF0ZTogJyArIHNEYXRlICsgJ10nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnYnVmZmVyJzpcXG4gICAgICAgIHZhciBqc29uID0gdmFsLnRvSlNPTigpO1xcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcXG4gICAgICAgIGpzb24gPSBqc29uLmRhdGEgJiYganNvbi50eXBlID8ganNvbi5kYXRhIDoganNvbjtcXG4gICAgICAgIHZhbCA9ICdbQnVmZmVyOiAnICsganNvblN0cmluZ2lmeShqc29uLCAyLCBkZXB0aCArIDEpICsgJ10nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHZhbCA9ICh2YWwgPT09ICdbRnVuY3Rpb25dJyB8fCB2YWwgPT09ICdbQ2lyY3VsYXJdJylcXG4gICAgICAgICAgPyB2YWxcXG4gICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWwpOyAvLyBzdHJpbmdcXG4gICAgfVxcbiAgICByZXR1cm4gdmFsO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSBpbiBvYmplY3QpIHtcXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBpKSkge1xcbiAgICAgIGNvbnRpbnVlOyAvLyBub3QgbXkgYnVzaW5lc3NcXG4gICAgfVxcbiAgICAtLWxlbmd0aDtcXG4gICAgc3RyICs9ICdcXFxcbiAnICsgcmVwZWF0KCcgJywgc3BhY2UpXFxuICAgICAgKyAoaXNBcnJheShvYmplY3QpID8gJycgOiAnXFxcIicgKyBpICsgJ1xcXCI6ICcpIC8vIGtleVxcbiAgICAgICsgX3N0cmluZ2lmeShvYmplY3RbaV0pICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVcXG4gICAgICArIChsZW5ndGggPyAnLCcgOiAnJyk7ICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFcXG4gIH1cXG5cXG4gIHJldHVybiBzdHJcXG4gICAgLy8gW10sIHt9XFxuICAgICsgKHN0ci5sZW5ndGggIT09IDEgPyAnXFxcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpO1xcbn1cXG5cXG4vKipcXG4gKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBidWZmZXIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuZXhwb3J0cy5pc0J1ZmZlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhIG5ldyBUaGluZyB0aGF0IGhhcyB0aGUga2V5cyBpbiBzb3J0ZWQgb3JkZXIuIFJlY3Vyc2l2ZS5cXG4gKlxcbiAqIElmIHRoZSBUaGluZy4uLlxcbiAqIC0gaGFzIGFscmVhZHkgYmVlbiBzZWVuLCByZXR1cm4gc3RyaW5nIGAnW0NpcmN1bGFyXSdgXFxuICogLSBpcyBgdW5kZWZpbmVkYCwgcmV0dXJuIHN0cmluZyBgJ1t1bmRlZmluZWRdJ2BcXG4gKiAtIGlzIGBudWxsYCwgcmV0dXJuIHZhbHVlIGBudWxsYFxcbiAqIC0gaXMgc29tZSBvdGhlciBwcmltaXRpdmUsIHJldHVybiB0aGUgdmFsdWVcXG4gKiAtIGlzIG5vdCBhIHByaW1pdGl2ZSBvciBhbiBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgVGhpbmcncyBgdG9TdHJpbmcoKWAgbWV0aG9kXFxuICogLSBpcyBhIG5vbi1lbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFnYWluLlxcbiAqIC0gaXMgYW4gZW1wdHkgYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGVtcHR5UmVwcmVzZW50YXRpb24oKWBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUge0BsaW5rIGV4cG9ydHMuc3RyaW5naWZ5fVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhpbmcgdG8gaW5zcGVjdC4gIE1heSBvciBtYXkgbm90IGhhdmUgcHJvcGVydGllcy5cXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2s9W11dIFN0YWNrIG9mIHNlZW4gdmFsdWVzXFxuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkKX1cXG4gKi9cXG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdGFjaykge1xcbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbiAgdmFyIHByb3A7XFxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXFxuICB2YXIgdHlwZSA9IGV4cG9ydHMudHlwZSh2YWx1ZSk7XFxuICBmdW5jdGlvbiB3aXRoU3RhY2sodmFsdWUsIGZuKSB7XFxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xcbiAgICBmbigpO1xcbiAgICBzdGFjay5wb3AoKTtcXG4gIH1cXG5cXG4gIHN0YWNrID0gc3RhY2sgfHwgW107XFxuXFxuICBpZiAoZXhwb3J0cy5pbmRleE9mKHN0YWNrLCB2YWx1ZSkgIT09IC0xKSB7XFxuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICB9XFxuXFxuICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcXG4gICAgY2FzZSAnYnVmZmVyJzpcXG4gICAgY2FzZSAnbnVsbCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdhcnJheSc6XFxuICAgICAgd2l0aFN0YWNrKHZhbHVlLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBleHBvcnRzLm1hcCh2YWx1ZSwgZnVuY3Rpb24oaXRlbSkge1xcbiAgICAgICAgICByZXR1cm4gZXhwb3J0cy5jYW5vbmljYWxpemUoaXRlbSwgc3RhY2spO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cXG4gICAgICBmb3IgKHByb3AgaW4gdmFsdWUpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xcbiAgICAgIGlmICghY2Fub25pY2FsaXplZE9iaikge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGUpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXFxuICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGNhbm9uaWNhbGl6ZWRPYmogfHwge307XFxuICAgICAgd2l0aFN0YWNrKHZhbHVlLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIGV4cG9ydHMuZm9yRWFjaChleHBvcnRzLmtleXModmFsdWUpLnNvcnQoKSwgZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlW2tleV0sIHN0YWNrKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdkYXRlJzpcXG4gICAgY2FzZSAnbnVtYmVyJzpcXG4gICAgY2FzZSAncmVnZXhwJzpcXG4gICAgY2FzZSAnYm9vbGVhbic6XFxuICAgIGNhc2UgJ3N5bWJvbCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZSArICcnO1xcbiAgfVxcblxcbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxufTtcXG5cXG4vKipcXG4gKiBMb29rdXAgZmlsZSBuYW1lcyBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBCYXNlIHBhdGggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXh0ZW5zaW9ucyBGaWxlIGV4dGVuc2lvbnMgdG8gbG9vayBmb3IuXFxuICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgV2hldGhlciBvciBub3QgdG8gcmVjdXJzZSBpbnRvIHN1YmRpcmVjdG9yaWVzLlxcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBwYXRocy5cXG4gKi9cXG5leHBvcnRzLmxvb2t1cEZpbGVzID0gZnVuY3Rpb24gbG9va3VwRmlsZXMocGF0aCwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSB7XFxuICB2YXIgZmlsZXMgPSBbXTtcXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ1xcXFxcXFxcLignICsgZXh0ZW5zaW9ucy5qb2luKCd8JykgKyAnKSQnKTtcXG5cXG4gIGlmICghZXhpc3RzKHBhdGgpKSB7XFxuICAgIGlmIChleGlzdHMocGF0aCArICcuanMnKSkge1xcbiAgICAgIHBhdGggKz0gJy5qcyc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZmlsZXMgPSBnbG9iLnN5bmMocGF0aCk7XFxuICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiY2Fubm90IHJlc29sdmUgcGF0aCAob3IgcGF0dGVybikgJ1xcXCIgKyBwYXRoICsgXFxcIidcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZpbGVzO1xcbiAgICB9XFxuICB9XFxuXFxuICB0cnkge1xcbiAgICB2YXIgc3RhdCA9IHN0YXRTeW5jKHBhdGgpO1xcbiAgICBpZiAoc3RhdC5pc0ZpbGUoKSkge1xcbiAgICAgIHJldHVybiBwYXRoO1xcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgLy8gaWdub3JlIGVycm9yXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHJlYWRkaXJTeW5jKHBhdGgpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xcbiAgICBmaWxlID0gam9pbihwYXRoLCBmaWxlKTtcXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgc3RhdCA9IHN0YXRTeW5jKGZpbGUpO1xcbiAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcXG4gICAgICAgICAgZmlsZXMgPSBmaWxlcy5jb25jYXQobG9va3VwRmlsZXMoZmlsZSwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKCFzdGF0LmlzRmlsZSgpIHx8ICFyZS50ZXN0KGZpbGUpIHx8IGJhc2VuYW1lKGZpbGUpWzBdID09PSAnLicpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZmlsZXMucHVzaChmaWxlKTtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIGZpbGVzO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYW4gdW5kZWZpbmVkIGVycm9yIHdpdGggYSBtZXNzYWdlIHdhcm5pbmcgdGhlIHVzZXIuXFxuICpcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKi9cXG5cXG5leHBvcnRzLnVuZGVmaW5lZEVycm9yID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gbmV3IEVycm9yKCdDYXVnaHQgdW5kZWZpbmVkIGVycm9yLCBkaWQgeW91IHRocm93IHdpdGhvdXQgc3BlY2lmeWluZyB3aGF0PycpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYW4gdW5kZWZpbmVkIGVycm9yIGlmIGBlcnJgIGlzIG5vdCBkZWZpbmVkLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHJldHVybiB7RXJyb3J9XFxuICovXFxuXFxuZXhwb3J0cy5nZXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xcbiAgcmV0dXJuIGVyciB8fCBleHBvcnRzLnVuZGVmaW5lZEVycm9yKCk7XFxufTtcXG5cXG4vKipcXG4gKiBAc3VtbWFyeVxcbiAqIFRoaXMgRmlsdGVyIGJhc2VkIG9uIGBtb2NoYS1jbGVhbmAgbW9kdWxlLihzZWU6IGBnaXRodWIuY29tL3JzdGFjcnV6L21vY2hhLWNsZWFuYClcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBXaGVuIGludm9raW5nIHRoaXMgZnVuY3Rpb24geW91IGdldCBhIGZpbHRlciBmdW5jdGlvbiB0aGF0IGdldCB0aGUgRXJyb3Iuc3RhY2sgYXMgYW4gaW5wdXQsXFxuICogYW5kIHJldHVybiBhIHByZXR0aWZ5IG91dHB1dC5cXG4gKiAoaS5lOiBzdHJpcCBNb2NoYSBhbmQgaW50ZXJuYWwgbm9kZSBmdW5jdGlvbnMgZnJvbSBzdGFjayB0cmFjZSkuXFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxcbiAqL1xcbmV4cG9ydHMuc3RhY2tUcmFjZUZpbHRlciA9IGZ1bmN0aW9uKCkge1xcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIGBwcm9jZXNzLmJyb3dzZXJgXFxuICB2YXIgc2xhc2ggPSAnLyc7XFxuICB2YXIgaXMgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8geyBub2RlOiB0cnVlIH0gOiB7IGJyb3dzZXI6IHRydWUgfTtcXG4gIHZhciBjd2QgPSBpcy5ub2RlXFxuICAgICAgPyBwcm9jZXNzLmN3ZCgpICsgc2xhc2hcXG4gICAgICA6ICh0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uIDogbG9jYXRpb24pLmhyZWYucmVwbGFjZSgvXFxcXC9bXlxcXFwvXSokLywgJy8nKTtcXG5cXG4gIGZ1bmN0aW9uIGlzTW9jaGFJbnRlcm5hbChsaW5lKSB7XFxuICAgIHJldHVybiAofmxpbmUuaW5kZXhPZignbm9kZV9tb2R1bGVzJyArIHNsYXNoICsgJ21vY2hhJyArIHNsYXNoKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZignY29tcG9uZW50cycgKyBzbGFzaCArICdtb2NoYWpzJyArIHNsYXNoKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZignY29tcG9uZW50cycgKyBzbGFzaCArICdtb2NoYScgKyBzbGFzaCkpXFxuICAgICAgfHwgKH5saW5lLmluZGV4T2Yoc2xhc2ggKyAnbW9jaGEuanMnKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc05vZGVJbnRlcm5hbChsaW5lKSB7XFxuICAgIHJldHVybiAofmxpbmUuaW5kZXhPZignKHRpbWVycy5qczonKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZignKGV2ZW50cy5qczonKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZignKG5vZGUuanM6JykpXFxuICAgICAgfHwgKH5saW5lLmluZGV4T2YoJyhtb2R1bGUuanM6JykpXFxuICAgICAgfHwgKH5saW5lLmluZGV4T2YoJ0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLm5leHQgKG5hdGl2ZSknKSlcXG4gICAgICB8fCBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbihzdGFjaykge1xcbiAgICBzdGFjayA9IHN0YWNrLnNwbGl0KCdcXFxcbicpO1xcblxcbiAgICBzdGFjayA9IGV4cG9ydHMucmVkdWNlKHN0YWNrLCBmdW5jdGlvbihsaXN0LCBsaW5lKSB7XFxuICAgICAgaWYgKGlzTW9jaGFJbnRlcm5hbChsaW5lKSkge1xcbiAgICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpcy5ub2RlICYmIGlzTm9kZUludGVybmFsKGxpbmUpKSB7XFxuICAgICAgICByZXR1cm4gbGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gQ2xlYW4gdXAgY3dkKGFic29sdXRlKVxcbiAgICAgIGlmICgvXFxcXCg/Lis6XFxcXGQrOlxcXFxkK1xcXFwpPyQvLnRlc3QobGluZSkpIHtcXG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoY3dkLCAnJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGxpc3QucHVzaChsaW5lKTtcXG4gICAgICByZXR1cm4gbGlzdDtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gc3RhY2suam9pbignXFxcXG4nKTtcXG4gIH07XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxyZXF1aXJlKFxcXCJidWZmZXJcXFwiKS5CdWZmZXIpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwiYnVmZmVyXFxcIjo0NSxcXFwiZGVidWdcXFwiOjIsXFxcImZzXFxcIjo0MyxcXFwiZ2xvYlxcXCI6NDMsXFxcInBhdGhcXFwiOjQzLFxcXCJ0by1pc28tc3RyaW5nXFxcIjo3MixcXFwidXRpbFxcXCI6NzV9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnXFxuXFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XFxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxcblxcbnZhciBsb29rdXAgPSBbXVxcbnZhciByZXZMb29rdXAgPSBbXVxcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcXG5cXG5mdW5jdGlvbiBpbml0ICgpIHtcXG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldXFxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxcbiAgfVxcblxcbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXFxuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcXG59XFxuXFxuaW5pdCgpXFxuXFxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXFxuXFxuICBpZiAobGVuICUgNCA+IDApIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcXG4gIH1cXG5cXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXFxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxcblxcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXFxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxcblxcbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXFxuXFxuICB2YXIgTCA9IDBcXG5cXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXFxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXFxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XFxuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXFxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXFxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gYXJyXFxufVxcblxcbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XFxuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cXG59XFxuXFxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XFxuICB2YXIgdG1wXFxuICB2YXIgb3V0cHV0ID0gW11cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XFxuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXFxuICB9XFxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXFxufVxcblxcbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XFxuICB2YXIgdG1wXFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcXG4gIHZhciBvdXRwdXQgPSAnJ1xcbiAgdmFyIHBhcnRzID0gW11cXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xcblxcbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxcbiAgfVxcblxcbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcXG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cXG4gICAgb3V0cHV0ICs9ICc9PSdcXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXFxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gJz0nXFxuICB9XFxuXFxuICBwYXJ0cy5wdXNoKG91dHB1dClcXG5cXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxcbn1cXG5cXG59LHt9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuXFxufSx7fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxudmFyIFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuV3JpdGFibGVcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEJyb3dzZXJTdGRvdXRcXG5cXG5cXG5pbmhlcml0cyhCcm93c2VyU3Rkb3V0LCBXcml0YWJsZVN0cmVhbSlcXG5cXG5mdW5jdGlvbiBCcm93c2VyU3Rkb3V0KG9wdHMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCcm93c2VyU3Rkb3V0KSkgcmV0dXJuIG5ldyBCcm93c2VyU3Rkb3V0KG9wdHMpXFxuXFxuICBvcHRzID0gb3B0cyB8fCB7fVxcbiAgV3JpdGFibGVTdHJlYW0uY2FsbCh0aGlzLCBvcHRzKVxcbiAgdGhpcy5sYWJlbCA9IChvcHRzLmxhYmVsICE9PSB1bmRlZmluZWQpID8gb3B0cy5sYWJlbCA6ICdzdGRvdXQnXFxufVxcblxcbkJyb3dzZXJTdGRvdXQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rcywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgb3V0cHV0ID0gY2h1bmtzLnRvU3RyaW5nID8gY2h1bmtzLnRvU3RyaW5nKCkgOiBjaHVua3NcXG4gIGlmICh0aGlzLmxhYmVsID09PSBmYWxzZSkge1xcbiAgICBjb25zb2xlLmxvZyhvdXRwdXQpXFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyh0aGlzLmxhYmVsKyc6Jywgb3V0cHV0KVxcbiAgfVxcbiAgcHJvY2Vzcy5uZXh0VGljayhjYilcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwic3RyZWFtXFxcIjo1OSxcXFwidXRpbFxcXCI6NzV9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuYXJndW1lbnRzWzRdWzQxXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcXG59LHtcXFwiZHVwXFxcIjo0MX1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcXG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcXG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcXG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XFxuICB9XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xcbiAgfVxcbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xcbiAgfVxcbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xcbiAgdmFyIF9maWxsID0gZmlsbDtcXG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuYyA9IHVuZGVmaW5lZDtcXG4gICAgX2ZpbGwgPSAwO1xcbiAgfVxcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XFxuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XFxuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XFxuICAgIHZhciBpID0gLTE7XFxuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XFxuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGJ1Zi5maWxsKF9maWxsKTtcXG4gIH1cXG4gIHJldHVybiBidWY7XFxufVxcbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XFxuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcXG4gIH1cXG4gIGlmIChzaXplID4gTUFYX0xFTikge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcXG4gIH1cXG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xcbn1cXG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XFxuICB9XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwidmFsdWVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XFxuICB9XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XFxuICB9XFxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XFxuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBvZmZzZXQgPSAwO1xcbiAgICB9XFxuICAgIHZhciBsZW4gPSBsZW5ndGg7XFxuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XFxuICAgIH1cXG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXFwnb2Zmc2V0XFxcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xcbiAgICB9XFxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXFwnbGVuZ3RoXFxcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XFxuICB9XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcXG4gICAgcmV0dXJuIG91dDtcXG4gIH1cXG4gIGlmICh2YWx1ZSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xcbiAgICB9XFxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XFxuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xcbn1cXG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XFxuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XFxuICB9XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xcbiAgfVxcbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcXG4gIH1cXG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcImJ1ZmZlclxcXCI6NDV9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbi8qIVxcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxuXFxuJ3VzZSBzdHJpY3QnXFxuXFxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXFxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxcblxcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXFxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxcblxcbi8qKlxcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XFxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXFxuICpcXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxcbiAqXFxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxcbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxcbiAqXFxuICogTm90ZTpcXG4gKlxcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxcbiAqXFxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXFxuICpcXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cXG5cXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxcbiAqL1xcbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXFxuXFxuLypcXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXFxuICovXFxuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXFxuXFxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xcbiAgdHJ5IHtcXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXFxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XFxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcXG4gIH0gY2F0Y2ggKGUpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXFxuICAgID8gMHg3ZmZmZmZmZlxcbiAgICA6IDB4M2ZmZmZmZmZcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcXG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcXG4gIH1cXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICB9IGVsc2Uge1xcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXFxuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XFxuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxcbiAgICB9XFxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXFxuICB9XFxuXFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG4vKipcXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXFxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cXG4gKlxcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cXG4gKi9cXG5cXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICAvLyBDb21tb24gY2FzZS5cXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xcbiAgICAgIClcXG4gICAgfVxcbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxcbiAgfVxcbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxcblxcbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxcbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcXG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICByZXR1cm4gYXJyXFxufVxcblxcbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcXG4gIH1cXG5cXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxcbn1cXG5cXG4vKipcXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxcbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXFxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXFxuICoqL1xcbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xcbiAgICAgIHZhbHVlOiBudWxsLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICBhc3NlcnRTaXplKHNpemUpXFxuICBpZiAoc2l6ZSA8PSAwKSB7XFxuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcXG4gIH1cXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXFxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXFxuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXFxuICB9XFxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXFxuICoqL1xcbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxcbn1cXG5cXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xcbiAgYXNzZXJ0U2l6ZShzaXplKVxcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcXG4gICAgICB0aGF0W2ldID0gMFxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG4vKipcXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqICovXFxuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxcbn1cXG4vKipcXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKi9cXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcXG4gIH1cXG5cXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJlbmNvZGluZ1xcXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXFxuICB9XFxuXFxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxcblxcbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcXG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxcblxcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFxcJ29mZnNldFxcXFwnIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcXCdsZW5ndGhcXFxcJyBpcyBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxcbiAgfSBlbHNlIHtcXG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxcbiAgfVxcblxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxcbiAgICB0aGF0ID0gYXJyYXlcXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICB9IGVsc2Uge1xcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXFxuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxcbiAgfVxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcXG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxcblxcbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gdGhhdFxcbiAgICB9XFxuXFxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcXG4gICAgcmV0dXJuIHRoYXRcXG4gIH1cXG5cXG4gIGlmIChvYmopIHtcXG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXFxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcXG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxcbiAgICB9XFxuXFxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxcbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXFxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcXG4gIH1cXG4gIHJldHVybiBsZW5ndGggfCAwXFxufVxcblxcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXFxuICAgIGxlbmd0aCA9IDBcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcXG59XFxuXFxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcXG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXFxufVxcblxcbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcXG4gIH1cXG5cXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxcblxcbiAgdmFyIHggPSBhLmxlbmd0aFxcbiAgdmFyIHkgPSBiLmxlbmd0aFxcblxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcXG4gICAgICB4ID0gYVtpXVxcbiAgICAgIHkgPSBiW2ldXFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcXG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XFxuICAgIGNhc2UgJ2hleCc6XFxuICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICBjYXNlICd1dGYtOCc6XFxuICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgY2FzZSAncmF3JzpcXG4gICAgY2FzZSAndWNzMic6XFxuICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgY2FzZSAndXRmMTZsZSc6XFxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcXG4gIGlmICghaXNBcnJheShsaXN0KSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcXG4gIH1cXG5cXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXFxuICB9XFxuXFxuICB2YXIgaVxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGxlbmd0aCA9IDBcXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXFxuICB2YXIgcG9zID0gMFxcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgICB9XFxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxcbiAgfVxcbiAgcmV0dXJuIGJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcXG4gIH1cXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XFxuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxcbiAgfVxcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XFxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXFxuICB9XFxuXFxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcXG5cXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG4gIGZvciAoOzspIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgIC8vIERlcHJlY2F0ZWRcXG4gICAgICBjYXNlICdyYXcnOlxcbiAgICAgIGNhc2UgJ3Jhd3MnOlxcbiAgICAgICAgcmV0dXJuIGxlblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gbGVuICogMlxcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5cXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcblxcbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcXFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlxcXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cXG5cXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxcbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XFxuICAgIHN0YXJ0ID0gMFxcbiAgfVxcbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXFxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgfVxcblxcbiAgaWYgKGVuZCA8PSAwKSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cXG4gIGVuZCA+Pj49IDBcXG4gIHN0YXJ0ID4+Pj0gMFxcblxcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICB3aGlsZSAodHJ1ZSkge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXFxuXFxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xcbiAgdmFyIGkgPSBiW25dXFxuICBiW25dID0gYlttXVxcbiAgYlttXSA9IGlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XFxuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XFxuICB2YXIgc3RyID0gJydcXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXFxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcXG4gIH1cXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgfVxcblxcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgc3RhcnQgPSAwXFxuICB9XFxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcXG4gIH1cXG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzU3RhcnQgPSAwXFxuICB9XFxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxcbiAgfVxcblxcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxcbiAgfVxcblxcbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xcbiAgICByZXR1cm4gMFxcbiAgfVxcbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XFxuICAgIHJldHVybiAtMVxcbiAgfVxcbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xcbiAgICByZXR1cm4gMVxcbiAgfVxcblxcbiAgc3RhcnQgPj4+PSAwXFxuICBlbmQgPj4+PSAwXFxuICB0aGlzU3RhcnQgPj4+PSAwXFxuICB0aGlzRW5kID4+Pj0gMFxcblxcbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcXG5cXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXFxuXFxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xcbiAgICAgIHggPSB0aGlzQ29weVtpXVxcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICB2YXIgaW5kZXhTaXplID0gMVxcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXFxuXFxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xcbiAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgfVxcbiAgICAgIGluZGV4U2l6ZSA9IDJcXG4gICAgICBhcnJMZW5ndGggLz0gMlxcbiAgICAgIHZhbExlbmd0aCAvPSAyXFxuICAgICAgYnl0ZU9mZnNldCAvPSAyXFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XFxuICAgICAgcmV0dXJuIGJ1ZltpXVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBmb3VuZEluZGV4ID0gLTFcXG4gIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChyZWFkKGFyciwgYnl0ZU9mZnNldCArIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XFxuICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxcbiAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIChieXRlT2Zmc2V0ICsgZm91bmRJbmRleCkgKiBpbmRleFNpemVcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcXG4gICAgICBmb3VuZEluZGV4ID0gLTFcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIC0xXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XFxuICAgIGJ5dGVPZmZzZXQgPSAwXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XFxuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcXG4gIH1cXG4gIGJ5dGVPZmZzZXQgPj49IDBcXG5cXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXFxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXFxuXFxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXFxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXFxuXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcXG4gIH1cXG5cXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXFxuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIC0xXFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKVxcbiAgfVxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZylcXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcXG59XFxuXFxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcXG4gIGlmICghbGVuZ3RoKSB7XFxuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgfSBlbHNlIHtcXG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXFxuXFxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXFxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcXG4gIH1cXG4gIHJldHVybiBpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXFxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcXG4gICAgb2Zmc2V0ID0gMFxcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXFxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgIGVuY29kaW5nID0gb2Zmc2V0XFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXFxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxcbiAgICB9XFxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXFxuICB9IGVsc2Uge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xcbiAgICApXFxuICB9XFxuXFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xcblxcbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcbiAgZm9yICg7Oykge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdHlwZTogJ0J1ZmZlcicsXFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XFxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcbiAgdmFyIHJlcyA9IFtdXFxuXFxuICB2YXIgaSA9IHN0YXJ0XFxuICB3aGlsZSAoaSA8IGVuZCkge1xcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXFxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxcbiAgICAgIDogMVxcblxcbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XFxuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxcblxcbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xcbiAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXFxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcXG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXFxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XFxuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxcbiAgICB9XFxuXFxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXFxuICB9XFxuXFxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcXG59XFxuXFxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxcbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcXG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcXG5cXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcXG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcXG4gIH1cXG5cXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXFxcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFxcXCIuXFxuICB2YXIgcmVzID0gJydcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKGkgPCBsZW4pIHtcXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXFxuICAgICAgU3RyaW5nLFxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcXG4gICAgKVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByZXQgPSAnJ1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHJldCA9ICcnXFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXFxuICB9XFxuICByZXR1cm4gcmV0XFxufVxcblxcbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXFxuXFxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXFxuXFxuICB2YXIgb3V0ID0gJydcXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XFxuICAgIG91dCArPSB0b0hleChidWZbaV0pXFxuICB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcXG4gIHZhciByZXMgPSAnJ1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIHN0YXJ0ID0gfn5zdGFydFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxcblxcbiAgaWYgKHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCArPSBsZW5cXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XFxuICAgIHN0YXJ0ID0gbGVuXFxuICB9XFxuXFxuICBpZiAoZW5kIDwgMCkge1xcbiAgICBlbmQgKz0gbGVuXFxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xcbiAgICBlbmQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcXG5cXG4gIHZhciBuZXdCdWZcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXFxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbmV3QnVmXFxufVxcblxcbi8qXFxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXFxuICovXFxuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcXG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcbiAgfVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxcbiAgdmFyIG11bCA9IDFcXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxcbiAgICB0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXFxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJidWZmZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcInZhbHVlXFxcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxcbiAgfVxcblxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcXG4gIH1cXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcXG4gIHZhciBtdWwgPSAxXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDFcXG59XFxuXFxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxcbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXFxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XFxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcXG4gIH1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxcblxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcXG4gIH1cXG5cXG4gIHZhciBpID0gMFxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XFxuICAgICAgc3ViID0gMVxcbiAgICB9XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcXG4gIHJldHVybiBvZmZzZXQgKyA4XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXFxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXFxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcXG5cXG4gIC8vIEFyZSB3ZSBvb2I/XFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxcbiAgdmFyIGlcXG5cXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXFxuICAgICAgdGFyZ2V0LFxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcXG4gICAgICB0YXJnZXRTdGFydFxcbiAgICApXFxuICB9XFxuXFxuICByZXR1cm4gbGVuXFxufVxcblxcbi8vIFVzYWdlOlxcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcXG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XFxuICAgICAgc3RhcnQgPSAwXFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gZW5kXFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gICAgfVxcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xcbiAgICAgICAgdmFsID0gY29kZVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICB2YWwgPSB2YWwgJiAyNTVcXG4gIH1cXG5cXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxcbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxcbiAgfVxcblxcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxcblxcbiAgaWYgKCF2YWwpIHZhbCA9IDBcXG5cXG4gIHZhciBpXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xcbiAgICAgIHRoaXNbaV0gPSB2YWxcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcXG4gICAgICA/IHZhbFxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgaSsrKSB7XFxuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuLy8gSEVMUEVSIEZVTkNUSU9OU1xcbi8vID09PT09PT09PT09PT09PT1cXG5cXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFxcXC8wLTlBLVphLXotX10vZ1xcblxcbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXFxcbiBhbmQgXFxcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXFxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xcbiAgICBzdHIgPSBzdHIgKyAnPSdcXG4gIH1cXG4gIHJldHVybiBzdHJcXG59XFxuXFxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XFxuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXFxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJylcXG59XFxuXFxuZnVuY3Rpb24gdG9IZXggKG4pIHtcXG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XFxuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XFxuICB2YXIgY29kZVBvaW50XFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuICB2YXIgYnl0ZXMgPSBbXVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxcblxcbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XFxuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XFxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcXG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgICAgY29udGludWVcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG5cXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcXG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XFxuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXFxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgIH1cXG5cXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcXG5cXG4gICAgLy8gZW5jb2RlIHV0ZjhcXG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBieXRlc1xcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxcbiAgfVxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xcbiAgdmFyIGMsIGhpLCBsb1xcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG5cXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXFxuICAgIGhpID0gYyA+PiA4XFxuICAgIGxvID0gYyAlIDI1NlxcbiAgICBieXRlQXJyYXkucHVzaChsbylcXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZUFycmF5XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxcbn1cXG5cXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cXG4gIH1cXG4gIHJldHVybiBpXFxufVxcblxcbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcXG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxcbn1cXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiYmFzZTY0LWpzXFxcIjo0MCxcXFwiaWVlZTc1NFxcXCI6NTIsXFxcImlzYXJyYXlcXFwiOjQ2fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG59LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChCdWZmZXIpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcblxcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheSkge1xcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xcbiAgfVxcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMse1xcXCJpc0J1ZmZlclxcXCI6cmVxdWlyZShcXFwiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXFxcIil9KVxcbn0se1xcXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcXFwiOjU0fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIFNlZSBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zIG9mIHVzZSAqL1xcblxcbi8qXFxuICogVGV4dCBkaWZmIGltcGxlbWVudGF0aW9uLlxcbiAqXFxuICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcXG4gKiBKc0RpZmYuZGlmZkNoYXJzOiBDaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIGRpZmZcXG4gKiBKc0RpZmYuZGlmZldvcmRzOiBXb3JkIChhcyBkZWZpbmVkIGJ5IFxcXFxiIHJlZ2V4KSBkaWZmIHdoaWNoIGlnbm9yZXMgd2hpdGVzcGFjZVxcbiAqIEpzRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxcbiAqXFxuICogSnNEaWZmLmRpZmZDc3M6IERpZmYgdGFyZ2V0ZWQgYXQgQ1NTIGNvbnRlbnRcXG4gKlxcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxcbiAqIFxcXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcXFwiIChNeWVycywgMTk4NikuXFxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcXG4gKi9cXG4oZnVuY3Rpb24oZ2xvYmFsLCB1bmRlZmluZWQpIHtcXG4gIHZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuICAvKmlzdGFuYnVsIGlnbm9yZSBuZXh0Ki9cXG4gIGZ1bmN0aW9uIG1hcChhcnIsIG1hcHBlciwgdGhhdCkge1xcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCkge1xcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyLCBtYXBwZXIsIHRoYXQpO1xcbiAgICB9XFxuXFxuICAgIHZhciBvdGhlciA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcnIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxuICAgICAgb3RoZXJbaV0gPSBtYXBwZXIuY2FsbCh0aGF0LCBhcnJbaV0sIGksIGFycik7XFxuICAgIH1cXG4gICAgcmV0dXJuIG90aGVyO1xcbiAgfVxcbiAgZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcXG4gICAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XFxuICB9XFxuICBmdW5jdGlvbiByZW1vdmVFbXB0eShhcnJheSkge1xcbiAgICB2YXIgcmV0ID0gW107XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAoYXJyYXlbaV0pIHtcXG4gICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xcbiAgICB2YXIgbiA9IHM7XFxuICAgIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XFxuICAgIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcXG4gICAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xcbiAgICBuID0gbi5yZXBsYWNlKC9cXFwiL2csICcmcXVvdDsnKTtcXG5cXG4gICAgcmV0dXJuIG47XFxuICB9XFxuXFxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cXG4gIC8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFxcXCJzdGFja1xcXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLlxcbiAgZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spIHtcXG4gICAgc3RhY2sgPSBzdGFjayB8fCBbXTtcXG4gICAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XFxuXFxuICAgIHZhciBpO1xcblxcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBjYW5vbmljYWxpemVkT2JqO1xcblxcbiAgICBpZiAoJ1tvYmplY3QgQXJyYXldJyA9PT0gb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcuY2FsbChvYmopKSB7XFxuICAgICAgc3RhY2sucHVzaChvYmopO1xcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XFxuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbaV0gPSBjYW5vbmljYWxpemUob2JqW2ldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjayk7XFxuICAgICAgfVxcbiAgICAgIHN0YWNrLnBvcCgpO1xcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XFxuICAgICAgc3RhY2sucHVzaChvYmopO1xcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcXG4gICAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuICAgICAgdmFyIHNvcnRlZEtleXMgPSBbXSxcXG4gICAgICAgICAga2V5O1xcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xcbiAgICAgICAgc29ydGVkS2V5cy5wdXNoKGtleSk7XFxuICAgICAgfVxcbiAgICAgIHNvcnRlZEtleXMuc29ydCgpO1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3J0ZWRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICBrZXkgPSBzb3J0ZWRLZXlzW2ldO1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9ialtrZXldID0gY2Fub25pY2FsaXplKG9ialtrZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjayk7XFxuICAgICAgfVxcbiAgICAgIHN0YWNrLnBvcCgpO1xcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IG9iajtcXG4gICAgfVxcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcXG4gICAgdmFyIGNvbXBvbmVudFBvcyA9IDAsXFxuICAgICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcXG4gICAgICAgIG5ld1BvcyA9IDAsXFxuICAgICAgICBvbGRQb3MgPSAwO1xcblxcbiAgICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XFxuICAgICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xcbiAgICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XFxuICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XFxuICAgICAgICAgIHZhbHVlID0gbWFwKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwgaSkge1xcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFN0cmluZ1tvbGRQb3MgKyBpXTtcXG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IHZhbHVlLmpvaW4oJycpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KS5qb2luKCcnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFxuICAgICAgICAvLyBDb21tb24gY2FzZVxcbiAgICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcXG4gICAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gb2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KS5qb2luKCcnKTtcXG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFxuICAgICAgICAvLyBSZXZlcnNlIGFkZCBhbmQgcmVtb3ZlIHNvIHJlbW92ZXMgYXJlIG91dHB1dCBmaXJzdCB0byBtYXRjaCBjb21tb24gY29udmVudGlvblxcbiAgICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcXG4gICAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxcbiAgICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XFxuICAgICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xcbiAgICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xcbiAgICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBjb21wb25lbnRzO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gRGlmZihpZ25vcmVXaGl0ZXNwYWNlKSB7XFxuICAgIHRoaXMuaWdub3JlV2hpdGVzcGFjZSA9IGlnbm9yZVdoaXRlc3BhY2U7XFxuICB9XFxuICBEaWZmLnByb3RvdHlwZSA9IHtcXG4gICAgZGlmZjogZnVuY3Rpb24ob2xkU3RyaW5nLCBuZXdTdHJpbmcsIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTsgfSwgMCk7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBIYW5kbGUgdGhlIGlkZW50aXR5IGNhc2UgKHRoaXMgaXMgZHVlIHRvIHVucm9sbGluZyBlZGl0TGVuZ3RoID09IDBcXG4gICAgICBpZiAobmV3U3RyaW5nID09PSBvbGRTdHJpbmcpIHtcXG4gICAgICAgIHJldHVybiBkb25lKFt7IHZhbHVlOiBuZXdTdHJpbmcgfV0pO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIW5ld1N0cmluZykge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoW3sgdmFsdWU6IG9sZFN0cmluZywgcmVtb3ZlZDogdHJ1ZSB9XSk7XFxuICAgICAgfVxcbiAgICAgIGlmICghb2xkU3RyaW5nKSB7XFxuICAgICAgICByZXR1cm4gZG9uZShbeyB2YWx1ZTogbmV3U3RyaW5nLCBhZGRlZDogdHJ1ZSB9XSk7XFxuICAgICAgfVxcblxcbiAgICAgIG5ld1N0cmluZyA9IHRoaXMudG9rZW5pemUobmV3U3RyaW5nKTtcXG4gICAgICBvbGRTdHJpbmcgPSB0aGlzLnRva2VuaXplKG9sZFN0cmluZyk7XFxuXFxuICAgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XFxuICAgICAgdmFyIGVkaXRMZW5ndGggPSAxO1xcbiAgICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xcbiAgICAgIHZhciBiZXN0UGF0aCA9IFt7IG5ld1BvczogLTEsIGNvbXBvbmVudHM6IFtdIH1dO1xcblxcbiAgICAgIC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXFxuICAgICAgdmFyIG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xcbiAgICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xcbiAgICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXFxuICAgICAgICByZXR1cm4gZG9uZShbe3ZhbHVlOiBuZXdTdHJpbmcuam9pbignJyl9XSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cXG4gICAgICBmdW5jdGlvbiBleGVjRWRpdExlbmd0aCgpIHtcXG4gICAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IC0xICogZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoIDw9IGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCArPSAyKSB7XFxuICAgICAgICAgIHZhciBiYXNlUGF0aDtcXG4gICAgICAgICAgdmFyIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcXG4gICAgICAgICAgICAgIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXSxcXG4gICAgICAgICAgICAgIG9sZFBvcyA9IChyZW1vdmVQYXRoID8gcmVtb3ZlUGF0aC5uZXdQb3MgOiAwKSAtIGRpYWdvbmFsUGF0aDtcXG4gICAgICAgICAgaWYgKGFkZFBhdGgpIHtcXG4gICAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxcbiAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcXG4gICAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBvbGRQb3MgJiYgb2xkUG9zIDwgb2xkTGVuO1xcbiAgICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XFxuICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxcbiAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcXG4gICAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXFxuICAgICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcXG4gICAgICAgICAgaWYgKCFjYW5BZGQgfHwgKGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSkge1xcbiAgICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xcbiAgICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgICAvLyBObyBuZWVkIHRvIGNsb25lLCB3ZSd2ZSBwdWxsZWQgaXQgZnJvbSB0aGUgbGlzdFxcbiAgICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xcbiAgICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XFxuXFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXFxuICAgICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xcbiAgICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cXG4gICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGVkaXRMZW5ndGgrKztcXG4gICAgICB9XFxuXFxuICAgICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcXG4gICAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXFxuICAgICAgLy8gaXMgcHJvZHVjZWQuXFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAoZnVuY3Rpb24gZXhlYygpIHtcXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxcbiAgICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gICAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGgpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcXG4gICAgICAgICAgICAgIGV4ZWMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sIDApO1xcbiAgICAgICAgfSgpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xcbiAgICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcXG4gICAgICAgICAgaWYgKHJldCkge1xcbiAgICAgICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHB1c2hDb21wb25lbnQ6IGZ1bmN0aW9uKGNvbXBvbmVudHMsIGFkZGVkLCByZW1vdmVkKSB7XFxuICAgICAgdmFyIGxhc3QgPSBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV07XFxuICAgICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XFxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGhlcmUgYXMgdGhlIGNvbXBvbmVudCBjbG9uZSBvcGVyYXRpb24gaXMganVzdFxcbiAgICAgICAgLy8gYXMgc2hhbGxvdyBhcnJheSBjbG9uZVxcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID0ge2NvdW50OiBsYXN0LmNvdW50ICsgMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7Y291bnQ6IDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGV4dHJhY3RDb21tb246IGZ1bmN0aW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XFxuICAgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXFxuICAgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXFxuICAgICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcXG4gICAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxcblxcbiAgICAgICAgICBjb21tb25Db3VudCA9IDA7XFxuICAgICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcXG4gICAgICAgIG5ld1BvcysrO1xcbiAgICAgICAgb2xkUG9zKys7XFxuICAgICAgICBjb21tb25Db3VudCsrO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY29tbW9uQ291bnQpIHtcXG4gICAgICAgIGJhc2VQYXRoLmNvbXBvbmVudHMucHVzaCh7Y291bnQ6IGNvbW1vbkNvdW50fSk7XFxuICAgICAgfVxcblxcbiAgICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcXG4gICAgICByZXR1cm4gb2xkUG9zO1xcbiAgICB9LFxcblxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XFxuICAgICAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXFxcUy87XFxuICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8ICh0aGlzLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCkpO1xcbiAgICB9LFxcbiAgICB0b2tlbml6ZTogZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgdmFyIENoYXJEaWZmID0gbmV3IERpZmYoKTtcXG5cXG4gIHZhciBXb3JkRGlmZiA9IG5ldyBEaWZmKHRydWUpO1xcbiAgdmFyIFdvcmRXaXRoU3BhY2VEaWZmID0gbmV3IERpZmYoKTtcXG4gIFdvcmREaWZmLnRva2VuaXplID0gV29yZFdpdGhTcGFjZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICByZXR1cm4gcmVtb3ZlRW1wdHkodmFsdWUuc3BsaXQoLyhcXFxccyt8XFxcXGIpLykpO1xcbiAgfTtcXG5cXG4gIHZhciBDc3NEaWZmID0gbmV3IERpZmYodHJ1ZSk7XFxuICBDc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIHJlbW92ZUVtcHR5KHZhbHVlLnNwbGl0KC8oW3t9OjssXXxcXFxccyspLykpO1xcbiAgfTtcXG5cXG4gIHZhciBMaW5lRGlmZiA9IG5ldyBEaWZmKCk7XFxuXFxuICB2YXIgVHJpbW1lZExpbmVEaWZmID0gbmV3IERpZmYoKTtcXG4gIFRyaW1tZWRMaW5lRGlmZi5pZ25vcmVUcmltID0gdHJ1ZTtcXG5cXG4gIExpbmVEaWZmLnRva2VuaXplID0gVHJpbW1lZExpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdmFyIHJldExpbmVzID0gW10sXFxuICAgICAgICBsaW5lcyA9IHZhbHVlLnNwbGl0KC9eL20pO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXSxcXG4gICAgICAgICAgbGFzdExpbmUgPSBsaW5lc1tpIC0gMV0sXFxuICAgICAgICAgIGxhc3RMaW5lTGFzdENoYXIgPSBsYXN0TGluZSAmJiBsYXN0TGluZVtsYXN0TGluZS5sZW5ndGggLSAxXTtcXG5cXG4gICAgICAvLyBNZXJnZSBsaW5lcyB0aGF0IG1heSBjb250YWluIHdpbmRvd3MgbmV3IGxpbmVzXFxuICAgICAgaWYgKGxpbmUgPT09ICdcXFxcbicgJiYgbGFzdExpbmVMYXN0Q2hhciA9PT0gJ1xcXFxyJykge1xcbiAgICAgICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSA9IHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIC0xKSArICdcXFxcclxcXFxuJztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlVHJpbSkge1xcbiAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XFxuICAgICAgICAgIC8vIGFkZCBhIG5ld2xpbmUgdW5sZXNzIHRoaXMgaXMgdGhlIGxhc3QgbGluZS5cXG4gICAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGggLSAxKSB7XFxuICAgICAgICAgICAgbGluZSArPSAnXFxcXG4nO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmV0TGluZXM7XFxuICB9O1xcblxcbiAgdmFyIFBhdGNoRGlmZiA9IG5ldyBEaWZmKCk7XFxuICBQYXRjaERpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB2YXIgcmV0ID0gW10sXFxuICAgICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXFxcbnxcXFxcclxcXFxuKS8pO1xcblxcbiAgICAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcXG4gICAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcXG4gICAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xcbiAgICB9XFxuXFxuICAgIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcXG5cXG4gICAgICBpZiAoaSAlIDIpIHtcXG4gICAgICAgIHJldFtyZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0LnB1c2gobGluZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9O1xcblxcbiAgdmFyIFNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XFxuICBTZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICByZXR1cm4gcmVtb3ZlRW1wdHkodmFsdWUuc3BsaXQoLyhcXFxcUy4rP1suIT9dKSg/PVxcXFxzK3wkKS8pKTtcXG4gIH07XFxuXFxuICB2YXIgSnNvbkRpZmYgPSBuZXcgRGlmZigpO1xcbiAgLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcXG4gIC8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxcbiAgSnNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcXG4gIEpzb25EaWZmLnRva2VuaXplID0gTGluZURpZmYudG9rZW5pemU7XFxuICBKc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xcbiAgICByZXR1cm4gTGluZURpZmYuZXF1YWxzKGxlZnQucmVwbGFjZSgvLChbXFxcXHJcXFxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXFxcclxcXFxuXSkvZywgJyQxJykpO1xcbiAgfTtcXG5cXG4gIHZhciBKc0RpZmYgPSB7XFxuICAgIERpZmY6IERpZmYsXFxuXFxuICAgIGRpZmZDaGFyczogZnVuY3Rpb24ob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBDaGFyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH0sXFxuICAgIGRpZmZXb3JkczogZnVuY3Rpb24ob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBXb3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH0sXFxuICAgIGRpZmZXb3Jkc1dpdGhTcGFjZTogZnVuY3Rpb24ob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBXb3JkV2l0aFNwYWNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH0sXFxuICAgIGRpZmZMaW5lczogZnVuY3Rpb24ob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBMaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH0sXFxuICAgIGRpZmZUcmltbWVkTGluZXM6IGZ1bmN0aW9uKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gVHJpbW1lZExpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTsgfSxcXG5cXG4gICAgZGlmZlNlbnRlbmNlczogZnVuY3Rpb24ob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBTZW50ZW5jZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9LFxcblxcbiAgICBkaWZmQ3NzOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIENzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9LFxcbiAgICBkaWZmSnNvbjogZnVuY3Rpb24ob2xkT2JqLCBuZXdPYmosIGNhbGxiYWNrKSB7XFxuICAgICAgcmV0dXJuIEpzb25EaWZmLmRpZmYoXFxuICAgICAgICB0eXBlb2Ygb2xkT2JqID09PSAnc3RyaW5nJyA/IG9sZE9iaiA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZShvbGRPYmopLCB1bmRlZmluZWQsICcgICcpLFxcbiAgICAgICAgdHlwZW9mIG5ld09iaiA9PT0gJ3N0cmluZycgPyBuZXdPYmogOiBKU09OLnN0cmluZ2lmeShjYW5vbmljYWxpemUobmV3T2JqKSwgdW5kZWZpbmVkLCAnICAnKSxcXG4gICAgICAgIGNhbGxiYWNrXFxuICAgICAgKTtcXG4gICAgfSxcXG5cXG4gICAgY3JlYXRlVHdvRmlsZXNQYXRjaDogZnVuY3Rpb24ob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIpIHtcXG4gICAgICB2YXIgcmV0ID0gW107XFxuXFxuICAgICAgaWYgKG9sZEZpbGVOYW1lID09IG5ld0ZpbGVOYW1lKSB7XFxuICAgICAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBvbGRGaWxlTmFtZSk7XFxuICAgICAgfVxcbiAgICAgIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XFxuICAgICAgcmV0LnB1c2goJy0tLSAnICsgb2xkRmlsZU5hbWUgKyAodHlwZW9mIG9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXFxcdCcgKyBvbGRIZWFkZXIpKTtcXG4gICAgICByZXQucHVzaCgnKysrICcgKyBuZXdGaWxlTmFtZSArICh0eXBlb2YgbmV3SGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcXFx0JyArIG5ld0hlYWRlcikpO1xcblxcbiAgICAgIHZhciBkaWZmID0gUGF0Y2hEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIpO1xcbiAgICAgIGRpZmYucHVzaCh7dmFsdWU6ICcnLCBsaW5lczogW119KTsgICAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxcblxcbiAgICAgIC8vIEZvcm1hdHMgYSBnaXZlbiBzZXQgb2YgbGluZXMgZm9yIHByaW50aW5nIGFzIGNvbnRleHQgbGluZXMgaW4gYSBwYXRjaFxcbiAgICAgIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xcbiAgICAgICAgcmV0dXJuIG1hcChsaW5lcywgZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuICcgJyArIGVudHJ5OyB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gT3V0cHV0cyB0aGUgbm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZSB3YXJuaW5nIGlmIG5lZWRlZFxcbiAgICAgIGZ1bmN0aW9uIGVvZk5MKGN1clJhbmdlLCBpLCBjdXJyZW50KSB7XFxuICAgICAgICB2YXIgbGFzdCA9IGRpZmZbZGlmZi5sZW5ndGggLSAyXSxcXG4gICAgICAgICAgICBpc0xhc3QgPSBpID09PSBkaWZmLmxlbmd0aCAtIDIsXFxuICAgICAgICAgICAgaXNMYXN0T2ZUeXBlID0gaSA9PT0gZGlmZi5sZW5ndGggLSAzICYmIGN1cnJlbnQuYWRkZWQgIT09IGxhc3QuYWRkZWQ7XFxuXFxuICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHRoaXMgaXMgdGhlIGxhc3QgbGluZSBmb3IgdGhlIGdpdmVuIGZpbGUgYW5kIG1pc3NpbmcgTkxcXG4gICAgICAgIGlmICghKC9cXFxcbiQvLnRlc3QoY3VycmVudC52YWx1ZSkpICYmIChpc0xhc3QgfHwgaXNMYXN0T2ZUeXBlKSkge1xcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBvbGRSYW5nZVN0YXJ0ID0gMCwgbmV3UmFuZ2VTdGFydCA9IDAsIGN1clJhbmdlID0gW10sXFxuICAgICAgICAgIG9sZExpbmUgPSAxLCBuZXdMaW5lID0gMTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjdXJyZW50ID0gZGlmZltpXSxcXG4gICAgICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXFxcbiQvLCAnJykuc3BsaXQoJ1xcXFxuJyk7XFxuICAgICAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XFxuXFxuICAgICAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcXG4gICAgICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XFxuICAgICAgICAgICAgdmFyIHByZXYgPSBkaWZmW2kgLSAxXTtcXG4gICAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcXG4gICAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcXG5cXG4gICAgICAgICAgICBpZiAocHJldikge1xcbiAgICAgICAgICAgICAgY3VyUmFuZ2UgPSBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtNCkpO1xcbiAgICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XFxuICAgICAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gT3V0cHV0IG91ciBjaGFuZ2VzXFxuICAgICAgICAgIGN1clJhbmdlLnB1c2guYXBwbHkoY3VyUmFuZ2UsIG1hcChsaW5lcywgZnVuY3Rpb24oZW50cnkpIHtcXG4gICAgICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XFxuICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgZW9mTkwoY3VyUmFuZ2UsIGksIGN1cnJlbnQpO1xcblxcbiAgICAgICAgICAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXFxuICAgICAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XFxuICAgICAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcXG4gICAgICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcXG4gICAgICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gOCAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XFxuICAgICAgICAgICAgICAvLyBPdmVybGFwcGluZ1xcbiAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaC5hcHBseShjdXJSYW5nZSwgY29udGV4dExpbmVzKGxpbmVzKSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCA0KTtcXG4gICAgICAgICAgICAgIHJldC5wdXNoKFxcbiAgICAgICAgICAgICAgICAgICdAQCAtJyArIG9sZFJhbmdlU3RhcnQgKyAnLCcgKyAob2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSlcXG4gICAgICAgICAgICAgICAgICArICcgKycgKyBuZXdSYW5nZVN0YXJ0ICsgJywnICsgKG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUpXFxuICAgICAgICAgICAgICAgICAgKyAnIEBAJyk7XFxuICAgICAgICAgICAgICByZXQucHVzaC5hcHBseShyZXQsIGN1clJhbmdlKTtcXG4gICAgICAgICAgICAgIHJldC5wdXNoLmFwcGx5KHJldCwgY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpO1xcbiAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSA0KSB7XFxuICAgICAgICAgICAgICAgIGVvZk5MKHJldCwgaSwgY3VycmVudCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gMDtcXG4gICAgICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xcbiAgICAgICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJ1xcXFxuJykgKyAnXFxcXG4nO1xcbiAgICB9LFxcblxcbiAgICBjcmVhdGVQYXRjaDogZnVuY3Rpb24oZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlcikge1xcbiAgICAgIHJldHVybiBKc0RpZmYuY3JlYXRlVHdvRmlsZXNQYXRjaChmaWxlTmFtZSwgZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlcik7XFxuICAgIH0sXFxuXFxuICAgIGFwcGx5UGF0Y2g6IGZ1bmN0aW9uKG9sZFN0ciwgdW5pRGlmZikge1xcbiAgICAgIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgnXFxcXG4nKSxcXG4gICAgICAgICAgaHVua3MgPSBbXSxcXG4gICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgIHJlbUVPRk5MID0gZmFsc2UsXFxuICAgICAgICAgIGFkZEVPRk5MID0gZmFsc2U7XFxuXFxuICAgICAgLy8gU2tpcCB0byB0aGUgZmlyc3QgY2hhbmdlIGh1bmtcXG4gICAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoICYmICEoL15AQC8udGVzdChkaWZmc3RyW2ldKSkpIHtcXG4gICAgICAgIGkrKztcXG4gICAgICB9XFxuXFxuICAgICAgLy8gUGFyc2UgdGhlIHVuaWZpZWQgZGlmZlxcbiAgICAgIGZvciAoOyBpIDwgZGlmZnN0ci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGRpZmZzdHJbaV1bMF0gPT09ICdAJykge1xcbiAgICAgICAgICB2YXIgY2hudWtIZWFkZXIgPSBkaWZmc3RyW2ldLnNwbGl0KC9AQCAtKFxcXFxkKyksKFxcXFxkKykgXFxcXCsoXFxcXGQrKSwoXFxcXGQrKSBAQC8pO1xcbiAgICAgICAgICBodW5rcy51bnNoaWZ0KHtcXG4gICAgICAgICAgICBzdGFydDogY2hudWtIZWFkZXJbM10sXFxuICAgICAgICAgICAgb2xkbGVuZ3RoOiArY2hudWtIZWFkZXJbMl0sXFxuICAgICAgICAgICAgcmVtb3ZlZDogW10sXFxuICAgICAgICAgICAgbmV3bGVuZ3RoOiBjaG51a0hlYWRlcls0XSxcXG4gICAgICAgICAgICBhZGRlZDogW11cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZzdHJbaV1bMF0gPT09ICcrJykge1xcbiAgICAgICAgICBodW5rc1swXS5hZGRlZC5wdXNoKGRpZmZzdHJbaV0uc3Vic3RyKDEpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZnN0cltpXVswXSA9PT0gJy0nKSB7XFxuICAgICAgICAgIGh1bmtzWzBdLnJlbW92ZWQucHVzaChkaWZmc3RyW2ldLnN1YnN0cigxKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZzdHJbaV1bMF0gPT09ICcgJykge1xcbiAgICAgICAgICBodW5rc1swXS5hZGRlZC5wdXNoKGRpZmZzdHJbaV0uc3Vic3RyKDEpKTtcXG4gICAgICAgICAgaHVua3NbMF0ucmVtb3ZlZC5wdXNoKGRpZmZzdHJbaV0uc3Vic3RyKDEpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZnN0cltpXVswXSA9PT0gJ1xcXFxcXFxcJykge1xcbiAgICAgICAgICBpZiAoZGlmZnN0cltpIC0gMV1bMF0gPT09ICcrJykge1xcbiAgICAgICAgICAgIHJlbUVPRk5MID0gdHJ1ZTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmc3RyW2kgLSAxXVswXSA9PT0gJy0nKSB7XFxuICAgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBpbnB1dFxcbiAgICAgIHZhciBsaW5lcyA9IG9sZFN0ci5zcGxpdCgnXFxcXG4nKTtcXG4gICAgICBmb3IgKGkgPSBodW5rcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgdmFyIGh1bmsgPSBodW5rc1tpXTtcXG4gICAgICAgIC8vIFNhbml0eSBjaGVjayB0aGUgaW5wdXQgc3RyaW5nLiBCYWlsIGlmIHdlIGRvbid0IG1hdGNoLlxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBodW5rLm9sZGxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIGlmIChsaW5lc1todW5rLnN0YXJ0IC0gMSArIGpdICE9PSBodW5rLnJlbW92ZWRbal0pIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkobGluZXMsIFtodW5rLnN0YXJ0IC0gMSwgaHVuay5vbGRsZW5ndGhdLmNvbmNhdChodW5rLmFkZGVkKSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxcbiAgICAgIGlmIChyZW1FT0ZOTCkge1xcbiAgICAgICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xcbiAgICAgICAgICBsaW5lcy5wb3AoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XFxuICAgICAgICBsaW5lcy5wdXNoKCcnKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcXFxuJyk7XFxuICAgIH0sXFxuXFxuICAgIGNvbnZlcnRDaGFuZ2VzVG9YTUw6IGZ1bmN0aW9uKGNoYW5nZXMpIHtcXG4gICAgICB2YXIgcmV0ID0gW107XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcXG4gICAgICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG4gICAgICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XFxuICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuICAgICAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcXG5cXG4gICAgICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG4gICAgICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xcbiAgICAgICAgICByZXQucHVzaCgnPC9kZWw+Jyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXQuam9pbignJyk7XFxuICAgIH0sXFxuXFxuICAgIC8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXFxuICAgIGNvbnZlcnRDaGFuZ2VzVG9ETVA6IGZ1bmN0aW9uKGNoYW5nZXMpIHtcXG4gICAgICB2YXIgcmV0ID0gW10sXFxuICAgICAgICAgIGNoYW5nZSxcXG4gICAgICAgICAgb3BlcmF0aW9uO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcXG4gICAgICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG4gICAgICAgICAgb3BlcmF0aW9uID0gMTtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG4gICAgICAgICAgb3BlcmF0aW9uID0gLTE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvcGVyYXRpb24gPSAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0LnB1c2goW29wZXJhdGlvbiwgY2hhbmdlLnZhbHVlXSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH0sXFxuXFxuICAgIGNhbm9uaWNhbGl6ZTogY2Fub25pY2FsaXplXFxuICB9O1xcblxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgLypnbG9iYWwgbW9kdWxlICovXFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKc0RpZmY7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAvKmdsb2JhbCBkZWZpbmUgKi9cXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIEpzRGlmZjsgfSk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwuSnNEaWZmID09PSAndW5kZWZpbmVkJykge1xcbiAgICBnbG9iYWwuSnNEaWZmID0gSnNEaWZmO1xcbiAgfVxcbn0odGhpcykpO1xcblxcbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxcXFxcXHt9KClbXFxcXF1eJCsqPy5dL2c7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XFxuXFx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICAnXFxcXFxcXFwkJicpO1xcbn07XFxuXFxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcXG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcXG5cXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxcbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XFxuXFxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXFxuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG5cXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XFxuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XFxuICAgICAgfVxcbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFxcXCJlcnJvclxcXCIgZXZlbnQuJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXFxuICAgIHJldHVybiBmYWxzZTtcXG5cXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XFxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICAgIC8vIGZhc3QgY2FzZXNcXG4gICAgICBjYXNlIDE6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDI6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMzpcXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICAvLyBzbG93ZXJcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XFxuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XFxuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIG07XFxuXFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMpXFxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcblxcbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXFxcIm5ld0xpc3RlbmVyXFxcIiEgQmVmb3JlXFxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcXFwibmV3TGlzdGVuZXJcXFwiLlxcbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XFxuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XFxuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcXG4gIGVsc2VcXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcXG5cXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXFxuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcXG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcXG4gICAgfVxcblxcbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXFxuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xcblxcbiAgZnVuY3Rpb24gZygpIHtcXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcXG5cXG4gICAgaWYgKCFmaXJlZCkge1xcbiAgICAgIGZpcmVkID0gdHJ1ZTtcXG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuICB9XFxuXFxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XFxuICB0aGlzLm9uKHR5cGUsIGcpO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XFxuXFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XFxuICBwb3NpdGlvbiA9IC0xO1xcblxcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XFxuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXFxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcXG5cXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcXG4gICAgICAgIHBvc2l0aW9uID0gaTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocG9zaXRpb24gPCAwKVxcbiAgICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcXG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XFxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciBrZXksIGxpc3RlbmVycztcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICByZXR1cm4gdGhpcztcXG5cXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcXG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XFxuICAgIH1cXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XFxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcXG4gICAgLy8gTElGTyBvcmRlclxcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xcbiAgfVxcbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XFxuICB2YXIgcmV0O1xcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgcmV0ID0gW107XFxuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXFxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xcbiAgZWxzZVxcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XFxuICBpZiAodGhpcy5fZXZlbnRzKSB7XFxuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcXG4gICAgICByZXR1cm4gMTtcXG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XFxuICB9XFxuICByZXR1cm4gMDtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcXG59O1xcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuXFxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XFxufVxcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XFxufVxcblxcbn0se31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8vIEdyb3dsIC0gQ29weXJpZ2h0IFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+IChNSVQgTGljZW5zZWQpXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjXFxuICAsIGZzID0gcmVxdWlyZSgnZnMnKVxcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXFxuICAsIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMgfHwgcGF0aC5leGlzdHNTeW5jXFxuICAsIG9zID0gcmVxdWlyZSgnb3MnKVxcbiAgLCBxdW90ZSA9IEpTT04uc3RyaW5naWZ5XFxuICAsIGNtZDtcXG5cXG5mdW5jdGlvbiB3aGljaChuYW1lKSB7XFxuICB2YXIgcGF0aHMgPSBwcm9jZXNzLmVudi5QQVRILnNwbGl0KCc6Jyk7XFxuICB2YXIgbG9jO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGxvYyA9IHBhdGguam9pbihwYXRoc1tpXSwgbmFtZSk7XFxuICAgIGlmIChleGlzdHMobG9jKSkgcmV0dXJuIGxvYztcXG4gIH1cXG59XFxuXFxuc3dpdGNoKG9zLnR5cGUoKSkge1xcbiAgY2FzZSAnRGFyd2luJzpcXG4gICAgaWYgKHdoaWNoKCd0ZXJtaW5hbC1ub3RpZmllcicpKSB7XFxuICAgICAgY21kID0ge1xcbiAgICAgICAgICB0eXBlOiBcXFwiRGFyd2luLU5vdGlmaWNhdGlvbkNlbnRlclxcXCJcXG4gICAgICAgICwgcGtnOiBcXFwidGVybWluYWwtbm90aWZpZXJcXFwiXFxuICAgICAgICAsIG1zZzogJy1tZXNzYWdlJ1xcbiAgICAgICAgLCB0aXRsZTogJy10aXRsZSdcXG4gICAgICAgICwgc3VidGl0bGU6ICctc3VidGl0bGUnXFxuICAgICAgICAsIGljb246ICctYXBwSWNvbidcXG4gICAgICAgICwgc291bmQ6ICAnLXNvdW5kJ1xcbiAgICAgICAgLCB1cmw6ICctb3BlbidcXG4gICAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICAgIGNtZDogJy1leGVjdXRlJ1xcbiAgICAgICAgICAgICwgcmFuZ2U6IFtdXFxuICAgICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNtZCA9IHtcXG4gICAgICAgICAgdHlwZTogXFxcIkRhcndpbi1Hcm93bFxcXCJcXG4gICAgICAgICwgcGtnOiBcXFwiZ3Jvd2xub3RpZnlcXFwiXFxuICAgICAgICAsIG1zZzogJy1tJ1xcbiAgICAgICAgLCBzdGlja3k6ICctLXN0aWNreSdcXG4gICAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICAgIGNtZDogJy0tcHJpb3JpdHknXFxuICAgICAgICAgICAgLCByYW5nZTogW1xcbiAgICAgICAgICAgICAgICAtMlxcbiAgICAgICAgICAgICAgLCAtMVxcbiAgICAgICAgICAgICAgLCAwXFxuICAgICAgICAgICAgICAsIDFcXG4gICAgICAgICAgICAgICwgMlxcbiAgICAgICAgICAgICAgLCBcXFwiVmVyeSBMb3dcXFwiXFxuICAgICAgICAgICAgICAsIFxcXCJNb2RlcmF0ZVxcXCJcXG4gICAgICAgICAgICAgICwgXFxcIk5vcm1hbFxcXCJcXG4gICAgICAgICAgICAgICwgXFxcIkhpZ2hcXFwiXFxuICAgICAgICAgICAgICAsIFxcXCJFbWVyZ2VuY3lcXFwiXFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBicmVhaztcXG4gIGNhc2UgJ0xpbnV4JzpcXG4gICAgaWYgKHdoaWNoKCdncm93bCcpKSB7XFxuICAgICAgY21kID0ge1xcbiAgICAgICAgICB0eXBlOiBcXFwiTGludXgtR3Jvd2xcXFwiXFxuICAgICAgICAsIHBrZzogXFxcImdyb3dsXFxcIlxcbiAgICAgICAgLCBtc2c6ICctbSdcXG4gICAgICAgICwgdGl0bGU6ICctdGl0bGUnXFxuICAgICAgICAsIHN1YnRpdGxlOiAnLXN1YnRpdGxlJ1xcbiAgICAgICAgLCBob3N0OiB7XFxuICAgICAgICAgICAgY21kOiAnLUgnXFxuICAgICAgICAgICwgaG9zdG5hbWU6ICcxOTIuMTY4LjMzLjEnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjbWQgPSB7XFxuICAgICAgICAgIHR5cGU6IFxcXCJMaW51eFxcXCJcXG4gICAgICAgICwgcGtnOiBcXFwibm90aWZ5LXNlbmRcXFwiXFxuICAgICAgICAsIG1zZzogJydcXG4gICAgICAgICwgc3RpY2t5OiAnLXQgMCdcXG4gICAgICAgICwgaWNvbjogJy1pJ1xcbiAgICAgICAgLCBwcmlvcml0eToge1xcbiAgICAgICAgICAgIGNtZDogJy11J1xcbiAgICAgICAgICAsIHJhbmdlOiBbXFxuICAgICAgICAgICAgICBcXFwibG93XFxcIlxcbiAgICAgICAgICAgICwgXFxcIm5vcm1hbFxcXCJcXG4gICAgICAgICAgICAsIFxcXCJjcml0aWNhbFxcXCJcXG4gICAgICAgICAgXVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgYnJlYWs7XFxuICBjYXNlICdXaW5kb3dzX05UJzpcXG4gICAgY21kID0ge1xcbiAgICAgICAgdHlwZTogXFxcIldpbmRvd3NcXFwiXFxuICAgICAgLCBwa2c6IFxcXCJncm93bG5vdGlmeVxcXCJcXG4gICAgICAsIG1zZzogJydcXG4gICAgICAsIHN0aWNreTogJy9zOnRydWUnXFxuICAgICAgLCB0aXRsZTogJy90OidcXG4gICAgICAsIGljb246ICcvaTonXFxuICAgICAgLCB1cmw6ICcvY3U6J1xcbiAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICBjbWQ6ICcvcDonXFxuICAgICAgICAgICwgcmFuZ2U6IFtcXG4gICAgICAgICAgICAgIC0yXFxuICAgICAgICAgICAgLCAtMVxcbiAgICAgICAgICAgICwgMFxcbiAgICAgICAgICAgICwgMVxcbiAgICAgICAgICAgICwgMlxcbiAgICAgICAgICBdXFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIGJyZWFrO1xcbn1cXG5cXG4vKipcXG4gKiBFeHBvc2UgYGdyb3dsYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBncm93bDtcXG5cXG4vKipcXG4gKiBOb2RlLWdyb3dsIHZlcnNpb24uXFxuICovXFxuXFxuZXhwb3J0cy52ZXJzaW9uID0gJzEuNC4xJ1xcblxcbi8qKlxcbiAqIFNlbmQgZ3Jvd2wgbm90aWZpY2F0aW9uIF9tc2dfIHdpdGggX29wdGlvbnNfLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAtIHRpdGxlICAgTm90aWZpY2F0aW9uIHRpdGxlXFxuICogIC0gc3RpY2t5ICBNYWtlIHRoZSBub3RpZmljYXRpb24gc3RpY2sgKGRlZmF1bHRzIHRvIGZhbHNlKVxcbiAqICAtIHByaW9yaXR5ICBTcGVjaWZ5IGFuIGludCBvciBuYW1lZCBrZXkgKGRlZmF1bHQgaXMgMClcXG4gKiAgLSBuYW1lICAgIEFwcGxpY2F0aW9uIG5hbWUgKGRlZmF1bHRzIHRvIGdyb3dsbm90aWZ5KVxcbiAqICAtIHNvdW5kICAgU291bmQgZWZlY3QgKCBpbiBPU3ggZGVmaW5lZCBpbiBwcmVmZXJlbmNlcyAtPiBzb3VuZCAtPiBlZmZlY3RzKSAqIHdvcmtzIG9ubHkgaW4gT1NYID4gMTAuOHhcXG4gKiAgLSBpbWFnZVxcbiAqICAgIC0gcGF0aCB0byBhbiBpY29uIHNldHMgLS1pY29ucGF0aFxcbiAqICAgIC0gcGF0aCB0byBhbiBpbWFnZSBzZXRzIC0taW1hZ2VcXG4gKiAgICAtIGNhcGl0YWxpemVkIHdvcmQgc2V0cyAtLWFwcEljb25cXG4gKiAgICAtIGZpbGVuYW1lIHVzZXMgZXh0bmFtZSBhcyAtLWljb25cXG4gKiAgICAtIG90aGVyd2lzZSB0cmVhdGVkIGFzIC0taWNvblxcbiAqXFxuICogRXhhbXBsZXM6XFxuICpcXG4gKiAgIGdyb3dsKCdOZXcgZW1haWwnKVxcbiAqICAgZ3Jvd2woJzUgbmV3IGVtYWlscycsIHsgdGl0bGU6ICdUaHVuZGVyYmlyZCcgfSlcXG4gKiAgIGdyb3dsKCc1IG5ldyBlbWFpbHMnLCB7IHRpdGxlOiAnVGh1bmRlcmJpcmQnLCBzb3VuZDogJ1B1cnInIH0pXFxuICogICBncm93bCgnRW1haWwgc2VudCcsIGZ1bmN0aW9uKCl7XFxuICogICAgIC8vIC4uLiBub3RpZmljYXRpb24gc2VudFxcbiAqICAgfSlcXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBncm93bChtc2csIG9wdGlvbnMsIGZuKSB7XFxuICB2YXIgaW1hZ2VcXG4gICAgLCBhcmdzXFxuICAgICwgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cXG4gICAgLCBmbiA9IGZuIHx8IGZ1bmN0aW9uKCl7fTtcXG5cXG4gIGlmIChvcHRpb25zLmV4ZWMpIHtcXG4gICAgY21kID0ge1xcbiAgICAgICAgdHlwZTogXFxcIkN1c3RvbVxcXCJcXG4gICAgICAsIHBrZzogb3B0aW9ucy5leGVjXFxuICAgICAgLCByYW5nZTogW11cXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIG5vb3BcXG4gIGlmICghY21kKSByZXR1cm4gZm4obmV3IEVycm9yKCdncm93bCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm0nKSk7XFxuICBhcmdzID0gW2NtZC5wa2ddO1xcblxcbiAgLy8gaW1hZ2VcXG4gIGlmIChpbWFnZSA9IG9wdGlvbnMuaW1hZ2UpIHtcXG4gICAgc3dpdGNoKGNtZC50eXBlKSB7XFxuICAgICAgY2FzZSAnRGFyd2luLUdyb3dsJzpcXG4gICAgICAgIHZhciBmbGFnLCBleHQgPSBwYXRoLmV4dG5hbWUoaW1hZ2UpLnN1YnN0cigxKVxcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgZXh0ID09ICdpY25zJyAmJiAnaWNvbnBhdGgnXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAvXltBLVpdLy50ZXN0KGltYWdlKSAmJiAnYXBwSWNvbidcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8IC9ecG5nfGdpZnxqcGU/ZyQvLnRlc3QoZXh0KSAmJiAnaW1hZ2UnXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCBleHQgJiYgKGltYWdlID0gZXh0KSAmJiAnaWNvbidcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8ICdpY29uJ1xcbiAgICAgICAgYXJncy5wdXNoKCctLScgKyBmbGFnLCBxdW90ZShpbWFnZSkpXFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdEYXJ3aW4tTm90aWZpY2F0aW9uQ2VudGVyJzpcXG4gICAgICAgIGFyZ3MucHVzaChjbWQuaWNvbiwgcXVvdGUoaW1hZ2UpKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ0xpbnV4JzpcXG4gICAgICAgIGFyZ3MucHVzaChjbWQuaWNvbiwgcXVvdGUoaW1hZ2UpKTtcXG4gICAgICAgIC8vIGxpYm5vdGlmeSBkZWZhdWx0cyB0byBzdGlja3ksIHNldCBhIGhpbnQgZm9yIHRyYW5zaWVudCBub3RpZmljYXRpb25zXFxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RpY2t5KSBhcmdzLnB1c2goJy0taGludD1pbnQ6dHJhbnNpZW50OjEnKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ1dpbmRvd3MnOlxcbiAgICAgICAgYXJncy5wdXNoKGNtZC5pY29uICsgcXVvdGUoaW1hZ2UpKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBzdGlja3lcXG4gIGlmIChvcHRpb25zLnN0aWNreSkgYXJncy5wdXNoKGNtZC5zdGlja3kpO1xcblxcbiAgLy8gcHJpb3JpdHlcXG4gIGlmIChvcHRpb25zLnByaW9yaXR5KSB7XFxuICAgIHZhciBwcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHkgKyAnJztcXG4gICAgdmFyIGNoZWNraW5kZXhPZiA9IGNtZC5wcmlvcml0eS5yYW5nZS5pbmRleE9mKHByaW9yaXR5KTtcXG4gICAgaWYgKH5jbWQucHJpb3JpdHkucmFuZ2UuaW5kZXhPZihwcmlvcml0eSkpIHtcXG4gICAgICBhcmdzLnB1c2goY21kLnByaW9yaXR5LCBvcHRpb25zLnByaW9yaXR5KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy9zb3VuZFxcbiAgaWYob3B0aW9ucy5zb3VuZCAmJiBjbWQudHlwZSA9PT0gJ0Rhcndpbi1Ob3RpZmljYXRpb25DZW50ZXInKXtcXG4gICAgYXJncy5wdXNoKGNtZC5zb3VuZCwgb3B0aW9ucy5zb3VuZClcXG4gIH1cXG5cXG4gIC8vIG5hbWVcXG4gIGlmIChvcHRpb25zLm5hbWUgJiYgY21kLnR5cGUgPT09IFxcXCJEYXJ3aW4tR3Jvd2xcXFwiKSB7XFxuICAgIGFyZ3MucHVzaCgnLS1uYW1lJywgb3B0aW9ucy5uYW1lKTtcXG4gIH1cXG5cXG4gIHN3aXRjaChjbWQudHlwZSkge1xcbiAgICBjYXNlICdEYXJ3aW4tR3Jvd2wnOlxcbiAgICAgIGFyZ3MucHVzaChjbWQubXNnKTtcXG4gICAgICBhcmdzLnB1c2gocXVvdGUobXNnKS5yZXBsYWNlKC9cXFxcXFxcXG4vZywgJ1xcXFxuJykpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdEYXJ3aW4tTm90aWZpY2F0aW9uQ2VudGVyJzpcXG4gICAgICBhcmdzLnB1c2goY21kLm1zZyk7XFxuICAgICAgdmFyIHN0cmluZ2lmaWVkTXNnID0gcXVvdGUobXNnKTtcXG4gICAgICB2YXIgZXNjYXBlZE1zZyA9IHN0cmluZ2lmaWVkTXNnLnJlcGxhY2UoL1xcXFxcXFxcbi9nLCAnXFxcXG4nKTtcXG4gICAgICBhcmdzLnB1c2goZXNjYXBlZE1zZyk7XFxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcXG4gICAgICAgIGFyZ3MucHVzaChjbWQudGl0bGUpO1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMudGl0bGUpKTtcXG4gICAgICB9XFxuICAgICAgaWYgKG9wdGlvbnMuc3VidGl0bGUpIHtcXG4gICAgICAgIGFyZ3MucHVzaChjbWQuc3VidGl0bGUpO1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMuc3VidGl0bGUpKTtcXG4gICAgICB9XFxuICAgICAgaWYgKG9wdGlvbnMudXJsKSB7XFxuICAgICAgICBhcmdzLnB1c2goY21kLnVybCk7XFxuICAgICAgICBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy51cmwpKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ0xpbnV4LUdyb3dsJzpcXG4gICAgICBhcmdzLnB1c2goY21kLm1zZyk7XFxuICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykucmVwbGFjZSgvXFxcXFxcXFxuL2csICdcXFxcbicpKTtcXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMudGl0bGUpKTtcXG4gICAgICBpZiAoY21kLmhvc3QpIHtcXG4gICAgICAgIGFyZ3MucHVzaChjbWQuaG9zdC5jbWQsIGNtZC5ob3N0Lmhvc3RuYW1lKVxcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnTGludXgnOlxcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XFxuICAgICAgICBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgICAgYXJncy5wdXNoKGNtZC5tc2cpO1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykucmVwbGFjZSgvXFxcXFxcXFxuL2csICdcXFxcbicpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykucmVwbGFjZSgvXFxcXFxcXFxuL2csICdcXFxcbicpKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ1dpbmRvd3MnOlxcbiAgICAgIGFyZ3MucHVzaChxdW90ZShtc2cpLnJlcGxhY2UoL1xcXFxcXFxcbi9nLCAnXFxcXG4nKSk7XFxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIGFyZ3MucHVzaChjbWQudGl0bGUgKyBxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgaWYgKG9wdGlvbnMudXJsKSBhcmdzLnB1c2goY21kLnVybCArIHF1b3RlKG9wdGlvbnMudXJsKSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ0N1c3RvbSc6XFxuICAgICAgYXJnc1swXSA9IChmdW5jdGlvbihvcmlnQ29tbWFuZCkge1xcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLnRpdGxlXFxuICAgICAgICAgID8gb3B0aW9ucy50aXRsZSArICc6ICcgKyBtc2dcXG4gICAgICAgICAgOiBtc2c7XFxuICAgICAgICB2YXIgY29tbWFuZCA9IG9yaWdDb21tYW5kLnJlcGxhY2UoLyhefFteJV0pJXMvZywgJyQxJyArIHF1b3RlKG1lc3NhZ2UpKTtcXG4gICAgICAgIGlmIChjb21tYW5kID09PSBvcmlnQ29tbWFuZCkgYXJncy5wdXNoKHF1b3RlKG1lc3NhZ2UpKTtcXG4gICAgICAgIHJldHVybiBjb21tYW5kO1xcbiAgICAgIH0pKGFyZ3NbMF0pO1xcbiAgICAgIGJyZWFrO1xcbiAgfVxcblxcbiAgLy8gZXhlY3V0ZVxcbiAgZXhlYyhhcmdzLmpvaW4oJyAnKSwgZm4pO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwiY2hpbGRfcHJvY2Vzc1xcXCI6NDMsXFxcImZzXFxcIjo0MyxcXFwib3NcXFwiOjU2LFxcXCJwYXRoXFxcIjo0M31dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG1cXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXFxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXFxuICB2YXIgbkJpdHMgPSAtN1xcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXFxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxcblxcbiAgaSArPSBkXFxuXFxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgcyA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IGVMZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgZSA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IG1MZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBpZiAoZSA9PT0gMCkge1xcbiAgICBlID0gMSAtIGVCaWFzXFxuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcXG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXFxuICB9IGVsc2Uge1xcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXFxuICAgIGUgPSBlIC0gZUJpYXNcXG4gIH1cXG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXFxufVxcblxcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcXG4gIHZhciBlLCBtLCBjXFxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXFxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxcblxcbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcXG5cXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XFxuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxcbiAgICBlID0gZU1heFxcbiAgfSBlbHNlIHtcXG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXFxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcXG4gICAgICBlLS1cXG4gICAgICBjICo9IDJcXG4gICAgfVxcbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICB2YWx1ZSArPSBydCAvIGNcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcXG4gICAgfVxcbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcXG4gICAgICBlKytcXG4gICAgICBjIC89IDJcXG4gICAgfVxcblxcbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcXG4gICAgICBtID0gMFxcbiAgICAgIGUgPSBlTWF4XFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gZSArIGVCaWFzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IDBcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cXG5cXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cXG4gIGVMZW4gKz0gbUxlblxcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxcblxcbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XFxufVxcblxcbn0se31dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcXG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xcbiAgICAgIGNvbnN0cnVjdG9yOiB7XFxuICAgICAgICB2YWx1ZTogY3RvcixcXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG59IGVsc2Uge1xcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XFxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXFxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XFxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcXG4gIH1cXG59XFxuXFxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgQnVmZmVyXFxuICpcXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cXG4gKiBMaWNlbnNlOiAgTUlUXFxuICpcXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXFxuICAgIChvYmouX2lzQnVmZmVyIHx8IC8vIEZvciBTYWZhcmkgNS03IChtaXNzaW5nIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpXFxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxcbiAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcXG4gICAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSlcXG4gICAgKSlcXG59XFxuXFxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgXzA3NzcgPSBwYXJzZUludCgnMDc3NycsIDgpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gbWtkaXJQLm1rZGlycCA9IG1rZGlyUC5ta2RpclAgPSBta2RpclA7XFxuXFxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgZiA9IG9wdHM7XFxuICAgICAgICBvcHRzID0ge307XFxuICAgIH1cXG4gICAgZWxzZSBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XFxuICAgIH1cXG4gICAgXFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcXG4gICAgXFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIG1vZGUgPSBfMDc3NyAmICh+cHJvY2Vzcy51bWFzaygpKTtcXG4gICAgfVxcbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xcbiAgICBcXG4gICAgdmFyIGNiID0gZiB8fCBmdW5jdGlvbiAoKSB7fTtcXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcXG4gICAgXFxuICAgIHhmcy5ta2RpcihwLCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcXG4gICAgICAgIGlmICghZXIpIHtcXG4gICAgICAgICAgICBtYWRlID0gbWFkZSB8fCBwO1xcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBtYWRlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN3aXRjaCAoZXIuY29kZSkge1xcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XFxuICAgICAgICAgICAgICAgIG1rZGlyUChwYXRoLmRpcm5hbWUocCksIG9wdHMsIGZ1bmN0aW9uIChlciwgbWFkZSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyKSBjYihlciwgbWFkZSk7XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIG1rZGlyUChwLCBvcHRzLCBjYiwgbWFkZSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICB4ZnMuc3RhdChwLCBmdW5jdGlvbiAoZXIyLCBzdGF0KSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdCBmYWlscywgdGhlbiB0aGF0J3Mgc3VwZXIgd2VpcmQuXFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcjIgfHwgIXN0YXQuaXNEaXJlY3RvcnkoKSkgY2IoZXIsIG1hZGUpXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGNiKG51bGwsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5cXG5ta2RpclAuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKHAsIG9wdHMsIG1hZGUpIHtcXG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xcbiAgICB9XFxuICAgIFxcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcXG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XFxuICAgIFxcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XFxuICAgIH1cXG4gICAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbDtcXG5cXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcXG5cXG4gICAgdHJ5IHtcXG4gICAgICAgIHhmcy5ta2RpclN5bmMocCwgbW9kZSk7XFxuICAgICAgICBtYWRlID0gbWFkZSB8fCBwO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnIwKSB7XFxuICAgICAgICBzd2l0Y2ggKGVycjAuY29kZSkge1xcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCcgOlxcbiAgICAgICAgICAgICAgICBtYWRlID0gc3luYyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICBzeW5jKHAsIG9wdHMsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICB2YXIgc3RhdDtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXQgPSB4ZnMuc3RhdFN5bmMocCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycjEpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHRocm93IGVycjA7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBtYWRlO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwiZnNcXFwiOjQzLFxcXCJwYXRoXFxcIjo0M31dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XFxuXFxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxcbiAgICB9XFxuICAgIGVsc2UgcmV0dXJuICcnO1xcbn07XFxuXFxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcXG5cXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcXG5cXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xcbn07XFxuXFxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XFxufTtcXG5cXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xcblxcbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xcblxcbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XFxuICAgIH1cXG4gICAgcmV0dXJuICcnO1xcbn07XFxuXFxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcXG5cXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcXG5cXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XFxuXFxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuICcvdG1wJztcXG59O1xcblxcbmV4cG9ydHMuRU9MID0gJ1xcXFxuJztcXG5cXG59LHt9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcXG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcXG59IGVsc2Uge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xcbn1cXG5cXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiY2FsbGJhY2tcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xcbiAgfVxcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICB2YXIgYXJncywgaTtcXG4gIHN3aXRjaCAobGVuKSB7XFxuICBjYXNlIDA6XFxuICBjYXNlIDE6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcXG4gIGNhc2UgMjpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XFxuICAgIH0pO1xcbiAgY2FzZSAzOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcXG4gICAgfSk7XFxuICBjYXNlIDQ6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XFxuICAgIH0pO1xcbiAgZGVmYXVsdDpcXG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcXG4gICAgaSA9IDA7XFxuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcXG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XFxuICAgIH1cXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xcbiAgICB9KTtcXG4gIH1cXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1OH1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcXG5cXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxuXFxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxuXFxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcXG5cXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XFxuXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XFxuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XFxuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XFxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcXG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcXG5cXG5cXG5cXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cXG5cXG5mdW5jdGlvbiBTdHJlYW0oKSB7XFxuICBFRS5jYWxsKHRoaXMpO1xcbn1cXG5cXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XFxuICB2YXIgc291cmNlID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XFxuICAgICAgICBzb3VyY2UucGF1c2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XFxuXFxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcXG4gICAgICBzb3VyY2UucmVzdW1lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXFxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcXG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgfVxcblxcbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcXG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XFxuICAgIGRpZE9uRW5kID0gdHJ1ZTtcXG5cXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG5cXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XFxuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xcbiAgICBkaWRPbkVuZCA9IHRydWU7XFxuXFxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcXG4gIH1cXG5cXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgY2xlYW51cCgpO1xcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcXG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XFxuXFxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG59LHtcXFwiZXZlbnRzXFxcIjo1MCxcXFwiaW5oZXJpdHNcXFwiOjUzLFxcXCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXFxcIjo2MSxcXFwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXFxcIjo2NyxcXFwicmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzXFxcIjo2OCxcXFwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xcXCI6NjksXFxcInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qc1xcXCI6NzB9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuYXJndW1lbnRzWzRdWzQ2XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcXG59LHtcXFwiZHVwXFxcIjo0Nn1dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIilcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcXFwiOjYyfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXFxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3NcXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXFxuLy8gV3JpdGFibGUuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XFxuICB2YXIga2V5cyA9IFtdO1xcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICBrZXlzLnB1c2goa2V5KTtcXG4gIH1yZXR1cm4ga2V5cztcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xcblxcbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XFxuXFxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XFxuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XFxuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcXG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcXG59XFxuXFxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcXG5cXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XFxuXFxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XFxuXFxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcXG59XFxuXFxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxcbmZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcXG4gIC8vIHRoZW4gd2UncmUgb2suXFxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcXG5cXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxcbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcXG4gIHNlbGYuZW5kKCk7XFxufVxcblxcbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGYoeHNbaV0sIGkpO1xcbiAgfVxcbn1cXG59LHtcXFwiLi9fc3RyZWFtX3JlYWRhYmxlXFxcIjo2NCxcXFwiLi9fc3RyZWFtX3dyaXRhYmxlXFxcIjo2NixcXFwiY29yZS11dGlsLWlzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjUzLFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTd9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXFxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXFxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcXG5cXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xcblxcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XFxuXFxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcXG59XFxuXFxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2IobnVsbCwgY2h1bmspO1xcbn07XFxufSx7XFxcIi4vX3N0cmVhbV90cmFuc2Zvcm1cXFwiOjY1LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQ3LFxcXCJpbmhlcml0c1xcXCI6NTN9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxuXFxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgU3RyZWFtO1xcbihmdW5jdGlvbiAoKSB7XFxuICB0cnkge1xcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XFxuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxuICB9XFxufSkoKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xcbn0gZWxzZSB7XFxuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xcbn1cXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgU3RyaW5nRGVjb2RlcjtcXG5cXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xcblxcbnZhciBoYXNQcmVwZW5kTGlzdGVuZXIgPSB0eXBlb2YgRUUucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcXG5cXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XFxuICBpZiAoaGFzUHJlcGVuZExpc3RlbmVyKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcXG5cXG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZVxcbiAgLy8gb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkcyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnNcXG4gIC8vIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZSB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbFxcbiAgLy8gaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XFxufVxcblxcbnZhciBEdXBsZXg7XFxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXFxuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFxcXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXFxcIlxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcXG5cXG4gIC8vIGNhc3QgdG8gaW50cy5cXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcXG5cXG4gIHRoaXMuYnVmZmVyID0gW107XFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuICB0aGlzLnBpcGVzID0gbnVsbDtcXG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XFxuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XFxuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcXG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFxcXCJsYXRlclxcXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXFxuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cXG4gIHRoaXMuc3luYyA9IHRydWU7XFxuXFxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXFxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcXG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXFxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xcblxcbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XFxuXFxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XFxuXFxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XFxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcXG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XFxuICB9XFxufVxcblxcbnZhciBEdXBsZXg7XFxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XFxuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3lcXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcXG5cXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xcbn1cXG5cXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXFxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XFxuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcXG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xcbiAgICAgIGVuY29kaW5nID0gJyc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcXG59O1xcblxcbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXFxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcXG59O1xcblxcblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcXG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xcbiAgaWYgKGVyKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcXG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcXG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XFxuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XFxuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XFxuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgc2tpcEFkZDtcXG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcXG4gICAgICBpZiAoIXNraXBBZGQpIHtcXG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXFxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcXG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XFxuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcblxcbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcXG59XFxuXFxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXFxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxcbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcXG59XFxuXFxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXFxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXFxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XFxuICBpZiAobiA+PSBNQVhfSFdNKSB7XFxuICAgIG4gPSBNQVhfSFdNO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxcbiAgICBuLS07XFxuICAgIG4gfD0gbiA+Pj4gMTtcXG4gICAgbiB8PSBuID4+PiAyO1xcbiAgICBuIHw9IG4gPj4+IDQ7XFxuICAgIG4gfD0gbiA+Pj4gODtcXG4gICAgbiB8PSBuID4+PiAxNjtcXG4gICAgbisrO1xcbiAgfVxcbiAgcmV0dXJuIG47XFxufVxcblxcbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xcblxcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiBuID09PSAwID8gMCA6IDE7XFxuXFxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xcbiAgfVxcblxcbiAgaWYgKG4gPD0gMCkgcmV0dXJuIDA7XFxuXFxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcXG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XFxuICAvLyBhbW91bnRzLlxcbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XFxuXFxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXFxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XFxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbjtcXG59XFxuXFxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICBkZWJ1ZygncmVhZCcsIG4pO1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBuT3JpZyA9IG47XFxuXFxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxcbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcXG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XFxuXFxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXFxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXFxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXFxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cXG4gIC8vXFxuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcXG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXFxuICAvL1xcbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXFxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXFxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxcbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XFxuICAvLyAncmVhZGFibGUnIGV0Yy5cXG4gIC8vXFxuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXFxuXFxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXFxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xcblxcbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIGRvUmVhZCA9IHRydWU7XFxuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XFxuICB9XFxuXFxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxcbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZG9SZWFkID0gZmFsc2U7XFxuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcXG4gIH1cXG5cXG4gIGlmIChkb1JlYWQpIHtcXG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcXG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XFxuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XFxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXFxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xcblxcbiAgdmFyIHJldDtcXG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcXG5cXG4gIGlmIChyZXQgPT09IG51bGwpIHtcXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgbiA9IDA7XFxuICB9XFxuXFxuICBzdGF0ZS5sZW5ndGggLT0gbjtcXG5cXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuXFxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXFxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcXG5cXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xcbiAgdmFyIGVyID0gbnVsbDtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XFxuICB9XFxuICByZXR1cm4gZXI7XFxufVxcblxcbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XFxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XFxuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgfVxcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcblxcbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXFxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG59XFxuXFxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXFxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXFxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcXG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XFxuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XFxuICBmbG93KHN0cmVhbSk7XFxufVxcblxcbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXFxuLy8gaXQncyBpbiBwcm9ncmVzcy5cXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XFxuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxcbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xcbiAgfVxcbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcXG59XFxuXFxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxcbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXFxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFxcXCJsZW5ndGhcXFwiIGlzIHNvbWV3aGF0XFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxcblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XFxufTtcXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xcbiAgdmFyIHNyYyA9IHRoaXM7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XFxuICAgIGNhc2UgMDpcXG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMTpcXG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcXG4gICAgICBicmVhaztcXG4gIH1cXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcXG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XFxuXFxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xcblxcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XFxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XFxuXFxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcXG4gICAgICBjbGVhbnVwKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgICBkZWJ1Zygnb25lbmQnKTtcXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcXG4gIC8vIHRvbyBzbG93LlxcbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XFxuICAgIGRlYnVnKCdjbGVhbnVwJyk7XFxuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xcblxcbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xcblxcbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXFxuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxcbiAgICAvLyBmbG93aW5nIGFnYWluLlxcbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXFxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xcbiAgfVxcblxcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBkZWJ1Zygnb25kYXRhJyk7XFxuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcXG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcXG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXFxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXFxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XFxuICAgICAgfVxcbiAgICAgIHNyYy5wYXVzZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XFxuICAgIHVucGlwZSgpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxcbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcXG4gICAgdW5waXBlKCk7XFxuICB9XFxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XFxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcXG4gICAgZGVidWcoJ29uZmluaXNoJyk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XFxuICAgIHVucGlwZSgpO1xcbiAgfVxcbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuXFxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XFxuICAgIGRlYnVnKCd1bnBpcGUnKTtcXG4gICAgc3JjLnVucGlwZShkZXN0KTtcXG4gIH1cXG5cXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXFxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xcblxcbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xcbiAgICBzcmMucmVzdW1lKCk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVzdDtcXG59O1xcblxcbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xcbiAgICAgIGZsb3coc3JjKTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xcblxcbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcXG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXFxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcXG5cXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XFxuXFxuICAgIC8vIGdvdCBhIG1hdGNoLlxcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXFxuXFxuICBpZiAoIWRlc3QpIHtcXG4gICAgLy8gcmVtb3ZlIGFsbC5cXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XFxuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuXFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcXG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XFxuICAgIH1yZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXFxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcXG5cXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcXG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xcblxcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXFxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xcblxcbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcXG4gICAgdGhpcy5yZXN1bWUoKTtcXG4gIH1cXG5cXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XFxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcXG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XFxuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXM7XFxufTtcXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XFxuXFxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XFxuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XFxuICBzZWxmLnJlYWQoMCk7XFxufVxcblxcbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZScpO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XFxuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XFxuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICB9XFxuXFxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcXG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcXG4gIGZsb3coc3RyZWFtKTtcXG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncGF1c2UnKTtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XFxuICBpZiAoc3RhdGUuZmxvd2luZykge1xcbiAgICBkbyB7XFxuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcXG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XFxuICB9XFxufVxcblxcbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXFxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxcbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxcblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XFxuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcXG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xcbiAgICB9XFxuXFxuICAgIHNlbGYucHVzaChudWxsKTtcXG4gIH0pO1xcblxcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuXFxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XFxuXFxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xcbiAgICBpZiAoIXJldCkge1xcbiAgICAgIHBhdXNlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLnBhdXNlKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxcbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXFxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgICAgfShpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxcbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcXG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcXG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xcbiAgfSk7XFxuXFxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXFxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xcbiAgICBpZiAocGF1c2VkKSB7XFxuICAgICAgcGF1c2VkID0gZmFsc2U7XFxuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIHNlbGY7XFxufTtcXG5cXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXFxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XFxuXFxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxcbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXFxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcXG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcXG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XFxuICB2YXIgcmV0O1xcblxcbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XFxuXFxuICBpZiAobGVuZ3RoID09PSAwKSByZXQgPSBudWxsO2Vsc2UgaWYgKG9iamVjdE1vZGUpIHJldCA9IGxpc3Quc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxcbiAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ID0gbGlzdC5qb2luKCcnKTtlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0ID0gbGlzdFswXTtlbHNlIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcXG4gICAgbGlzdC5sZW5ndGggPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXFxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcXG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXFxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXFxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XFxuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XFxuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcXG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBjb21wbGV4IGNhc2UuXFxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXFxuICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCA9ICcnO2Vsc2UgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcXG5cXG4gICAgICB2YXIgYyA9IDA7XFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xcbiAgICAgICAgdmFyIF9idWYgPSBsaXN0WzBdO1xcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBfYnVmLmxlbmd0aCk7XFxuXFxuICAgICAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ICs9IF9idWYuc2xpY2UoMCwgY3B5KTtlbHNlIF9idWYuY29weShyZXQsIGMsIDAsIGNweSk7XFxuXFxuICAgICAgICBpZiAoY3B5IDwgX2J1Zi5sZW5ndGgpIGxpc3RbMF0gPSBfYnVmLnNsaWNlKGNweSk7ZWxzZSBsaXN0LnNoaWZ0KCk7XFxuXFxuICAgICAgICBjICs9IGNweTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxcbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXFxcImVuZFJlYWRhYmxlKClcXFwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XFxuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcXG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XFxuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBmKHhzW2ldLCBpKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcXG4gIH1cXG4gIHJldHVybiAtMTtcXG59XFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vX3N0cmVhbV9kdXBsZXhcXFwiOjYyLFxcXCJfcHJvY2Vzc1xcXCI6NTgsXFxcImJ1ZmZlclxcXCI6NDUsXFxcImJ1ZmZlci1zaGltc1xcXCI6NDQsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDcsXFxcImV2ZW50c1xcXCI6NTAsXFxcImluaGVyaXRzXFxcIjo1MyxcXFwiaXNhcnJheVxcXCI6NjAsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NyxcXFwic3RyaW5nX2RlY29kZXIvXFxcIjo3MSxcXFwidXRpbFxcXCI6NDF9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xcbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXFxcImZpbHRlclxcXCIsXFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxcbi8vXFxuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxcbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cXG4vL1xcbi8vIEhlcmUncyBob3cgdGhpcyB3b3JrczpcXG4vL1xcbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXFxuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cXG4vL1xcbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXFxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xcbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cXG4vL1xcbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcXG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXFxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxcbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cXG4vL1xcbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xcblxcbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xcblxcbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XFxuICB9O1xcblxcbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XFxuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcXG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XFxuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XFxuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XFxuXFxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xcblxcbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XFxuXFxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcXG4gIHRzLndyaXRlY2IgPSBudWxsO1xcblxcbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcXG5cXG4gIGNiKGVyKTtcXG5cXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XFxuXFxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcXG5cXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xcblxcbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxcbiAgdmFyIHN0cmVhbSA9IHRoaXM7XFxuXFxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XFxuXFxuICBpZiAob3B0aW9ucykge1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XFxuICB9XFxuXFxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XFxuICAgICAgZG9uZShzdHJlYW0sIGVyKTtcXG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XFxuICB9KTtcXG59XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XFxufTtcXG5cXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cXG4vL1xcbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXFxuLy9cXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xcbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3VcXG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xcbn07XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XFxuICB0cy53cml0ZWNiID0gY2I7XFxuICB0cy53cml0ZWNodW5rID0gY2h1bms7XFxuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XFxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcXG4gIH1cXG59O1xcblxcbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXFxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXFxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XFxuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuXFxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXFxuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xcblxcbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XFxuXFxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XFxufVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo2MixcXFwiY29yZS11dGlsLWlzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjUzfV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXFxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGludGVybmFsVXRpbCA9IHtcXG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgU3RyZWFtO1xcbihmdW5jdGlvbiAoKSB7XFxuICB0cnkge1xcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XFxuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxuICB9XFxufSkoKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xcblxcbmZ1bmN0aW9uIG5vcCgpIHt9XFxuXFxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xcbiAgdGhpcy5uZXh0ID0gbnVsbDtcXG59XFxuXFxudmFyIER1cGxleDtcXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXFxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXFxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcXG5cXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xcblxcbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XFxuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XFxuXFxuICAvLyBjYXN0IHRvIGludHMuXFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XFxuXFxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XFxuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XFxuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcXG5cXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xcbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXFxuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxcbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcXG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcXG5cXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xcblxcbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcXG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcXG4gIC8vIHNvY2tldCBvciBmaWxlLlxcbiAgdGhpcy5sZW5ndGggPSAwO1xcblxcbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xcblxcbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxcbiAgdGhpcy5jb3JrZWQgPSAwO1xcblxcbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXFxcImxhdGVyXFxcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxcbiAgdGhpcy5zeW5jID0gdHJ1ZTtcXG5cXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xcblxcbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XFxuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XFxuICB9O1xcblxcbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXFxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xcblxcbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxcbiAgdGhpcy53cml0ZWxlbiA9IDA7XFxuXFxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcblxcbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xcblxcbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcXG5cXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXFxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xcblxcbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xcblxcbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xcbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcXG59XFxuXFxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUdldEJ1ZmZlcigpIHtcXG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XFxuICB2YXIgb3V0ID0gW107XFxuICB3aGlsZSAoY3VycmVudCkge1xcbiAgICBvdXQucHVzaChjdXJyZW50KTtcXG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcXG4gIH1cXG4gIHJldHVybiBvdXQ7XFxufTtcXG5cXG4oZnVuY3Rpb24gKCkge1xcbiAgdHJ5IHtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcXG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicpXFxuICAgIH0pO1xcbiAgfSBjYXRjaCAoXykge31cXG59KSgpO1xcblxcbnZhciBEdXBsZXg7XFxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XFxuXFxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3kuXFxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcXG5cXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcXG4gIH1cXG5cXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xcbn1cXG5cXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXFxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xcbn07XFxuXFxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XFxuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xcbn1cXG5cXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxcbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxcbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXFxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcXG4gIHZhciB2YWxpZCA9IHRydWU7XFxuICB2YXIgZXIgPSBmYWxzZTtcXG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxcbiAgLy8gaWYgd2UgYXJlIG5vdCBpbiBvYmplY3QgbW9kZSB0aGVuIHRocm93XFxuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcXG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xcbiAgfVxcbiAgaWYgKGVyKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XFxuICAgIHZhbGlkID0gZmFsc2U7XFxuICB9XFxuICByZXR1cm4gdmFsaWQ7XFxufVxcblxcbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHJldCA9IGZhbHNlO1xcblxcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGVuY29kaW5nO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9XFxuXFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xcblxcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XFxuXFxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIHN0YXRlLmNvcmtlZCsrO1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBpZiAoc3RhdGUuY29ya2VkKSB7XFxuICAgIHN0YXRlLmNvcmtlZC0tO1xcblxcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XFxuICB9XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XFxuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XFxuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcXG4gICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcXG4gIH1cXG4gIHJldHVybiBjaHVuaztcXG59XFxuXFxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXFxuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxcbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcXG5cXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcXG5cXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXFxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcXG5cXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICAgIGlmIChsYXN0KSB7XFxuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICB9XFxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XFxuICB9IGVsc2Uge1xcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XFxuICBzdGF0ZS53cml0ZWNiID0gY2I7XFxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcXG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XFxuICAtLXN0YXRlLnBlbmRpbmdjYjtcXG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcXG5cXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcXG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcXG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcXG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XFxuXFxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xcblxcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcXG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XFxuXFxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3luYykge1xcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXFxuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcXG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcXG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgY2IoKTtcXG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbn1cXG5cXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxcbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XFxuICB9XFxufVxcblxcbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XFxuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XFxuXFxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXFxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XFxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XFxuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XFxuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xcblxcbiAgICB2YXIgY291bnQgPSAwO1xcbiAgICB3aGlsZSAoZW50cnkpIHtcXG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgIGNvdW50ICs9IDE7XFxuICAgIH1cXG5cXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xcblxcbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcXG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxcbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXFxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxcbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gIH1cXG5cXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xcbn1cXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBjaHVuaztcXG4gICAgY2h1bmsgPSBudWxsO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGVuY29kaW5nO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9XFxuXFxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xcblxcbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcXG4gICAgc3RhdGUuY29ya2VkID0gMTtcXG4gICAgdGhpcy51bmNvcmsoKTtcXG4gIH1cXG5cXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcXG59O1xcblxcbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcXG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XFxufVxcblxcbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XFxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XFxuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xcbiAgaWYgKG5lZWQpIHtcXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcXG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5lZWQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XFxuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICBpZiAoY2IpIHtcXG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcXG4gIH1cXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcXG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xcbn1cXG5cXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3RcXG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgdGhpcy5uZXh0ID0gbnVsbDtcXG4gIHRoaXMuZW50cnkgPSBudWxsO1xcblxcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgICAgIGNiKGVycik7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICB9XFxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xcbiAgICB9XFxuICB9O1xcbn1cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6NjIsXFxcIl9wcm9jZXNzXFxcIjo1OCxcXFwiYnVmZmVyXFxcIjo0NSxcXFwiYnVmZmVyLXNoaW1zXFxcIjo0NCxcXFwiY29yZS11dGlsLWlzXFxcIjo0NyxcXFwiZXZlbnRzXFxcIjo1MCxcXFwiaW5oZXJpdHNcXFwiOjUzLFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTcsXFxcInV0aWwtZGVwcmVjYXRlXFxcIjo3M31dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXFxcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcXFwiKVxcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXFxcIjo2M31dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbnZhciBTdHJlYW0gPSAoZnVuY3Rpb24gKCl7XFxuICB0cnkge1xcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcXG4gIH0gY2F0Y2goXyl7fVxcbn0oKSk7XFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xcbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XFxuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XFxuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIjo2MixcXFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xcXCI6NjMsXFxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcXFwiOjY0LFxcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCI6NjUsXFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjY2LFxcXCJfcHJvY2Vzc1xcXCI6NTh9XSw2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFxcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCIpXFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXFxcIjo2NX1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiKVxcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXFxcIjo2Nn1dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xcblxcbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XFxuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XFxuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xcbiAgICAgICB9XFxuICAgICB9XFxuXFxuXFxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcXG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xcbiAgfVxcbn1cXG5cXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXFxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXFxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXFxuLy9cXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcXG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXFxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxcbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcXG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XFxuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XFxuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXFxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAndWNzMic6XFxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XFxuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XFxuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xcbiAgICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxcbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcXG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcXG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XFxufTtcXG5cXG5cXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXFxuLy9cXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXFxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICB2YXIgY2hhclN0ciA9ICcnO1xcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcXG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cXG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcXG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XFxuXFxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XFxuXFxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXFxuICAgICAgcmV0dXJuICcnO1xcbiAgICB9XFxuXFxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcXG5cXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcXG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xcblxcbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXFxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XFxuICAgICAgY2hhclN0ciA9ICcnO1xcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcXG5cXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiBjaGFyU3RyO1xcbiAgICB9XFxuICAgIGJyZWFrO1xcbiAgfVxcblxcbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xcblxcbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XFxuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XFxuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XFxuICB9XFxuXFxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xcblxcbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcXG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcXG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XFxuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcXG4gIH1cXG5cXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxcbiAgcmV0dXJuIGNoYXJTdHI7XFxufTtcXG5cXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXFxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XFxuXFxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXFxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXFxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XFxuXFxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXFxuXFxuICAgIC8vIDExMFhYWFhYXFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcXG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuXFxuICAgIC8vIDExMTBYWFhYXFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcXG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuXFxuICAgIC8vIDExMTEwWFhYXFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcXG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICB9XFxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XFxufTtcXG5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gIHZhciByZXMgPSAnJztcXG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xcblxcbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XFxuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcXG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXM7XFxufTtcXG5cXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XFxuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XFxuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xcbn1cXG5cXG59LHtcXFwiYnVmZmVyXFxcIjo0NX1dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYHRvSXNvU3RyaW5nYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHRvSXNvU3RyaW5nO1xcblxcblxcbi8qKlxcbiAqIFR1cm4gYSBgZGF0ZWAgaW50byBhbiBJU08gc3RyaW5nLlxcbiAqXFxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0lTT1N0cmluZ1xcbiAqXFxuICogQHBhcmFtIHtEYXRlfSBkYXRlXFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqL1xcblxcbmZ1bmN0aW9uIHRvSXNvU3RyaW5nIChkYXRlKSB7XFxuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpXFxuICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpXFxuICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpKVxcbiAgICArICdUJyArIHBhZChkYXRlLmdldFVUQ0hvdXJzKCkpXFxuICAgICsgJzonICsgcGFkKGRhdGUuZ2V0VVRDTWludXRlcygpKVxcbiAgICArICc6JyArIHBhZChkYXRlLmdldFVUQ1NlY29uZHMoKSlcXG4gICAgKyAnLicgKyBTdHJpbmcoKGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkvMTAwMCkudG9GaXhlZCgzKSkuc2xpY2UoMiwgNSlcXG4gICAgKyAnWic7XFxufVxcblxcblxcbi8qKlxcbiAqIFBhZCBhIGBudW1iZXJgIHdpdGggYSB0ZW4ncyBwbGFjZSB6ZXJvLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxcbiAqIEByZXR1cm4ge1N0cmluZ31cXG4gKi9cXG5cXG5mdW5jdGlvbiBwYWQgKG51bWJlcikge1xcbiAgdmFyIG4gPSBudW1iZXIudG9TdHJpbmcoKTtcXG4gIHJldHVybiBuLmxlbmd0aCA9PT0gMSA/ICcwJyArIG4gOiBuO1xcbn1cXG59LHt9XSw3MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcblxcbi8qKlxcbiAqIE1vZHVsZSBleHBvcnRzLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xcblxcbi8qKlxcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXFxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXFxuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFxcXCJkZXByZWNhdGVkXFxcIiB2ZXJzaW9uIG9mIGBmbmBcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XFxuICAgIHJldHVybiBmbjtcXG4gIH1cXG5cXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XFxuICAgIGlmICghd2FybmVkKSB7XFxuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcXG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XFxuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xcbiAgICAgIH1cXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcXG4gIHRyeSB7XFxuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xcbiAgfSBjYXRjaCAoXykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcXG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XFxuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXFxuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XFxufVxcbn0se31dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcXG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcXG4gIGlmICghaXNTdHJpbmcoZikpIHtcXG4gICAgdmFyIG9iamVjdHMgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcXG4gICAgfVxcbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XFxuICB9XFxuXFxuICB2YXIgaSA9IDE7XFxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcXG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcXG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XFxuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XFxuICAgIHN3aXRjaCAoeCkge1xcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJyVqJzpcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xcbiAgICAgICAgfSBjYXRjaCAoXykge1xcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xcbiAgICAgICAgfVxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4geDtcXG4gICAgfVxcbiAgfSk7XFxuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xcbiAgICAgIHN0ciArPSAnICcgKyB4O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gc3RyO1xcbn07XFxuXFxuXFxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0Llxcbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXFxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XFxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxcbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuICB9XFxuXFxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XFxuICAgIHJldHVybiBmbjtcXG4gIH1cXG5cXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XFxuICAgIGlmICghd2FybmVkKSB7XFxuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcXG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xcbiAgICAgIH1cXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XFxufTtcXG5cXG5cXG52YXIgZGVidWdzID0ge307XFxudmFyIGRlYnVnRW52aXJvbjtcXG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XFxuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcXG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXFxcXFxiJyArIHNldCArICdcXFxcXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcXG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XFxuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xcbn07XFxuXFxuXFxuLyoqXFxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxcbiAqL1xcbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xcbiAgLy8gZGVmYXVsdCBvcHRpb25zXFxuICB2YXIgY3R4ID0ge1xcbiAgICBzZWVuOiBbXSxcXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcXG4gIH07XFxuICAvLyBsZWdhY3kuLi5cXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XFxuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XFxuICAgIC8vIGxlZ2FjeS4uLlxcbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XFxuICB9IGVsc2UgaWYgKG9wdHMpIHtcXG4gICAgLy8gZ290IGFuIFxcXCJvcHRpb25zXFxcIiBvYmplY3RcXG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XFxuICB9XFxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcXG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XFxuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XFxufVxcbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XFxuXFxuXFxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXFxuaW5zcGVjdC5jb2xvcnMgPSB7XFxuICAnYm9sZCcgOiBbMSwgMjJdLFxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcXG4gICdncmV5JyA6IFs5MCwgMzldLFxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXFxuICAnY3lhbicgOiBbMzYsIDM5XSxcXG4gICdncmVlbicgOiBbMzIsIDM5XSxcXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cXG59O1xcblxcbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxcbmluc3BlY3Quc3R5bGVzID0ge1xcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXFxuICAnbnVtYmVyJzogJ3llbGxvdycsXFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcXG4gICdudWxsJzogJ2JvbGQnLFxcbiAgJ3N0cmluZyc6ICdncmVlbicsXFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcXG4gIC8vIFxcXCJuYW1lXFxcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xcbiAgJ3JlZ2V4cCc6ICdyZWQnXFxufTtcXG5cXG5cXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XFxuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xcblxcbiAgaWYgKHN0eWxlKSB7XFxuICAgIHJldHVybiAnXFxcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xcbiAgICAgICAgICAgJ1xcXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG59XFxuXFxuXFxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcXG4gIHJldHVybiBzdHI7XFxufVxcblxcblxcbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XFxuICB2YXIgaGFzaCA9IHt9O1xcblxcbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gaGFzaDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XFxuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXFxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcXG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxcbiAgICAgIHZhbHVlICYmXFxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxcbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcXG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcXG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XFxuICBpZiAocHJpbWl0aXZlKSB7XFxuICAgIHJldHVybiBwcmltaXRpdmU7XFxuICB9XFxuXFxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcXG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xcblxcbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XFxuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXFxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxcbiAgaWYgKGlzRXJyb3IodmFsdWUpXFxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XFxuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXFxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xcbiAgICB9XFxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xcbiAgICB9XFxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XFxuXFxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XFxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgYXJyYXkgPSB0cnVlO1xcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcXG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XFxuICB9XFxuXFxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICB9XFxuXFxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcXG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XFxuICB9XFxuXFxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XFxuXFxuICB2YXIgb3V0cHV0O1xcbiAgaWYgKGFycmF5KSB7XFxuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xcbiAgfSBlbHNlIHtcXG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGN0eC5zZWVuLnBvcCgpO1xcblxcbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xcbiAgICB2YXIgc2ltcGxlID0gJ1xcXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXFxcInxcXFwiJC9nLCAnJylcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcXFwiXFxcXFxcXFwnXFxcIilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFxcXFwiL2csICdcXFwiJykgKyAnXFxcXCcnO1xcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XFxuICB9XFxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFxcXCJvYmplY3RcXFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cXG4gIGlmIChpc051bGwodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xcbiAgdmFyIG91dHB1dCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcXG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XFxuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3V0cHV0LnB1c2goJycpO1xcbiAgICB9XFxuICB9XFxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XFxuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcXG4gICAgICAgICAga2V5LCB0cnVlKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIG91dHB1dDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcXG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcXG4gIGlmIChkZXNjLmdldCkge1xcbiAgICBpZiAoZGVzYy5zZXQpIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAoZGVzYy5zZXQpIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XFxuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XFxuICB9XFxuICBpZiAoIXN0cikge1xcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcXG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcXG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxcXG4nKSA+IC0xKSB7XFxuICAgICAgICBpZiAoYXJyYXkpIHtcXG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xcbiAgICAgICAgICB9KS5qb2luKCdcXFxcbicpLnN1YnN0cigyKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN0ciA9ICdcXFxcbicgKyBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xcbiAgICAgICAgICB9KS5qb2luKCdcXFxcbicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgcmV0dXJuIHN0cjtcXG4gICAgfVxcbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xcbiAgICBpZiAobmFtZS5tYXRjaCgvXlxcXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcXFwiJC8pKSB7XFxuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XFxuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcXFwiXFxcXFxcXFwnXFxcIilcXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXFxcXCIvZywgJ1xcXCInKVxcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXFxcInxcXFwiJCkvZywgXFxcIidcXFwiKTtcXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XFxufVxcblxcblxcbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XFxuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XFxuICAgIG51bUxpbmVzRXN0Kys7XFxuICAgIGlmIChjdXIuaW5kZXhPZignXFxcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXFxcdTAwMWJcXFxcW1xcXFxkXFxcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcXG4gIH0sIDApO1xcblxcbiAgaWYgKGxlbmd0aCA+IDYwKSB7XFxuICAgIHJldHVybiBicmFjZXNbMF0gK1xcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcXFxuICcpICtcXG4gICAgICAgICAgICcgJyArXFxuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcXFxuICAnKSArXFxuICAgICAgICAgICAnICcgK1xcbiAgICAgICAgICAgYnJhY2VzWzFdO1xcbiAgfVxcblxcbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcXG59XFxuXFxuXFxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXFxuZnVuY3Rpb24gaXNBcnJheShhcikge1xcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xcbn1cXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcblxcbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XFxufVxcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xcblxcbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xcblxcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XFxufVxcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcXG5cXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcXG59XFxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xcblxcbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xcbn1cXG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XFxuXFxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XFxufVxcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xcbn1cXG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XFxuXFxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcXG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xcbn1cXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcXG5cXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcXG4gIHJldHVybiBpc09iamVjdChlKSAmJlxcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xcbn1cXG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcXG5cXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcXG59XFxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xcblxcbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBwYWQobikge1xcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XFxufVxcblxcblxcbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xcblxcbi8vIDI2IEZlYiAxNjoxOTozNFxcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcXG4gIHZhciBkID0gbmV3IERhdGUoKTtcXG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcXG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XFxufVxcblxcblxcbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XFxufTtcXG5cXG5cXG4vKipcXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXFxuICpcXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXFxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cXG4gKlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcXG4gKiAgICAgcHJvdG90eXBlLlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxcbiAqL1xcbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcblxcbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XFxuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcXG5cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcXG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XFxuICB3aGlsZSAoaS0tKSB7XFxuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcXG4gIH1cXG4gIHJldHVybiBvcmlnaW47XFxufTtcXG5cXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9zdXBwb3J0L2lzQnVmZmVyXFxcIjo3NCxcXFwiX3Byb2Nlc3NcXFwiOjU4LFxcXCJpbmhlcml0c1xcXCI6NTN9XX0se30sWzFdKTtcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L21vY2hhL21vY2hhLmpzXG4gKiogbW9kdWxlIGlkID0gMzEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 313:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(314);\n\n__webpack_require__(315);\n\n__webpack_require__(316);\n\n__webpack_require__(317);\n\n/* endinject */\n\n// In case we run with phantomJS this is needed\n// Waiting for https://github.com/webpack/mocha-loader/pull/27\n\n/* inject:tests */\nif (typeof window !== 'undefined' && window.initMochaPhantomJS) {\n    window.initMochaPhantomJS();\n}\n\nvar assert = __webpack_require__(233).assert;\ndescribe('Example Array', function () {\n    describe('#indexOf()', function () {\n        it('should return -1 when the value is not present', function () {\n            assert.equal(-1, [1, 2, 3].indexOf(5));\n            assert.equal(-1, [1, 2, 3].indexOf(0));\n        });\n    });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy90ZXN0cy5qcz8yNDRjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyogaW5qZWN0OnRlc3RzICovXG5pbXBvcnQgJy4vZGF0YXNvdXJjZS9kYXRhc291cmNlUGx1Z2lucy50ZXN0LmpzJ1xuaW1wb3J0ICcuL3V0aWwvY29sbGVjdGlvbi50ZXN0LmpzJ1xuaW1wb3J0ICcuL3dpZGdldHMvd2lkZ2V0UGx1Z2lucy50ZXN0LmpzJ1xuaW1wb3J0ICcuL2RhdGFzb3VyY2UvcGx1Z2lucy9yYW5kb21EYXRhc291cmNlLnRlc3QuanMnXG4vKiBlbmRpbmplY3QgKi9cblxuLy8gSW4gY2FzZSB3ZSBydW4gd2l0aCBwaGFudG9tSlMgdGhpcyBpcyBuZWVkZWRcbi8vIFdhaXRpbmcgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL21vY2hhLWxvYWRlci9wdWxsLzI3XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmluaXRNb2NoYVBoYW50b21KUykge1xuICAgIHdpbmRvdy5pbml0TW9jaGFQaGFudG9tSlMoKTtcbn1cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5kZXNjcmliZSgnRXhhbXBsZSBBcnJheScsIGZ1bmN0aW9uKCkge1xuICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCgtMSwgWzEsMiwzXS5pbmRleE9mKDUpKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCgtMSwgWzEsMiwzXS5pbmRleE9mKDApKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy90ZXN0cy5qc1xuICoqLyJdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 314:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _chai = __webpack_require__(233);\n\nvar _datasourcePlugins = __webpack_require__(203);\n\nvar _datasourcePlugins2 = _interopRequireDefault(_datasourcePlugins);\n\nvar _store = __webpack_require__(297);\n\nvar _store2 = _interopRequireDefault(_store);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\ndescribe('Datasource Plugins', function () {\n    describe('#register() && #getPlugin()', function () {\n        it(\"It's possible to register and get back a plugin\", function () {\n            _datasourcePlugins2.default.store = _store2.default;\n            _datasourcePlugins2.default.register({\n                TYPE_INFO: {\n                    type: 'foo'\n                }\n            });\n\n            var plugin = _datasourcePlugins2.default.getPlugin('foo');\n\n            _chai.assert.isOk(plugin);\n            _chai.assert.equal('foo', plugin.type);\n        });\n    });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9kYXRhc291cmNlL2RhdGFzb3VyY2VQbHVnaW5zLnRlc3QuanM/NzIwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2Fzc2VydH0gZnJvbSAnY2hhaSdcbmltcG9ydCBEYXRhc291cmNlUGx1Z2lucyBmcm9tICcuL2RhdGFzb3VyY2VQbHVnaW5zJ1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uL3N0b3JlJ1xuXG5cbmRlc2NyaWJlKCdEYXRhc291cmNlIFBsdWdpbnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVzY3JpYmUoJyNyZWdpc3RlcigpICYmICNnZXRQbHVnaW4oKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoXCJJdCdzIHBvc3NpYmxlIHRvIHJlZ2lzdGVyIGFuZCBnZXQgYmFjayBhIHBsdWdpblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBEYXRhc291cmNlUGx1Z2lucy5zdG9yZSA9IHN0b3JlO1xuICAgICAgICAgICAgRGF0YXNvdXJjZVBsdWdpbnMucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIFRZUEVfSU5GTzoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZm9vJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgcGx1Z2luID0gRGF0YXNvdXJjZVBsdWdpbnMuZ2V0UGx1Z2luKCdmb28nKTtcblxuICAgICAgICAgICAgYXNzZXJ0LmlzT2socGx1Z2luKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCgnZm9vJywgcGx1Z2luLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9kYXRhc291cmNlL2RhdGFzb3VyY2VQbHVnaW5zLnRlc3QuanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 315:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _collection = __webpack_require__(199);\n\nvar c = _interopRequireWildcard(_collection);\n\nvar _chai = __webpack_require__(233);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\ndescribe('Collections', function () {\n    describe('chunk', function () {\n        it(\"Splits correctly\", function () {\n            var testChunks = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]];\n\n            var chunks = c.chunk([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, function (chunk, i) {\n                _chai.assert.deepEqual(testChunks[i], chunk);\n            });\n\n            _chai.assert.deepEqual(testChunks, chunks);\n        });\n\n        it(\"Can deal with null\", function () {\n            var chunks = c.chunk(null, 3, function (chunk, i) {\n                _chai.assert.fail(\"Must not call the callback function\");\n            });\n\n            _chai.assert.deepEqual(chunks, []);\n        });\n\n        it(\"Can deal with undefined\", function () {\n            var chunks = c.chunk(undefined, 3, function (chunk, i) {\n                _chai.assert.fail(\"Must not call the callback function\");\n            });\n\n            _chai.assert.deepEqual(chunks, []);\n        });\n    });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy91dGlsL2NvbGxlY3Rpb24udGVzdC5qcz9hYzM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGMgZnJvbSAnLi9jb2xsZWN0aW9uJ1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJ2NoYWknXG5cbmRlc2NyaWJlKCdDb2xsZWN0aW9ucycsIGZ1bmN0aW9uICgpIHtcbiAgICBkZXNjcmliZSgnY2h1bmsnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0KFwiU3BsaXRzIGNvcnJlY3RseVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgdGVzdENodW5rcyA9IFtbMSwyLDNdLCBbNCw1LDZdLCBbNyw4LDldLCBbMTBdXVxuXG4gICAgICAgICAgICBsZXQgY2h1bmtzID0gYy5jaHVuayhbMSwyLDMsNCw1LDYsNyw4LDksMTBdLCAzLCAoY2h1bmssIGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKHRlc3RDaHVua3NbaV0sIGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKHRlc3RDaHVua3MsIGNodW5rcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiQ2FuIGRlYWwgd2l0aCBudWxsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCBjaHVua3MgPSBjLmNodW5rKG51bGwsIDMsIChjaHVuaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKFwiTXVzdCBub3QgY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChjaHVua3MsIFtdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJDYW4gZGVhbCB3aXRoIHVuZGVmaW5lZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgY2h1bmtzID0gYy5jaHVuayh1bmRlZmluZWQsIDMsIChjaHVuaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKFwiTXVzdCBub3QgY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChjaHVua3MsIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvdXRpbC9jb2xsZWN0aW9uLnRlc3QuanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 316:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _chai = __webpack_require__(233);\n\nvar _widgetPlugins = __webpack_require__(190);\n\nvar _widgetPlugins2 = _interopRequireDefault(_widgetPlugins);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\ndescribe('Widget Plugins', function () {\n    describe('#register() && #getWidget()', function () {\n        it(\"It's possible to register and get back a plugin\", function () {\n            _widgetPlugins2.default.register({\n                TYPE_INFO: {\n                    type: 'foo'\n                }\n            });\n\n            var plugin = _widgetPlugins2.default.getPlugin('foo');\n\n            _chai.assert.isOk(plugin);\n            _chai.assert.equal('foo', plugin.type);\n        });\n    });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy93aWRnZXRzL3dpZGdldFBsdWdpbnMudGVzdC5qcz84YmE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXNzZXJ0fSBmcm9tICdjaGFpJ1xuaW1wb3J0IFdpZGdldFBsdWdpbnMgZnJvbSAnLi93aWRnZXRQbHVnaW5zJ1xuXG5cbmRlc2NyaWJlKCdXaWRnZXQgUGx1Z2lucycsIGZ1bmN0aW9uICgpIHtcbiAgICBkZXNjcmliZSgnI3JlZ2lzdGVyKCkgJiYgI2dldFdpZGdldCgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpdChcIkl0J3MgcG9zc2libGUgdG8gcmVnaXN0ZXIgYW5kIGdldCBiYWNrIGEgcGx1Z2luXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFdpZGdldFBsdWdpbnMucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIFRZUEVfSU5GTzoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZm9vJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgcGx1Z2luID0gV2lkZ2V0UGx1Z2lucy5nZXRQbHVnaW4oJ2ZvbycpO1xuXG4gICAgICAgICAgICBhc3NlcnQuaXNPayhwbHVnaW4pO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKCdmb28nLCBwbHVnaW4udHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvd2lkZ2V0cy93aWRnZXRQbHVnaW5zLnRlc3QuanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 317:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _chai = __webpack_require__(233);\n\nvar _randomDatasource = __webpack_require__(300);\n\nvar RandomSource = _interopRequireWildcard(_randomDatasource);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\ndescribe('Random Datasource', function () {\n\n    it(\"Can create instance\", function () {\n        var randomSource = new RandomSource.Datasource();\n        _chai.assert.isOk(randomSource);\n    });\n\n    describe('fetch data', function () {\n\n        it(\"Can get new value\", function () {\n            var randomSource = new RandomSource.Datasource();\n\n            var values = randomSource.getValues();\n\n            _chai.assert.isArray(values);\n            _chai.assert.equal(values.length, 1);\n            _chai.assert.isAtLeast(values[0].value, 1);\n            _chai.assert.isAtMost(values[0].value, 100);\n        });\n\n        it(\"Can get all past value\", function () {\n            var randomSource = new RandomSource.Datasource();\n\n            var newValues = randomSource.getValues();\n            var values = randomSource.getValues();\n\n            _chai.assert.isArray(values);\n            _chai.assert.equal(values.length, 2);\n        });\n        it(\"Can get past values returns new array\", function () {\n            var randomSource = new RandomSource.Datasource();\n\n            var values = randomSource.getValues();\n            var newValues = randomSource.getValues();\n\n            _chai.assert.isArray(values);\n            _chai.assert.equal(values.length, 1);\n        });\n    });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9kYXRhc291cmNlL3BsdWdpbnMvcmFuZG9tRGF0YXNvdXJjZS50ZXN0LmpzPzUyNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHthc3NlcnR9IGZyb20gJ2NoYWknXG5pbXBvcnQgKiBhcyBSYW5kb21Tb3VyY2UgZnJvbSAnLi9yYW5kb21EYXRhc291cmNlJ1xuXG5kZXNjcmliZSgnUmFuZG9tIERhdGFzb3VyY2UnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICBpdChcIkNhbiBjcmVhdGUgaW5zdGFuY2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgcmFuZG9tU291cmNlID0gbmV3IFJhbmRvbVNvdXJjZS5EYXRhc291cmNlKCk7XG4gICAgICAgIGFzc2VydC5pc09rKHJhbmRvbVNvdXJjZSk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVzY3JpYmUoJ2ZldGNoIGRhdGEnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBpdChcIkNhbiBnZXQgbmV3IHZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCByYW5kb21Tb3VyY2UgPSBuZXcgUmFuZG9tU291cmNlLkRhdGFzb3VyY2UoKTtcblxuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHJhbmRvbVNvdXJjZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXNzZXJ0LmlzQXJyYXkodmFsdWVzKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCh2YWx1ZXMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgIGFzc2VydC5pc0F0TGVhc3QodmFsdWVzWzBdLnZhbHVlLCAxKTtcbiAgICAgICAgICAgIGFzc2VydC5pc0F0TW9zdCh2YWx1ZXNbMF0udmFsdWUsIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiQ2FuIGdldCBhbGwgcGFzdCB2YWx1ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZG9tU291cmNlID0gbmV3IFJhbmRvbVNvdXJjZS5EYXRhc291cmNlKCk7XG5cbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZXMgPSByYW5kb21Tb3VyY2UuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gcmFuZG9tU291cmNlLmdldFZhbHVlcygpO1xuXG4gICAgICAgICAgICBhc3NlcnQuaXNBcnJheSh2YWx1ZXMpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHZhbHVlcy5sZW5ndGgsIDIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoXCJDYW4gZ2V0IHBhc3QgdmFsdWVzIHJldHVybnMgbmV3IGFycmF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCByYW5kb21Tb3VyY2UgPSBuZXcgUmFuZG9tU291cmNlLkRhdGFzb3VyY2UoKTtcblxuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHJhbmRvbVNvdXJjZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZXMgPSByYW5kb21Tb3VyY2UuZ2V0VmFsdWVzKCk7XG5cbiAgICAgICAgICAgIGFzc2VydC5pc0FycmF5KHZhbHVlcyk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwodmFsdWVzLmxlbmd0aCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICB9KVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL2RhdGFzb3VyY2UvcGx1Z2lucy9yYW5kb21EYXRhc291cmNlLnRlc3QuanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 318:
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {\r\n\tdelete __webpack_require__.c[module.id];\r\n\tif(typeof window !== \"undefined\" && window.mochaPhantomJS)\r\n\t\tmochaPhantomJS.run();\r\n\telse\r\n\t\tmocha.run();\r\n});\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS1sb2FkZXIvc3RhcnQuanM/NGYxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG5cdGRlbGV0ZSByZXF1aXJlLmNhY2hlW21vZHVsZS5pZF07XHJcblx0aWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubW9jaGFQaGFudG9tSlMpXHJcblx0XHRtb2NoYVBoYW50b21KUy5ydW4oKTtcclxuXHRlbHNlXHJcblx0XHRtb2NoYS5ydW4oKTtcclxufSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vY2hhLWxvYWRlci9zdGFydC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }

});